package org.stypox.dicio.io.wake.sherpa

import android.content.Context
import android.util.Log
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.cancel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.launch
import org.stypox.dicio.io.wake.WakeDevice
import org.stypox.dicio.io.wake.WakeState
import org.stypox.dicio.ui.util.Progress
import org.stypox.dicio.util.DebugLogger
import org.stypox.dicio.util.AudioDebugSaver
import org.stypox.dicio.util.measureTimeAndLog
import org.stypox.dicio.util.ModelVariantDetector
import org.stypox.dicio.util.PermissionHelper
import org.stypox.dicio.util.ModelPathManager
import com.k2fsa.sherpa.onnx.KeywordSpotter
import com.k2fsa.sherpa.onnx.KeywordSpotterConfig
import com.k2fsa.sherpa.onnx.OnlineModelConfig
import com.k2fsa.sherpa.onnx.OnlineTransducerModelConfig
import com.k2fsa.sherpa.onnx.FeatureConfig
import com.k2fsa.sherpa.onnx.OnlineStream
import java.io.File
import java.io.IOException
import kotlin.math.abs

class SherpaOnnxWakeDevice(
    private val appContext: Context,
) : WakeDevice {
    private val _state: MutableStateFlow<WakeState> = MutableStateFlow(WakeState.NotLoaded)
    override val state: StateFlow<WakeState> = _state

    private var keywordSpotter: KeywordSpotter? = null
    private var stream: OnlineStream? = null
    private val scope = CoroutineScope(Dispatchers.IO)

    private val modelDir = File(appContext.filesDir, "sherpa_onnx_kws")
    private val keywordsFile = File(modelDir, "keywords.txt")

    init {
        Log.d(TAG, "üèóÔ∏è [INIT] SherpaOnnxWakeDeviceÊûÑÈÄ†ÂáΩÊï∞ÂºÄÂßã")
        DebugLogger.logWakeWord(TAG, "üöÄ Initializing SherpaOnnxWakeDevice")
        Log.d(TAG, "üöÄ [INIT] ÂêØÂä®ÂçèÁ®ãÂàùÂßãÂåñ")
        scope.launch {
            Log.d(TAG, "üîÑ [COROUTINE] initialize()ÂçèÁ®ãÂºÄÂßãÊâßË°å")
            initialize()
            Log.d(TAG, "‚úÖ [COROUTINE] initialize()ÂçèÁ®ãÊâßË°åÂÆåÊàê")
        }
        Log.d(TAG, "‚úÖ [INIT] SherpaOnnxWakeDeviceÊûÑÈÄ†ÂáΩÊï∞ÂÆåÊàê")
    }

    private suspend fun initialize() {
        _state.value = WakeState.Loading
        try {
            // ‰ºòÂÖàÊ£ÄÊü• assets ‰∏≠ÊòØÂê¶ÊúâÊ®°ÂûãÊñá‰ª∂
            val hasAssetsModels = checkAssetsModelsAvailable()
            val useAssetManager = hasAssetsModels || ModelVariantDetector.shouldUseAssetManager(appContext)
            val variantName = ModelVariantDetector.getVariantName(appContext)
            
            DebugLogger.logModelManagement(TAG, "üè∑Ô∏è ÂΩìÂâçÊûÑÂª∫Âèò‰Ωì: $variantName")
            DebugLogger.logModelManagement(TAG, "üì¶ Assets ‰∏≠ÊúâÊ®°Âûã: $hasAssetsModels")
            DebugLogger.logModelManagement(TAG, "üì¶ ‰ΩøÁî® AssetManager: $useAssetManager")

            val config: KeywordSpotterConfig
            
            if (useAssetManager) {
                // ‰ΩøÁî® AssetManager ÊñπÂºèÔºà‰ºòÂÖà‰ΩøÁî® assets ‰∏≠ÁöÑÊ®°ÂûãÔºâ
                DebugLogger.logModelManagement(TAG, "üéØ ‰ΩøÁî® Assets ‰∏≠ÁöÑ SherpaOnnx KWS Ê®°Âûã")
                config = createKwsConfig(useAssetManager)
                keywordSpotter = measureTimeAndLog(TAG, "Load SherpaOnnx KWS model from assets") {
                    KeywordSpotter(
                        assetManager = appContext.assets,
                        config = config
                    )
                }
            } else {
                // ‰ΩøÁî®Êñá‰ª∂Á≥ªÁªüË∑ØÂæÑÊñπÂºèÔºàÂõûÈÄÄÊñπÊ°àÔºâ
                DebugLogger.logModelManagement(TAG, "üîÑ ÂõûÈÄÄÂà∞Â§ñÈÉ®Â≠òÂÇ®Ê®°ÂûãÊñá‰ª∂")
                
                // ÊòæÁ§∫Ë∑ØÂæÑÁä∂ÊÄÅ‰ø°ÊÅØ
                val pathStatus = ModelPathManager.getAllPathsStatus(appContext)
                DebugLogger.logModelManagement(TAG, pathStatus)
                
                // Ëé∑ÂèñÂ§ñÈÉ®Â≠òÂÇ®Ë∑ØÂæÑ
                val externalModelPath = ModelPathManager.getExternalKwsModelsPath(appContext)
                DebugLogger.logModelManagement(TAG, "üìÇ Â§ñÈÉ®Â≠òÂÇ®Ë∑ØÂæÑ: $externalModelPath")
                
                // ‚ö†Ô∏è ÂÖ≥ÈîÆ‰øÆÂ§çÔºöNative Â∫ìÂú® Android 11+ ‰∏äÂèØËÉΩÊó†Ê≥ïËÆøÈóÆ /sdcard/ Ë∑ØÂæÑ
                // ÈúÄË¶ÅÂ∞ÜÊ®°ÂûãÊñá‰ª∂Â§çÂà∂Âà∞Â∫îÁî®ÂÜÖÈÉ®Â≠òÂÇ®
                val internalModelPath = File(appContext.filesDir, "sherpa_onnx_kws")
                DebugLogger.logModelManagement(TAG, "üìÇ ÂÜÖÈÉ®Â≠òÂÇ®Ë∑ØÂæÑ: ${internalModelPath.absolutePath}")
                
                // Ê£ÄÊü•Â§ñÈÉ®Â≠òÂÇ®ÁöÑÊ®°ÂûãÊñá‰ª∂ÊòØÂê¶Â≠òÂú®
                if (!checkSherpaModelFilesAccess(externalModelPath)) {
                    // ËÆæÁΩÆ‰∏∫ ErrorLoading ËÄåÈùû NotDownloadedÔºåÈÅøÂÖçÊó†ÈôêÈáçËØï
                    _state.value = WakeState.ErrorLoading(IOException("SherpaOnnx KWS Ê®°ÂûãÊñá‰ª∂‰∏çÂèØËÆøÈóÆ: $externalModelPath"))
                    DebugLogger.logWakeWordError(TAG, "‚ùå SherpaOnnx KWS Ê®°ÂûãÊñá‰ª∂‰∏çÂèØËÆøÈóÆ")
                    DebugLogger.logWakeWordError(TAG, "üí° ÂΩìÂâçÂ∞ùËØïË∑ØÂæÑ: $externalModelPath")
                    
                    // ÊòæÁ§∫Êé®ËçêÁöÑÊé®ÈÄÅÂëΩ‰ª§
                    val pushCommands = ModelPathManager.getModelPushCommands(appContext)
                    DebugLogger.logModelManagement(TAG, "üìã Êé®ËçêÁöÑÊ®°ÂûãÊé®ÈÄÅÂëΩ‰ª§:")
                    pushCommands.forEach { cmd ->
                        DebugLogger.logModelManagement(TAG, cmd)
                    }
                    return
                }
                
                DebugLogger.logModelManagement(TAG, "‚úÖ Â§ñÈÉ®Â≠òÂÇ®Ê®°ÂûãÊñá‰ª∂Ê£ÄÊü•ÈÄöËøá")
                
                // Â∞ÜÊ®°ÂûãÊñá‰ª∂Â§çÂà∂Âà∞ÂÜÖÈÉ®Â≠òÂÇ®ÔºàNative Â∫ìÂèØ‰ª•ËÆøÈóÆÔºâ
                try {
                    copyModelsToInternalStorage(externalModelPath, internalModelPath.absolutePath)
                } catch (e: Exception) {
                    _state.value = WakeState.ErrorLoading(e)
                    DebugLogger.logWakeWordError(TAG, "‚ùå Â§çÂà∂Ê®°ÂûãÊñá‰ª∂Âà∞ÂÜÖÈÉ®Â≠òÂÇ®Â§±Ë¥•: ${e.message}", e)
                    return
                }
                
                // ‰ΩøÁî®ÂÜÖÈÉ®Â≠òÂÇ®Ë∑ØÂæÑÂàõÂª∫ÈÖçÁΩÆ
                config = createKwsConfigWithPath(internalModelPath.absolutePath)
                
                // Â∞ùËØïÂä†ËΩΩ KeywordSpotterÔºåÊçïËé∑ÂèØËÉΩÁöÑ native ÂºÇÂ∏∏
                try {
                    keywordSpotter = measureTimeAndLog(TAG, "Load SherpaOnnx KWS model from internal storage") {
                        KeywordSpotter(config = config)
                    }
                } catch (e: Throwable) {
                    // sherpa-onnx native Â∫ìÂèØËÉΩ‰ºöÊäõÂá∫ UnsatisfiedLinkError ÊàñÂÖ∂‰ªñ native ÂºÇÂ∏∏
                    _state.value = WakeState.ErrorLoading(e)
                    DebugLogger.logWakeWordError(TAG, "‚ùå KeywordSpotter ÂàùÂßãÂåñÂ§±Ë¥• (ÂèØËÉΩÊòØÊùÉÈôêÊàñÊñá‰ª∂ËÆøÈóÆÈóÆÈ¢ò): ${e.message}", e)
                    DebugLogger.logWakeWordError(TAG, "üí° ËøôÂèØËÉΩÊòØ Android Â≠òÂÇ®ÊùÉÈôêÈóÆÈ¢òÔºåËØ∑Â∞ùËØïÔºö")
                    DebugLogger.logWakeWordError(TAG, "   1. Ê£ÄÊü•Â∫îÁî®ÊòØÂê¶ÊúâÂ≠òÂÇ®ÊùÉÈôê")
                    DebugLogger.logWakeWordError(TAG, "   2. Â∞ùËØï‰ΩøÁî® withModels Âèò‰Ωì")
                    DebugLogger.logWakeWordError(TAG, "   3. Ê£ÄÊü• SELinux ÊùÉÈôêËÆæÁΩÆ")
                    return
                }
            }
            
            stream = keywordSpotter?.createStream()

            if (keywordSpotter != null && stream != null) {
                _state.value = WakeState.Loaded
                DebugLogger.logWakeWord(TAG, "‚úÖ SherpaOnnx KWS model loaded successfully")
                DebugLogger.logWakeWord(TAG, "üîó KeywordSpotterÂÆû‰æãID: ${keywordSpotter.hashCode()}")
            } else {
                _state.value = WakeState.ErrorLoading(IOException("Failed to initialize SherpaOnnx KeywordSpotter or stream"))
                DebugLogger.logWakeWordError(TAG, "‚ùå Failed to initialize SherpaOnnx KeywordSpotter or stream")
            }
        } catch (e: Exception) {
            _state.value = WakeState.ErrorLoading(e)
            DebugLogger.logWakeWordError(TAG, "‚ùå Error initializing SherpaOnnxWakeDevice: ${e.message}", e)
        }
    }

    /**
     * Ê£ÄÊü• assets ‰∏≠ÊòØÂê¶Êúâ SherpaOnnx KWS Ê®°ÂûãÊñá‰ª∂
     */
    private fun checkAssetsModelsAvailable(): Boolean {
        val requiredFiles = listOf(
            "models/sherpa_onnx_kws/encoder-epoch-12-avg-2-chunk-16-left-64.onnx",
            "models/sherpa_onnx_kws/decoder-epoch-12-avg-2-chunk-16-left-64.onnx",
            "models/sherpa_onnx_kws/joiner-epoch-12-avg-2-chunk-16-left-64.onnx",
            "models/sherpa_onnx_kws/keywords.txt",
            "models/sherpa_onnx_kws/tokens.txt"
        )
        
        return try {
            val allFilesExist = requiredFiles.all { fileName ->
                try {
                    appContext.assets.open(fileName).use { 
                        DebugLogger.logModelManagement(TAG, "‚úÖ Assets Êñá‰ª∂Â≠òÂú®: $fileName")
                        true 
                    }
                } catch (e: Exception) {
                    DebugLogger.logModelManagement(TAG, "‚ùå Assets Êñá‰ª∂Áº∫Â§±: $fileName")
                    false
                }
            }
            
            if (allFilesExist) {
                DebugLogger.logModelManagement(TAG, "üéâ Assets ‰∏≠ÊâÄÊúâ SherpaOnnx KWS Ê®°ÂûãÊñá‰ª∂ÈÉΩÂèØÁî®")
            } else {
                DebugLogger.logModelManagement(TAG, "‚ö†Ô∏è Assets ‰∏≠Áº∫Â∞ëÈÉ®ÂàÜ SherpaOnnx KWS Ê®°ÂûãÊñá‰ª∂")
            }
            
            allFilesExist
        } catch (e: Exception) {
            DebugLogger.logWakeWordError(TAG, "‚ùå Ê£ÄÊü• Assets Ê®°ÂûãÊñá‰ª∂Â§±Ë¥•: ${e.message}")
            false
        }
    }

    private fun createKwsConfig(useAssetManager: Boolean): KeywordSpotterConfig {
        return if (useAssetManager) {
            // ‰ΩøÁî® AssetManager ÊñπÂºèÔºàwithModels Âèò‰ΩìÔºâ
            KeywordSpotterConfig(
                featConfig = FeatureConfig(
                    sampleRate = 16000,
                    featureDim = 80
                ),
                modelConfig = OnlineModelConfig(
                    transducer = OnlineTransducerModelConfig(
                        encoder = "models/sherpa_onnx_kws/encoder-epoch-12-avg-2-chunk-16-left-64.onnx",
                        decoder = "models/sherpa_onnx_kws/decoder-epoch-12-avg-2-chunk-16-left-64.onnx",
                        joiner = "models/sherpa_onnx_kws/joiner-epoch-12-avg-2-chunk-16-left-64.onnx"
                    ),
                    tokens = "models/sherpa_onnx_kws/tokens.txt",
                    modelType = "zipformer2",
                    numThreads = 1,
                    provider = "cpu"
                ),
                maxActivePaths = 4,
                keywordsFile = "models/sherpa_onnx_kws/keywords.txt",
                keywordsScore = 1.5f,
                keywordsThreshold = 0.25f,
                numTrailingBlanks = 2
            )
        } else {
            // ‰ΩøÁî®Êñá‰ª∂Á≥ªÁªüË∑ØÂæÑÊñπÂºèÔºànoModels Âèò‰ΩìÔºâ
            val externalModelPath = ModelPathManager.getExternalKwsModelsPath(appContext)
            KeywordSpotterConfig(
                featConfig = FeatureConfig(
                    sampleRate = 16000,
                    featureDim = 80
                ),
                modelConfig = OnlineModelConfig(
                    transducer = OnlineTransducerModelConfig(
                        encoder = "$externalModelPath/encoder-epoch-12-avg-2-chunk-16-left-64.onnx",
                        decoder = "$externalModelPath/decoder-epoch-12-avg-2-chunk-16-left-64.onnx",
                        joiner = "$externalModelPath/joiner-epoch-12-avg-2-chunk-16-left-64.onnx"
                    ),
                    tokens = "$externalModelPath/tokens.txt",
                    modelType = "zipformer2",
                    numThreads = 1,
                    provider = "cpu"
                ),
                maxActivePaths = 4,
                keywordsFile = "$externalModelPath/keywords.txt",
                keywordsScore = 1.5f,
                keywordsThreshold = 0.25f,
                numTrailingBlanks = 2
            )
        }
    }

    override fun download() {
        // SherpaOnnx Ê®°Âûã"‰∏ãËΩΩ"ÈÄªËæë - ‰ºòÂÖà‰ΩøÁî® assetsÔºåÂõûÈÄÄÂà∞Â§ñÈÉ®Â≠òÂÇ®
        if (_state.value == WakeState.NotDownloaded || _state.value is WakeState.ErrorLoading) {
            // Èò≤Ê≠¢ÈáçÂ§çÂàùÂßãÂåñÔºöÂÖàËÆæÁΩÆ‰∏∫ Loading
            _state.value = WakeState.Loading
            
            scope.launch {
                val hasAssetsModels = checkAssetsModelsAvailable()
                
                if (hasAssetsModels) {
                    DebugLogger.logModelManagement(TAG, "üéØ Ê£ÄÊµãÂà∞ Assets ‰∏≠ÊúâÊ®°ÂûãÊñá‰ª∂ÔºåÁõ¥Êé•‰ΩøÁî®")
                    initialize()
                } else {
                    DebugLogger.logModelManagement(TAG, "üîÑ Assets ‰∏≠Êó†Ê®°ÂûãÊñá‰ª∂ÔºåÂ∞ùËØï‰ΩøÁî®Â§ñÈÉ®Â≠òÂÇ®...")
                    
                    // Ê£ÄÊü•ÊùÉÈôê
                    if (!PermissionHelper.hasExternalStoragePermission(appContext)) {
                        DebugLogger.logWakeWordError(TAG, "‚ùå Áº∫Â∞ëÂ§ñÈÉ®Â≠òÂÇ®ÊùÉÈôê")
                        DebugLogger.logWakeWordError(TAG, "üí° ËØ∑Âú®Â∫îÁî®ËÆæÁΩÆ‰∏≠Êéà‰∫àÂ≠òÂÇ®ÊùÉÈôêÂêéÈáçËØï")
                        _state.value = WakeState.ErrorLoading(SecurityException("Áº∫Â∞ëÂ§ñÈÉ®Â≠òÂÇ®ÊùÉÈôê"))
                        return@launch
                    }
                    
                    copyModelsForNoModelsVariant()
                    initialize()
                }
            }
        } else {
            DebugLogger.logModelManagement(TAG, "SherpaOnnx models already available or loading, skipping duplicate download call.")
        }
    }
    
    private suspend fun copyModelsForNoModelsVariant() {
        try {
            val externalModelPath = ModelPathManager.getExternalKwsModelsPath(appContext)
            val externalDir = java.io.File(externalModelPath)
            
            // ÂàõÂª∫Â§ñÈÉ®ÁõÆÂΩï
            if (!externalDir.exists()) {
                externalDir.mkdirs()
                DebugLogger.logModelManagement(TAG, "üìÅ ÂàõÂª∫Â§ñÈÉ®Ê®°ÂûãÁõÆÂΩï: $externalModelPath")
            }
            
            // ÊòæÁ§∫Êé®ËçêÁöÑÊé®ÈÄÅÂëΩ‰ª§
            val pushCommands = ModelPathManager.getModelPushCommands(appContext)
            DebugLogger.logModelManagement(TAG, "‚ö†Ô∏è noModelsÂèò‰ΩìÈúÄË¶ÅÊâãÂä®Êé®ÈÄÅÊ®°ÂûãÊñá‰ª∂")
            pushCommands.forEach { cmd ->
                DebugLogger.logModelManagement(TAG, cmd)
            }
            
        } catch (e: Exception) {
            DebugLogger.logWakeWordError(TAG, "‚ùå ËÆæÁΩÆÂ§ñÈÉ®Ê®°ÂûãÁõÆÂΩïÂ§±Ë¥•: ${e.message}", e)
        }
    }

    /**
     * Ê£ÄÊü•SherpaOnnxÊ®°ÂûãÊñá‰ª∂ÊòØÂê¶ÂèØËÆøÈóÆ
     */
    private fun checkSherpaModelFilesAccess(modelBasePath: String): Boolean {
        val requiredFiles = listOf(
            "encoder-epoch-12-avg-2-chunk-16-left-64.onnx",
            "decoder-epoch-12-avg-2-chunk-16-left-64.onnx", 
            "joiner-epoch-12-avg-2-chunk-16-left-64.onnx",
            "keywords.txt",
            "tokens.txt"
        )
        
        return try {
            requiredFiles.all { fileName ->
                val file = File(modelBasePath, fileName)
                val exists = file.exists()
                // ÁßªÈô§ canRead Ê£ÄÊü•ÔºåÂè™Ê£ÄÊü•Êñá‰ª∂ÊòØÂê¶Â≠òÂú®ÔºàÁÆÄÂåñÊùÉÈôêÂ§ÑÁêÜÔºâ
                
                DebugLogger.logModelManagement(TAG, "üìÑ Ê£ÄÊü•Êñá‰ª∂: $fileName - ${if (exists) "‚úÖ" else "‚ùå"}")
                
                exists  // Âè™Ê£ÄÊü•Â≠òÂú®ÊÄß
            }
        } catch (e: Exception) {
            DebugLogger.logWakeWordError(TAG, "‚ùå Ê£ÄÊü•Ê®°ÂûãÊñá‰ª∂Â§±Ë¥•: ${e.message}")
            false
        }
    }

    override fun processFrame(audio16bitPcm: ShortArray): Boolean {
        // Ê£ÄÊü•Ê®°ÂûãÁä∂ÊÄÅÔºåÂ¶ÇÊûúÊú™Âä†ËΩΩÂàôËøîÂõûfalseËÄå‰∏çÊòØÊäõÂºÇÂ∏∏
        when (val currentState = _state.value) {
            WakeState.Loaded -> {
                // Ê®°ÂûãÂ∑≤Âä†ËΩΩÔºåÁªßÁª≠Â§ÑÁêÜ
            }
            WakeState.Loading -> {
                // Ê®°ÂûãÊ≠£Âú®Âä†ËΩΩ‰∏≠ÔºåËøîÂõûfalse‰ΩÜ‰∏çÊä•Èîô
                return false
            }
            WakeState.NotLoaded, WakeState.NotDownloaded -> {
                DebugLogger.logWakeWord(TAG, "‚è≥ SherpaOnnx model not ready, current state: $currentState")
                return false
            }
            is WakeState.Downloading -> {
                DebugLogger.logWakeWord(TAG, "‚è≥ SherpaOnnx model downloading, progress: ${currentState.progress}")
                return false
            }
            is WakeState.ErrorDownloading -> {
                DebugLogger.logWakeWordError(TAG, "‚ùå SherpaOnnx model download error: ${currentState.throwable.message}")
                return false
            }
            is WakeState.ErrorLoading -> {
                DebugLogger.logWakeWordError(TAG, "‚ùå SherpaOnnx model in error state: ${currentState.throwable.message}")
                return false
            }
            WakeState.NoMicOrNotificationPermission -> {
                DebugLogger.logWakeWordError(TAG, "‚ùå No microphone or notification permission")
                return false
            }
        }

        if (audio16bitPcm.size != frameSize()) {
            DebugLogger.logWakeWordError(TAG, "‚ùå Invalid frame size: ${audio16bitPcm.size}, expected: ${frameSize()}")
            throw IllegalArgumentException(
                "SherpaOnnx can only process audio frames of ${frameSize()} samples"
            )
        }

        // Convert ShortArray to FloatArray for SherpaOnnx
        val audioFloat = FloatArray(audio16bitPcm.size) { i -> audio16bitPcm[i].toFloat() / 32768.0f }

        return try {
            // ËÆ°ÁÆóÈü≥È¢ëÂπÖÂ∫¶Áî®‰∫éË∞ÉËØï
            val amplitude = audio16bitPcm.maxOfOrNull { abs(it.toInt()) }?.toFloat() ?: 0.0f

            // Â§ÑÁêÜÈü≥È¢ëÂ∏ßÂπ∂Ëé∑ÂèñÊ£ÄÊµãÁªìÊûú
            val detected = measureTimeAndLog(TAG, "Process SherpaOnnx audio frame") {
                processSherpaFrame(audioFloat)
            }

            // SherpaOnnx does not directly provide confidence per frame.
            // We might need to infer it or use a fixed value for logging.
            val confidence = if (detected) 1.0f else 0.0f // Placeholder

            // ‰øùÂ≠òÊúâÈü≥È¢ë‰ø°Âè∑ÁöÑÈü≥È¢ëÊï∞ÊçÆÁî®‰∫éË∞ÉËØï
            if (amplitude > 0.0f) {
                AudioDebugSaver.saveWakeAudio(appContext, audio16bitPcm, amplitude, confidence)
            }

            // ËÆ∞ÂΩïÊ£ÄÊµãÁªìÊûú
            if (confidence > 0.0f) { // Âè™ËÆ∞ÂΩïÊúâÊïàÊ£ÄÊµãÁªìÊûú
                DebugLogger.logWakeWordDetection(TAG, confidence, 0.25f, detected)
            }
            DebugLogger.logAudioStats(TAG, audio16bitPcm.size, amplitude, 0.25f)

            detected
        } catch (t: Throwable) {
            DebugLogger.logWakeWordError(TAG, "‚ùå Error processing SherpaOnnx audio frame: ${t.message}", t)
            _state.value = WakeState.ErrorLoading(t) // Transition to error state
            throw t
        }
    }

    private fun processSherpaFrame(audioFloat: FloatArray): Boolean {
        stream?.acceptWaveform(audioFloat, sampleRate = 16000)

        var detected = false
        while (keywordSpotter?.isReady(stream!!) == true) {
            keywordSpotter?.decode(stream!!)
            val result = keywordSpotter?.getResult(stream!!)
            val keyword = result?.keyword ?: ""

            if (keyword.isNotEmpty()) {
                DebugLogger.logWakeWord(TAG, "üéØ SherpaOnnx KWS detected keyword: '$keyword'")
                detected = true
                keywordSpotter?.reset(stream!!) // Reset stream after detection
                break // Exit loop after first detection
            }
        }
        return detected
    }

    override fun frameSize(): Int {
        // SherpaOnnx typically uses 16kHz audio. Frame size depends on internal buffer.
        // A common frame size for 16kHz audio is 1600 samples (100ms).
        // This should match the AudioRecord buffer size.
        return 1600 // Example frame size, adjust as needed
    }

    override fun destroy() {
        DebugLogger.logWakeWord(TAG, "üßπ Destroying SherpaOnnxWakeDevice resources")
        
        try {
            // ÂÆâÂÖ®ÈáäÊîæstreamËµÑÊ∫ê
            stream?.let { s ->
                try {
                    s.release()
                } catch (e: Exception) {
                    DebugLogger.logWakeWordError(TAG, "ÈáäÊîæOnlineStreamÊó∂Âá∫Èîô", e)
                }
            }
            stream = null
            
            // ÂÆâÂÖ®ÈáäÊîæKeywordSpotterËµÑÊ∫ê
            keywordSpotter?.let { kws ->
                try {
                    kws.release()
                } catch (e: Exception) {
                    DebugLogger.logWakeWordError(TAG, "ÈáäÊîæKeywordSpotterÊó∂Âá∫Èîô", e)
                }
            }
            keywordSpotter = null
            
            // ÂèñÊ∂àÂçèÁ®ã‰ΩúÁî®Âüü
            try {
                scope.cancel()
            } catch (e: Exception) {
                DebugLogger.logWakeWordError(TAG, "ÂèñÊ∂àÂçèÁ®ã‰ΩúÁî®ÂüüÊó∂Âá∫Èîô", e)
            }
            
            _state.value = WakeState.NotLoaded
            DebugLogger.logWakeWord(TAG, "‚úÖ SherpaOnnxWakeDeviceËµÑÊ∫êÈáäÊîæÂÆåÊàê")
        } catch (e: Exception) {
            DebugLogger.logWakeWordError(TAG, "‚ùå ÈîÄÊØÅSherpaOnnxWakeDeviceÂ§±Ë¥•", e)
        }
    }

    override fun isHeyDicio(): Boolean {
        // SherpaOnnx can support multiple keywords. For simplicity, we'll consider it
        // not "Hey Dicio" if it's enabled, as it's a custom KWS.
        return false
    }

    /**
     * Â∞ÜÊ®°ÂûãÊñá‰ª∂‰ªéÂ§ñÈÉ®Â≠òÂÇ®Â§çÂà∂Âà∞ÂÜÖÈÉ®Â≠òÂÇ®
     * ËøôÊòØ‰∏∫‰∫ÜËß£ÂÜ≥ Android 11+ ‰∏ä Native Â∫ìÊó†Ê≥ïËÆøÈóÆ /sdcard/ Ë∑ØÂæÑÁöÑÈóÆÈ¢ò
     */
    private fun copyModelsToInternalStorage(sourcePath: String, destPath: String) {
        val sourceDir = File(sourcePath)
        val destDir = File(destPath)
        
        // ÂàõÂª∫ÁõÆÊ†áÁõÆÂΩï
        if (!destDir.exists()) {
            destDir.mkdirs()
            DebugLogger.logModelManagement(TAG, "üìÅ ÂàõÂª∫ÂÜÖÈÉ®Â≠òÂÇ®ÁõÆÂΩï: $destPath")
        }
        
        val requiredFiles = listOf(
            "encoder-epoch-12-avg-2-chunk-16-left-64.onnx",
            "decoder-epoch-12-avg-2-chunk-16-left-64.onnx",
            "joiner-epoch-12-avg-2-chunk-16-left-64.onnx",
            "keywords.txt",
            "tokens.txt"
        )
        
        requiredFiles.forEach { fileName ->
            val sourceFile = File(sourceDir, fileName)
            val destFile = File(destDir, fileName)
            
            // Âè™ÊúâÂΩìÁõÆÊ†áÊñá‰ª∂‰∏çÂ≠òÂú®ÊàñÂ§ßÂ∞è‰∏çÂêåÊó∂ÊâçÂ§çÂà∂
            if (!destFile.exists() || destFile.length() != sourceFile.length()) {
                try {
                    sourceFile.inputStream().use { input ->
                        destFile.outputStream().use { output ->
                            input.copyTo(output)
                        }
                    }
                    DebugLogger.logModelManagement(TAG, "üìÑ Â§çÂà∂Ê®°ÂûãÊñá‰ª∂: $fileName (${sourceFile.length()} bytes)")
                } catch (e: Exception) {
                    DebugLogger.logWakeWordError(TAG, "‚ùå Â§çÂà∂Êñá‰ª∂ $fileName Â§±Ë¥•: ${e.message}", e)
                    throw IOException("Â§çÂà∂Ê®°ÂûãÊñá‰ª∂Â§±Ë¥•: $fileName", e)
                }
            } else {
                DebugLogger.logModelManagement(TAG, "‚úÖ Ê®°ÂûãÊñá‰ª∂Â∑≤Â≠òÂú®: $fileName")
            }
        }
        
        DebugLogger.logModelManagement(TAG, "üéâ ÊâÄÊúâÊ®°ÂûãÊñá‰ª∂Â∑≤Â§çÂà∂Âà∞ÂÜÖÈÉ®Â≠òÂÇ®")
    }

    /**
     * ÂàõÂª∫‰ΩøÁî®ÊåáÂÆöË∑ØÂæÑÁöÑ KeywordSpotterConfig
     */
    private fun createKwsConfigWithPath(modelBasePath: String): KeywordSpotterConfig {
        return KeywordSpotterConfig(
            featConfig = FeatureConfig(
                sampleRate = 16000,
                featureDim = 80
            ),
            modelConfig = OnlineModelConfig(
                transducer = OnlineTransducerModelConfig(
                    encoder = "$modelBasePath/encoder-epoch-12-avg-2-chunk-16-left-64.onnx",
                    decoder = "$modelBasePath/decoder-epoch-12-avg-2-chunk-16-left-64.onnx",
                    joiner = "$modelBasePath/joiner-epoch-12-avg-2-chunk-16-left-64.onnx"
                ),
                tokens = "$modelBasePath/tokens.txt",
                modelType = "zipformer2",
                numThreads = 1,
                provider = "cpu"
            ),
            maxActivePaths = 4,
            keywordsFile = "$modelBasePath/keywords.txt",
            keywordsScore = 1.5f,
            keywordsThreshold = 0.25f,
            numTrailingBlanks = 2
        )
    }

    companion object {
        val TAG = SherpaOnnxWakeDevice::class.simpleName ?: "SherpaOnnxWakeDevice"
    }
}
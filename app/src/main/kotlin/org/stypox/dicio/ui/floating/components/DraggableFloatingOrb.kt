package org.stypox.dicio.ui.floating.components

import android.content.Context
import android.graphics.PixelFormat
import android.view.Gravity
import android.view.MotionEvent
import android.view.View
import android.view.WindowManager
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.shadow
import androidx.compose.ui.draw.scale
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.graphicsLayer
import androidx.compose.animation.core.*
import androidx.compose.foundation.border
import androidx.compose.ui.platform.ComposeView
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import androidx.lifecycle.ViewModelStoreOwner
import androidx.lifecycle.setViewTreeLifecycleOwner
import androidx.lifecycle.setViewTreeViewModelStoreOwner
import androidx.savedstate.SavedStateRegistryOwner
import androidx.savedstate.setViewTreeSavedStateRegistryOwner
import kotlinx.coroutines.delay
import androidx.compose.material3.MaterialTheme
import org.stypox.dicio.ui.floating.DragTouchHandler
import org.stypox.dicio.ui.floating.FloatingOrbConfig
import org.stypox.dicio.ui.floating.components.FloatingTextDisplay
import org.stypox.dicio.ui.floating.components.FloatingTextStateManager
import org.stypox.dicio.ui.floating.components.LottieAnimationController
import org.stypox.dicio.ui.floating.components.LottieAnimationState
import org.stypox.dicio.ui.floating.components.LottieAnimationStateManager
import org.stypox.dicio.util.DebugLogger

/**
 * ÂèØÊãñÂä®ÁöÑÊÇ¨ÊµÆÁêÉÁªÑ‰ª∂
 * 
 * ÁâπÊÄßÔºö
 * - ‰ΩøÁî®WindowManagerÂàõÂª∫Á≥ªÁªüÁ∫ßÊÇ¨ÊµÆÁ™ó
 * - ÊîØÊåÅÊãñÂä®ÂíåÁÇπÂáª
 * - ÈõÜÊàêLottieÂä®Áîª
 * - FLAG_NOT_FOCUSABLEÈÅøÂÖçÊä¢ÁÑ¶ÁÇπ
 */
class DraggableFloatingOrb(
    private val context: Context,
    private val lifecycleOwner: androidx.lifecycle.LifecycleOwner,
    private val viewModelStoreOwner: ViewModelStoreOwner,
    private val savedStateRegistryOwner: SavedStateRegistryOwner
) {
    private val TAG = "DraggableFloatingOrb"
    
    private val windowManager = context.getSystemService(Context.WINDOW_SERVICE) as WindowManager
    private var floatingView: View? = null
    private var isShowing = false
    
    // Âä®ÁîªÁä∂ÊÄÅÁÆ°ÁêÜÂô®
    private val animationStateManager = LottieAnimationStateManager()
    
    // ÊñáÊú¨ÊòæÁ§∫Áä∂ÊÄÅÁÆ°ÁêÜÂô®
    private val textStateManager = FloatingTextStateManager(context)
    
    // ÊãñÊãΩÂ§ÑÁêÜÂô®
    private var dragTouchHandler: DragTouchHandler? = null
    
    // ËæπÁºòÂê∏ÈôÑÁä∂ÊÄÅ
    private var isAtEdge = false
    
    // ÊãñÊãΩÁä∂ÊÄÅ
    private var isDragging = false
    private var isLongPressing = false
    
    // ÁÇπÂáªÂõûË∞É
    var onOrbClick: (() -> Unit)? = null
    var onOrbLongPress: (() -> Unit)? = null
    
    /**
     * ÊòæÁ§∫ÊÇ¨ÊµÆÁêÉ
     */
    fun show() {
        if (isShowing) return
        
        // ÂàùÂßãÂåñÈÖçÁΩÆ
        FloatingOrbConfig.initialize(context)
        DebugLogger.logUI(TAG, "üéà Showing floating orb")
        DebugLogger.logUI(TAG, FloatingOrbConfig.getDebugInfo())
        
        try {
            val composeView = ComposeView(context)
            
            // ËÆæÁΩÆÈÄèÊòéËÉåÊôØ
            composeView.setBackgroundColor(android.graphics.Color.TRANSPARENT)
            
            // ËÆæÁΩÆÁîüÂëΩÂë®ÊúüÁõ∏ÂÖ≥ÁöÑTreeOwner
            composeView.setViewTreeLifecycleOwner(lifecycleOwner)
            composeView.setViewTreeViewModelStoreOwner(viewModelStoreOwner)
            composeView.setViewTreeSavedStateRegistryOwner(savedStateRegistryOwner)
            
            composeView.setContent {
                // ‰∏ç‰ΩøÁî®AppThemeÔºåÂõ†‰∏∫Service‰∏çÊòØActivity
                // ‰ΩøÁî®ÂÆåÂÖ®ÈÄèÊòéÁöÑËÉåÊôØ
                Box(
                    modifier = Modifier
                        .fillMaxSize()
                        .background(Color.Transparent)
                ) {
                    FloatingOrbContent(
                        animationStateManager = animationStateManager,
                        textStateManager = textStateManager,
                        isAtEdge = isAtEdge,
                        isDragging = isDragging,
                        isLongPressing = isLongPressing,
                        onOrbClick = { handleOrbClick() },
                        onOrbLongPress = { handleOrbLongPress() },
                        onDragStart = { handleDragStart() },
                        onDragEnd = { handleDragEnd() }
                    )
                }
            }
            
            val layoutParams = createWindowLayoutParams()
            windowManager.addView(composeView, layoutParams)
            
            floatingView = composeView
            isShowing = true
            
            // ÂàùÂßãÂåñÊãñÊãΩÂ§ÑÁêÜÂô®
            dragTouchHandler = DragTouchHandler(context, windowManager, composeView).apply {
                onOrbClick = { handleOrbClick() }
                onOrbLongPress = { handleOrbLongPress() }
                onDragStart = { handleDragStart() }
                onDragEnd = { handleDragEnd() }
                onEdgeStateChanged = { atEdge -> setEdgeState(atEdge) }
            }
            
            // Âú®ComposeView‰∏äËÆæÁΩÆËß¶Êë∏ÁõëÂê¨Âô®
            composeView.setOnTouchListener { _, event ->
                dragTouchHandler?.onTouchEvent(event) ?: false
            }
            
            // ÈªòËÆ§ËÆæÁΩÆ‰∏∫ÂæÖÊú∫Áä∂ÊÄÅ
            animationStateManager.setIdle()
            
        } catch (e: Exception) {
            DebugLogger.logUI(TAG, "‚ùå Error showing floating orb: ${e.message}")
        }
    }
    
    /**
     * ÈöêËóèÊÇ¨ÊµÆÁêÉ
     */
    fun hide() {
        if (!isShowing) return
        
        DebugLogger.logUI(TAG, "üéà Hiding floating orb")
        
        try {
            floatingView?.let { view ->
                windowManager.removeView(view)
                floatingView = null
                isShowing = false
            }
        } catch (e: Exception) {
            DebugLogger.logUI(TAG, "‚ùå Error hiding floating orb: ${e.message}")
        }
    }
    
    /**
     * Ëé∑ÂèñÂä®ÁîªÁä∂ÊÄÅÁÆ°ÁêÜÂô®
     */
    fun getAnimationStateManager(): LottieAnimationStateManager = animationStateManager
    
    /**
     * Ëé∑ÂèñÊñáÊú¨Áä∂ÊÄÅÁÆ°ÁêÜÂô®
     */
    fun getTextStateManager(): FloatingTextStateManager = textStateManager
    
    /**
     * ÂàõÂª∫WindowManagerÂ∏ÉÂ±ÄÂèÇÊï∞
     */
    private fun createWindowLayoutParams(): WindowManager.LayoutParams {
        return WindowManager.LayoutParams().apply {
            // Á™óÂè£Á±ªÂûã
            type = WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY
            
            // Á™óÂè£Ê†áÂøó - ÂÖ≥ÈîÆÔºöFLAG_NOT_FOCUSABLEÈÅøÂÖçÊä¢ÁÑ¶ÁÇπ
            flags = WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or
                    WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL or
                    WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH or
                    WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS or
                    WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED
            
            // ÂÉèÁ¥†Ê†ºÂºè - ‰ΩøÁî®RGBA_8888ÊîØÊåÅÂÆåÂÖ®ÈÄèÊòé
            format = PixelFormat.RGBA_8888
            
            // Á™óÂè£Â§ßÂ∞è
            width = WindowManager.LayoutParams.WRAP_CONTENT
            height = WindowManager.LayoutParams.WRAP_CONTENT
            
            // Á™óÂè£‰ΩçÁΩÆ
            gravity = Gravity.TOP or Gravity.START
            x = 100 // ÂàùÂßãX‰ΩçÁΩÆ
            y = 200 // ÂàùÂßãY‰ΩçÁΩÆ
        }
    }
    
    /**
     * Â§ÑÁêÜÊÇ¨ÊµÆÁêÉÁÇπÂáª
     */
    private fun handleOrbClick() {
        DebugLogger.logUI(TAG, "üëÜ Orb clicked")
        onOrbClick?.invoke()
    }
    
    /**
     * Â§ÑÁêÜÊÇ¨ÊµÆÁêÉÈïøÊåâ
     */
    private fun handleOrbLongPress() {
        DebugLogger.logUI(TAG, "üëÜ Orb long pressed - entering drag mode")
        
        // Ê∑ªÂä†ÈúáÂä®ÂèçÈ¶à
        addHapticFeedback()
        
        // Êõ¥Êñ∞Âä®ÁîªÁä∂ÊÄÅÊòæÁ§∫ÈïøÊåâÂèçÈ¶à
        animationStateManager.setActive("ÂèØÊãñÊãΩ")
        
        // Êõ¥Êñ∞UIÁä∂ÊÄÅ
        updateDragState(longPressing = true)
        
        onOrbLongPress?.invoke()
    }
    
    /**
     * Â§ÑÁêÜÊãñÂä®ÂºÄÂßã
     */
    private fun handleDragStart() {
        DebugLogger.logUI(TAG, "ü§è Drag started")
        
        // Êõ¥Êñ∞Âä®ÁîªÁä∂ÊÄÅÊòæÁ§∫ÊãñÊãΩÁä∂ÊÄÅ
        animationStateManager.setActive("ÊãñÊãΩ‰∏≠...")
        
        // Ê∑ªÂä†ÈúáÂä®ÂèçÈ¶à
        addHapticFeedback()
        
        // Êõ¥Êñ∞UIÁä∂ÊÄÅ
        updateDragState(dragging = true, longPressing = true)
    }
    
    /**
     * Â§ÑÁêÜÊãñÂä®ÁªìÊùü
     */
    private fun handleDragEnd() {
        DebugLogger.logUI(TAG, "ü§è Drag ended")
        
        // ÊãñÊãΩÁªìÊùüÂêéÂõûÂà∞ÂæÖÊú∫Áä∂ÊÄÅ
        animationStateManager.setIdle()
        
        // Ê∑ªÂä†ÈúáÂä®ÂèçÈ¶à
        addHapticFeedback()
        
        // Êõ¥Êñ∞UIÁä∂ÊÄÅ
        updateDragState(dragging = false, longPressing = false)
    }
    
    /**
     * Ê∑ªÂä†Ëß¶ËßâÂèçÈ¶à
     */
    private fun addHapticFeedback() {
        try {
            floatingView?.let { view ->
                if (android.os.Build.VERSION.SDK_INT >= android.os.Build.VERSION_CODES.R) {
                    view.performHapticFeedback(android.view.HapticFeedbackConstants.GESTURE_START)
                } else {
                    view.performHapticFeedback(android.view.HapticFeedbackConstants.LONG_PRESS)
                }
            }
        } catch (e: Exception) {
            DebugLogger.logUI(TAG, "‚ùå Haptic feedback failed: ${e.message}")
        }
    }
    
    /**
     * Êõ¥Êñ∞ÊÇ¨ÊµÆÁêÉ‰ΩçÁΩÆ
     */
    fun updatePosition(x: Int, y: Int) {
        floatingView?.let { view ->
            val layoutParams = view.layoutParams as WindowManager.LayoutParams
            layoutParams.x = x
            layoutParams.y = y
            windowManager.updateViewLayout(view, layoutParams)
        }
    }
    
    /**
     * ËÆæÁΩÆËæπÁºòÂê∏ÈôÑÁä∂ÊÄÅ
     */
    fun setEdgeState(atEdge: Boolean) {
        if (isAtEdge != atEdge) {
            isAtEdge = atEdge
            DebugLogger.logUI(TAG, "üß≤ Edge state changed: $atEdge")
            
            // ÈáçÊñ∞ÂàõÂª∫ËßÜÂõæ‰ª•Â∫îÁî®Êñ∞ÁöÑÂ∞∫ÂØ∏
            if (isShowing) {
                val currentView = floatingView
                if (currentView != null) {
                    // ‰øùÂ≠òÂΩìÂâç‰ΩçÁΩÆ
                    val layoutParams = currentView.layoutParams as WindowManager.LayoutParams
                    val currentX = layoutParams.x
                    val currentY = layoutParams.y
                    
                    // ÈöêËóèÂπ∂ÈáçÊñ∞ÊòæÁ§∫
                    hide()
                    show()
                    
                    // ÊÅ¢Â§ç‰ΩçÁΩÆ
                    updatePosition(currentX, currentY)
                }
            }
        }
    }
    
    /**
     * Ëé∑ÂèñÂΩìÂâçÊòØÂê¶Âú®ËæπÁºò
     */
    fun isAtEdge(): Boolean = isAtEdge
    
    /**
     * Êõ¥Êñ∞ÊãñÊãΩÁä∂ÊÄÅ
     */
    private fun updateDragState(dragging: Boolean = isDragging, longPressing: Boolean = isLongPressing) {
        if (isDragging != dragging || isLongPressing != longPressing) {
            isDragging = dragging
            isLongPressing = longPressing
            
            // Ëß¶ÂèëÈáçÊñ∞ÁªÑÂêà
            if (isShowing) {
                val currentView = floatingView
                if (currentView != null) {
                    // ‰øùÂ≠òÂΩìÂâç‰ΩçÁΩÆ
                    val layoutParams = currentView.layoutParams as WindowManager.LayoutParams
                    val currentX = layoutParams.x
                    val currentY = layoutParams.y
                    
                    // ÈöêËóèÂπ∂ÈáçÊñ∞ÊòæÁ§∫
                    hide()
                    show()
                    
                    // ÊÅ¢Â§ç‰ΩçÁΩÆ
                    updatePosition(currentX, currentY)
                }
            }
        }
    }
}

/**
 * ÊÇ¨ÊµÆÁêÉÂÜÖÂÆπÁªÑ‰ª∂ (ÂåÖÂê´ÊñáÊú¨ÊòæÁ§∫)
 */
@Composable
private fun FloatingOrbContent(
    animationStateManager: LottieAnimationStateManager,
    textStateManager: FloatingTextStateManager,
    isAtEdge: Boolean = false,
    isDragging: Boolean = false,
    isLongPressing: Boolean = false,
    onOrbClick: () -> Unit,
    onOrbLongPress: () -> Unit,
    onDragStart: () -> Unit,
    onDragEnd: () -> Unit
) {
    val animationState by animationStateManager.currentState
    val displayText by animationStateManager.displayText
    
    // ÊñáÊú¨Áä∂ÊÄÅ
    val userText by textStateManager.userText
    val aiText by textStateManager.aiText
    val isTextVisible by textStateManager.isVisible
    
    // Âä®ÁîªÊïàÊûú
    val scale by animateFloatAsState(
        targetValue = when {
            isDragging -> 1.1f
            isLongPressing -> 1.05f
            else -> 1.0f
        },
        animationSpec = spring(
            dampingRatio = Spring.DampingRatioMediumBouncy,
            stiffness = Spring.StiffnessLow
        ),
        label = "scale"
    )
    
    val alpha by animateFloatAsState(
        targetValue = when {
            isDragging -> 0.9f
            isLongPressing -> 0.95f
            else -> 1.0f
        },
        animationSpec = tween(200),
        label = "alpha"
    )
    
    val shadowElevation by animateDpAsState(
        targetValue = when {
            isDragging -> 12.dp
            isLongPressing -> 8.dp
            else -> 4.dp
        },
        animationSpec = tween(200),
        label = "shadow"
    )

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        // ÊÇ¨ÊµÆÁêÉ
        Box(
            modifier = Modifier
                .size(if (isAtEdge) FloatingOrbConfig.edgeOrbSizeDp else FloatingOrbConfig.orbSizeDp) // Ê†πÊçÆËæπÁºòÁä∂ÊÄÅ‰ΩøÁî®‰∏çÂêåÂ∞∫ÂØ∏
                .scale(scale) // Âä®ÁîªÁº©Êîæ
                .graphicsLayer(alpha = alpha) // ÈÄèÊòéÂ∫¶Âä®Áîª
                .shadow(
                    elevation = shadowElevation,
                    shape = CircleShape
                ) // Èò¥ÂΩ±Âä®Áîª
                .let { modifier ->
                    // ÊãñÊãΩÁä∂ÊÄÅÊó∂Ê∑ªÂä†ËæπÊ°Ü
                    if (isDragging || isLongPressing) {
                        modifier.border(
                            width = 2.dp,
                            color = if (isDragging) Color(0xFF4CAF50) else Color(0xFF2196F3),
                            shape = CircleShape
                        )
                    } else {
                        modifier
                    }
                },
            contentAlignment = Alignment.Center
        ) {
            // LottieÂä®Áîª
            LottieAnimationController(
                animationState = animationState,
                displayText = displayText,
                size = if (isAtEdge) FloatingOrbConfig.edgeAnimationSizeInt else FloatingOrbConfig.animationSizeInt // Ê†πÊçÆËæπÁºòÁä∂ÊÄÅ‰ΩøÁî®‰∏çÂêåÂ∞∫ÂØ∏
            )
        }
        
        // ÊñáÊú¨ÊòæÁ§∫Âå∫Âüü (ËæπÁºòÁä∂ÊÄÅÊó∂ÈöêËóè)
        if (!isAtEdge) {
            FloatingTextDisplay(
                userText = userText,
                aiText = aiText,
                isVisible = isTextVisible,
                modifier = Modifier.wrapContentHeight()
            )
        }
    }
}

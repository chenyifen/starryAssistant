# Dicio-Android æ¶æ„ä¼˜åŒ–è®¾è®¡ - æœåŠ¡åŒ–ä¸æ··åˆæ¨¡å¼

**æ–‡æ¡£ç¼–å·**: 30  
**åˆ›å»ºæ—¥æœŸ**: 2025-01-XX  
**ç‰ˆæœ¬**: v1.0  
**ç›®æ ‡**: å°†dicio-androidé‡æ„ä¸ºæœåŠ¡åŒ–æ¶æ„ï¼Œæ”¯æŒç¦»çº¿+åœ¨çº¿æ··åˆæ¨¡å¼

---

## ä¸€ã€ç°æœ‰æ¶æ„åˆ†æ

### 1.1 æ ¸å¿ƒç»„ä»¶åŠèŒè´£

```
EnhancedFloatingWindowService (å…¥å£æœåŠ¡)
â”œâ”€â”€ WakeDeviceWrapper (å”¤é†’è¯æ£€æµ‹)
â”œâ”€â”€ SttInputDeviceWrapper (STTè¾“å…¥è®¾å¤‡ç®¡ç†)
â”‚   â”œâ”€â”€ VoskInputDevice (ç¦»çº¿STT - Vosk)
â”‚   â”œâ”€â”€ SenseVoiceInputDevice (ç¦»çº¿STT - SenseVoice)
â”‚   â””â”€â”€ TwoPassInputDevice (åŒè¯†åˆ«æ¨¡å¼)
â”œâ”€â”€ SkillEvaluator (æŠ€èƒ½è¯„ä¼°å™¨)
â”‚   â”œâ”€â”€ SkillHandler (æŠ€èƒ½å¤„ç†å™¨)
â”‚   â””â”€â”€ SkillRanker (æŠ€èƒ½æ’åºå™¨)
â”œâ”€â”€ VoiceAssistantStateProvider (çŠ¶æ€æä¾›è€…)
â”‚   â””â”€â”€ VoiceAssistantStateCoordinator (çŠ¶æ€åè°ƒå™¨)
â””â”€â”€ DraggableFloatingOrb (æ‚¬æµ®çƒUI)
```

### 1.2 å½“å‰æ•°æ®æµ

```
ç”¨æˆ·å”¤é†’/ç‚¹å‡» 
  â†’ WakeService/FloatingOrb 
  â†’ SttInputDeviceWrapper.tryLoad()
  â†’ SttInputDevice.onClick()
  â†’ éŸ³é¢‘é‡‡é›†ï¼ˆåœ¨InputDeviceå†…éƒ¨ï¼‰
  â†’ VADæ£€æµ‹ï¼ˆåœ¨SenseVoiceInputDeviceå†…éƒ¨ï¼‰
  â†’ è¯­éŸ³è¯†åˆ«ï¼ˆVosk/SenseVoiceï¼‰
  â†’ InputEvent (Partial/Final)
  â†’ SkillEvaluator.processInputEvent()
  â†’ SkillRanker.getBest()
  â†’ Skill.generateOutput()
  â†’ SpeechOutputDevice.speak()
  â†’ çŠ¶æ€æ›´æ–° â†’ VoiceAssistantStateProvider
```

### 1.3 å­˜åœ¨çš„é—®é¢˜

| é—®é¢˜ | å½±å“ | ä¼˜å…ˆçº§ |
|-----|-----|--------|
| **éŸ³é¢‘å¤„ç†åˆ†æ•£** | éŸ³é¢‘é‡‡é›†ã€VADã€ç¼–è§£ç é€»è¾‘åˆ†æ•£åœ¨å„InputDeviceä¸­ï¼Œéš¾ä»¥å¤ç”¨ | é«˜ |
| **ç¼ºå°‘æœåŠ¡åŒ–å±‚** | æ— æ³•è¢«å…¶ä»–åº”ç”¨è°ƒç”¨ï¼Œä¸å¤Ÿçµæ´» | é«˜ |
| **ä»…æ”¯æŒç¦»çº¿æ¨¡å¼** | æ— æ³•ä½¿ç”¨åœ¨çº¿ASR/TTSï¼Œå‡†ç¡®åº¦å’ŒåŠŸèƒ½å—é™ | é«˜ |
| **æ— è¿æ¥ç®¡ç†** | ç¼ºå°‘WebSocketè¿æ¥æœåŠ¡ï¼Œæ— æ³•å®ç°æµå¼é€šä¿¡ | é«˜ |
| **çŠ¶æ€ç®¡ç†å¤æ‚** | å¤šä¸ªçŠ¶æ€åè°ƒå™¨ï¼ŒçŠ¶æ€æµè½¬ä¸å¤Ÿæ¸…æ™° | ä¸­ |
| **ç¼ºå°‘Function Calling** | æ— æ³•è°ƒç”¨è¿œç¨‹æœåŠ¡æˆ–æœ¬åœ°å‡½æ•° | ä¸­ |

---

## äºŒã€xiaozhi-esp32æ¶æ„æ·±åº¦åˆ†æ

### 2.1 æ ¸å¿ƒè®¾è®¡æ¨¡å¼

#### 2.1.1 ç‹¬ç«‹çš„AudioServiceå±‚

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- å®Œå…¨ç‹¬ç«‹çš„éŸ³é¢‘å¤„ç†æœåŠ¡
- ä½¿ç”¨3ä¸ªç‹¬ç«‹ä»»åŠ¡ï¼ˆFreeRTOS Taskï¼‰ï¼š
  - `AudioInputTask` - éŸ³é¢‘é‡‡é›†
  - `AudioOutputTask` - éŸ³é¢‘æ’­æ”¾
  - `OpusCodecTask` - ç¼–è§£ç 
- ä½¿ç”¨é˜Ÿåˆ—è§£è€¦æ•°æ®æµï¼š
  - `audio_encode_queue_` - å¾…ç¼–ç é˜Ÿåˆ—
  - `audio_send_queue_` - å¾…å‘é€é˜Ÿåˆ—
  - `audio_decode_queue_` - å¾…è§£ç é˜Ÿåˆ—
  - `audio_playback_queue_` - å¾…æ’­æ”¾é˜Ÿåˆ—
- ä½¿ç”¨å›è°ƒæœºåˆ¶é€šçŸ¥çŠ¶æ€å˜åŒ–

**å…³é”®ä»£ç æ¨¡å¼**ï¼š
```cpp
// AudioServiceåˆå§‹åŒ–
void AudioService::Initialize(AudioCodec* codec) {
    // åˆ›å»ºOpusç¼–è§£ç å™¨
    opus_decoder_ = std::make_unique<OpusDecoderWrapper>(...);
    opus_encoder_ = std::make_unique<OpusEncoderWrapper>(...);
    
    // è®¾ç½®éŸ³é¢‘å¤„ç†å™¨å›è°ƒ
    audio_processor_->OnOutput([this](std::vector<int16_t>&& data) {
        PushTaskToEncodeQueue(kAudioTaskTypeEncodeToSendQueue, std::move(data));
    });
    
    // è®¾ç½®VADå›è°ƒ
    audio_processor_->OnVadStateChange([this](bool speaking) {
        voice_detected_ = speaking;
        if (callbacks_.on_vad_change) {
            callbacks_.on_vad_change(speaking);
        }
    });
}
```

**Androidå¯¹åº”è®¾è®¡**ï¼š
```kotlin
class AudioService(private val context: Context) {
    // ä½¿ç”¨Kotlin Coroutinesæ›¿ä»£FreeRTOS Task
    private val captureScope = CoroutineScope(Dispatchers.IO)
    private val processScope = CoroutineScope(Dispatchers.Default)
    
    // ä½¿ç”¨Channelæ›¿ä»£C++é˜Ÿåˆ—
    private val audioEncodeChannel = Channel<AudioBuffer>(capacity = 10)
    private val audioPlaybackChannel = Channel<AudioBuffer>(capacity = 10)
    
    // å›è°ƒæœºåˆ¶
    var onVadStateChange: ((Boolean) -> Unit)? = null
    var onAudioData: ((FloatArray) -> Unit)? = null
}
```

#### 2.1.2 EventGroupäº‹ä»¶é©±åŠ¨

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- ä½¿ç”¨FreeRTOS EventGroupè¿›è¡Œä»»åŠ¡åŒæ­¥
- æ¯ä¸ªäº‹ä»¶å¯¹åº”ä¸€ä¸ªbitä½
- ä»»åŠ¡é€šè¿‡`xEventGroupWaitBits`ç­‰å¾…ç‰¹å®šäº‹ä»¶
- ä½¿ç”¨`xEventGroupSetBits`è§¦å‘äº‹ä»¶

**å…³é”®ä»£ç æ¨¡å¼**ï¼š
```cpp
// å®šä¹‰äº‹ä»¶ä½
#define MAIN_EVENT_SCHEDULE (1 << 0)
#define MAIN_EVENT_SEND_AUDIO (1 << 1)
#define MAIN_EVENT_WAKE_WORD_DETECTED (1 << 2)

// ä¸»äº‹ä»¶å¾ªç¯
void Application::MainEventLoop() {
    while (true) {
        EventBits_t bits = xEventGroupWaitBits(event_group_, 
            MAIN_EVENT_SCHEDULE | MAIN_EVENT_SEND_AUDIO | ...,
            pdTRUE, pdFALSE, pdMS_TO_TICKS(100));
        
        if (bits & MAIN_EVENT_WAKE_WORD_DETECTED) {
            OnWakeWordDetected();
        }
        if (bits & MAIN_EVENT_SEND_AUDIO) {
            // å‘é€éŸ³é¢‘æ•°æ®
        }
    }
}
```

**Androidå¯¹åº”è®¾è®¡**ï¼š
```kotlin
// ä½¿ç”¨Kotlin Flow + SharedFlow
class EventDispatcher {
    private val _events = MutableSharedFlow<AppEvent>()
    val events: SharedFlow<AppEvent> = _events.asSharedFlow()
    
    suspend fun dispatch(event: AppEvent) {
        _events.emit(event)
    }
}

// äº‹ä»¶ç›‘å¬
scope.launch {
    eventDispatcher.events.collect { event ->
        when (event) {
            is AppEvent.WakeWordDetected -> handleWakeWord()
            is AppEvent.AudioDataReady -> handleAudioData()
        }
    }
}
```

#### 2.1.3 ç²¾ç¡®çš„çŠ¶æ€æœº

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- æ˜ç¡®çš„çŠ¶æ€æšä¸¾`DeviceState`
- çŠ¶æ€è½¬æ¢é€šè¿‡`SetDeviceState()`
- çŠ¶æ€å˜åŒ–ä¼šè§¦å‘å›è°ƒ`DeviceStateEventManager`
- æ¯ä¸ªçŠ¶æ€æœ‰æ˜ç¡®çš„è¿›å…¥/é€€å‡ºé€»è¾‘

**å…³é”®ä»£ç æ¨¡å¼**ï¼š
```cpp
enum DeviceState {
    kDeviceStateIdle,
    kDeviceStateListening,
    kDeviceStateSpeaking,
    // ...
};

void Application::SetDeviceState(DeviceState state) {
    auto previous_state = device_state_;
    device_state_ = state;
    
    // è§¦å‘çŠ¶æ€å˜åŒ–äº‹ä»¶
    DeviceStateEventManager::GetInstance()
        .PostStateChangeEvent(previous_state, state);
}
```

#### 2.1.4 Protocolå›è°ƒæœºåˆ¶

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- Protocolå±‚ä½¿ç”¨å›è°ƒå‡½æ•°å¤„ç†å„ç§äº‹ä»¶
- æ”¯æŒå¤šç§æ¶ˆæ¯ç±»å‹ï¼ˆJSONã€Audioã€MCPï¼‰
- ç»Ÿä¸€çš„æ¶ˆæ¯æ ¼å¼å’Œåºåˆ—åŒ–

**å…³é”®ä»£ç æ¨¡å¼**ï¼š
```cpp
class Protocol {
public:
    void OnIncomingJson(std::function<void(const cJSON*)> callback);
    void OnIncomingAudio(std::function<void(std::unique_ptr<AudioStreamPacket>)> callback);
    void OnAudioChannelOpened(std::function<void()> callback);
    
    virtual bool SendAudio(std::unique_ptr<AudioStreamPacket> packet) = 0;
    virtual void SendWakeWordDetected(const std::string& wake_word);
};
```

#### 2.1.5 Scheduleä»»åŠ¡è°ƒåº¦

**è®¾è®¡ç‰¹ç‚¹**ï¼š
- ä½¿ç”¨é˜Ÿåˆ—ä¿å­˜å¾…æ‰§è¡Œçš„ä»»åŠ¡
- ä¸»äº‹ä»¶å¾ªç¯å®šæœŸå¤„ç†ä»»åŠ¡é˜Ÿåˆ—
- çº¿ç¨‹å®‰å…¨çš„ä»»åŠ¡æ·»åŠ 

**å…³é”®ä»£ç æ¨¡å¼**ï¼š
```cpp
void Application::Schedule(std::function<void()> callback) {
    std::lock_guard<std::mutex> lock(mutex_);
    main_tasks_.push_back(callback);
    xEventGroupSetBits(event_group_, MAIN_EVENT_SCHEDULE);
}

// åœ¨äº‹ä»¶å¾ªç¯ä¸­æ‰§è¡Œ
if (bits & MAIN_EVENT_SCHEDULE) {
    std::function<void()> task;
    {
        std::lock_guard<std::mutex> lock(mutex_);
        if (!main_tasks_.empty()) {
            task = std::move(main_tasks_.front());
            main_tasks_.pop_front();
        }
    }
    if (task) {
        task();
    }
}
```

### 2.2 æ¶æ„ä¼˜åŒ–ç›®æ ‡

åŸºäºxiaozhi-esp32çš„è®¾è®¡æ¨¡å¼ï¼Œå®šä¹‰dicio-androidçš„ä¼˜åŒ–ç›®æ ‡ï¼š

| ä¼˜åŒ–ç‚¹ | xiaozhi-esp32å®ç° | dicio-androidå®ç° | ä¼˜å…ˆçº§ |
|--------|------------------|-------------------|--------|
| **ç‹¬ç«‹éŸ³é¢‘æœåŠ¡** | AudioService + 3ä¸ªTask | AudioService + Coroutines | é«˜ |
| **äº‹ä»¶é©±åŠ¨æ¶æ„** | EventGroup + bits | Flow + SharedFlow | é«˜ |
| **ç²¾ç¡®çŠ¶æ€æœº** | DeviceStateæšä¸¾ | AssistantStateæšä¸¾ | é«˜ |
| **é˜Ÿåˆ—ç®¡ç†** | deque + mutex | Channel | é«˜ |
| **åè®®å±‚** | Protocolå›è°ƒ | ConnectionService | é«˜ |
| **VADæ£€æµ‹** | é›†æˆåœ¨AudioService | åŒæ ·é›†æˆåœ¨AudioService | ä¸­ |
| **Opusç¼–è§£ç ** | OpusEncoder/Decoder | ä½¿ç”¨ç°æœ‰åº“ | ä¸­ |
| **ä»»åŠ¡è°ƒåº¦** | Schedule()é˜Ÿåˆ— | Coroutine + Flow | ä¸­ |

### 2.3 å…³é”®å€Ÿé‰´ç‚¹

1. âœ… **æœåŠ¡ç‹¬ç«‹æ€§** - AudioServiceå®Œå…¨ç‹¬ç«‹ï¼Œä¸ä¾èµ–UI
2. âœ… **é˜Ÿåˆ—è§£è€¦** - ä½¿ç”¨å¤šä¸ªé˜Ÿåˆ—è§£è€¦éŸ³é¢‘å¤„ç†æµæ°´çº¿
3. âœ… **å›è°ƒæœºåˆ¶** - é€šè¿‡å›è°ƒè€Œéè½®è¯¢è·å–çŠ¶æ€å˜åŒ–
4. âœ… **çŠ¶æ€è½¬æ¢éªŒè¯** - æ˜ç¡®å“ªäº›çŠ¶æ€è½¬æ¢æ˜¯åˆæ³•çš„
5. âœ… **è¾¹æ”¶è¾¹å¤„ç†** - éŸ³é¢‘é‡‡é›†å’Œå¤„ç†åŒæ—¶è¿›è¡Œ
6. âœ… **ä¸­æ–­æ”¯æŒ** - AbortSpeakingå¯éšæ—¶ä¸­æ–­TTS

---

## ä¸‰ã€æ¶æ„ä¼˜åŒ–è®¾è®¡

### 3.1 æ–°å¢æœåŠ¡å±‚æ¶æ„

```
EnhancedFloatingWindowService (å…¥å£æœåŠ¡ - ä¿æŒ)
â”œâ”€â”€ AudioService (ğŸ†• éŸ³é¢‘æœåŠ¡å±‚)
â”‚   â”œâ”€â”€ AudioCapture (éŸ³é¢‘é‡‡é›†)
â”‚   â”œâ”€â”€ AudioProcessor (VAD/AECå¤„ç†)
â”‚   â”œâ”€â”€ AudioCodec (Opusç¼–è§£ç )
â”‚   â””â”€â”€ AudioBufferManager (ç¼“å†²ç®¡ç†)
â”‚
â”œâ”€â”€ RecognitionService (ğŸ†• è¯†åˆ«æœåŠ¡å±‚)
â”‚   â”œâ”€â”€ OfflineRecognizer (ç¦»çº¿è¯†åˆ«å™¨)
â”‚   â”‚   â”œâ”€â”€ VoskRecognizer
â”‚   â”‚   â””â”€â”€ SenseVoiceRecognizer
â”‚   â”œâ”€â”€ OnlineRecognizer (åœ¨çº¿è¯†åˆ«å™¨)
â”‚   â”‚   â””â”€â”€ StreamingASR (WebSocketæµå¼ASR)
â”‚   â””â”€â”€ HybridRecognizer (æ··åˆè¯†åˆ«å™¨)
â”‚       â””â”€â”€ æ™ºèƒ½åˆ‡æ¢é€»è¾‘
â”‚
â”œâ”€â”€ SynthesisService (ğŸ†• åˆæˆæœåŠ¡å±‚)
â”‚   â”œâ”€â”€ OfflineTTS (SherpaOnnxTTS)
â”‚   â””â”€â”€ OnlineTTS (WebSocketæµå¼TTS)
â”‚
â”œâ”€â”€ ConnectionService (ğŸ†• è¿æ¥æœåŠ¡å±‚)
â”‚   â”œâ”€â”€ WebSocketClient (WebSocketå®¢æˆ·ç«¯)
â”‚   â”œâ”€â”€ ProtocolHandler (åè®®å¤„ç†å™¨)
â”‚   â””â”€â”€ ReconnectionManager (é‡è¿ç®¡ç†)
â”‚
â”œâ”€â”€ StateManager (ğŸ”„ çŠ¶æ€ç®¡ç†å™¨ - é‡æ„)
â”‚   â”œâ”€â”€ AssistantState (çŠ¶æ€æšä¸¾)
â”‚   â”œâ”€â”€ StateTransition (çŠ¶æ€è½¬æ¢è§„åˆ™)
â”‚   â””â”€â”€ EventDispatcher (äº‹ä»¶åˆ†å‘å™¨)
â”‚
â””â”€â”€ ç°æœ‰ç»„ä»¶ (ä¿æŒ/é‡æ„)
    â”œâ”€â”€ WakeDeviceWrapper (ä¿æŒ)
    â”œâ”€â”€ SkillEvaluator (ä¿æŒ)
    â””â”€â”€ DraggableFloatingOrb (ä¿æŒ)
```

### 3.2 å…³é”®ç±»è®¾è®¡

#### 3.2.1 AudioService (æ–°å¢)

```kotlin
/**
 * ç‹¬ç«‹çš„éŸ³é¢‘æœåŠ¡
 * èŒè´£ï¼šéŸ³é¢‘é‡‡é›†ã€å¤„ç†ã€ç¼–è§£ç 
 */
class AudioService(
    private val context: Context
) {
    // éŸ³é¢‘é‡‡é›†
    private val audioCapture: AudioCapture
    
    // VADæ£€æµ‹å™¨
    private val vadDetector: VADDetector
    
    // éŸ³é¢‘ç¼–è§£ç 
    private val audioCodec: AudioCodec
    
    // éŸ³é¢‘ç¼“å†²é˜Ÿåˆ—
    private val audioBufferChannel: Channel<AudioBuffer>
    
    // çŠ¶æ€å›è°ƒ
    var onVadStateChange: ((Boolean) -> Unit)? = null
    var onAudioData: ((FloatArray) -> Unit)? = null
    
    /**
     * å¼€å§‹å½•éŸ³
     */
    suspend fun startCapture()
    
    /**
     * åœæ­¢å½•éŸ³
     */
    fun stopCapture()
    
    /**
     * æ’­æ”¾éŸ³é¢‘
     */
    suspend fun playAudio(audioData: ByteArray)
    
    /**
     * ç¼–ç ä¸ºOpus
     */
    fun encodeToOpus(pcmData: FloatArray): ByteArray
    
    /**
     * ä»Opusè§£ç 
     */
    fun decodeFromOpus(opusData: ByteArray): FloatArray
}
```

#### 3.2.2 ConnectionService (æ–°å¢)

```kotlin
/**
 * WebSocketè¿æ¥æœåŠ¡
 * èŒè´£ï¼šç®¡ç†ä¸æœåŠ¡å™¨çš„WebSocketè¿æ¥
 */
class ConnectionService(
    private val serverUrl: String
) {
    private var webSocket: WebSocket? = null
    
    // è¿æ¥çŠ¶æ€
    val connectionState: StateFlow<ConnectionState>
    
    // æ¶ˆæ¯æµ
    val messageFlow: SharedFlow<ServerMessage>
    
    /**
     * è¿æ¥æœåŠ¡å™¨
     */
    suspend fun connect()
    
    /**
     * æ–­å¼€è¿æ¥
     */
    fun disconnect()
    
    /**
     * å‘é€éŸ³é¢‘æ•°æ®
     */
    suspend fun sendAudio(audioData: ByteArray)
    
    /**
     * å‘é€JSONæ¶ˆæ¯
     */
    suspend fun sendJson(json: String)
    
    /**
     * æ¥æ”¶æµå¼ASRç»“æœ
     */
    fun observeAsrResults(): Flow<AsrResult>
    
    /**
     * æ¥æ”¶æµå¼TTSéŸ³é¢‘
     */
    fun observeTtsAudio(): Flow<ByteArray>
}
```

#### 3.2.3 HybridRecognizer (æ–°å¢)

```kotlin
/**
 * æ··åˆè¯†åˆ«å™¨
 * èŒè´£ï¼šæ™ºèƒ½åˆ‡æ¢ç¦»çº¿/åœ¨çº¿è¯†åˆ«
 */
class HybridRecognizer(
    private val offlineRecognizer: OfflineRecognizer,
    private val onlineRecognizer: OnlineRecognizer,
    private val connectionService: ConnectionService
) : Recognizer {
    
    // è¯†åˆ«æ¨¡å¼
    enum class Mode {
        OFFLINE_ONLY,    // ä»…ç¦»çº¿
        ONLINE_ONLY,     // ä»…åœ¨çº¿
        HYBRID_OFFLINE_FIRST,  // ç¦»çº¿ä¼˜å…ˆ
        HYBRID_PARALLEL   // å¹¶è¡Œè¯†åˆ«
    }
    
    private var currentMode = Mode.HYBRID_OFFLINE_FIRST
    
    /**
     * å¼€å§‹è¯†åˆ«
     */
    override suspend fun recognize(audioData: FloatArray): RecognitionResult {
        return when (currentMode) {
            Mode.OFFLINE_ONLY -> offlineRecognizer.recognize(audioData)
            Mode.ONLINE_ONLY -> onlineRecognizer.recognize(audioData)
            Mode.HYBRID_OFFLINE_FIRST -> recognizeHybridOfflineFirst(audioData)
            Mode.HYBRID_PARALLEL -> recognizeParallel(audioData)
        }
    }
    
    /**
     * ç¦»çº¿ä¼˜å…ˆæ··åˆæ¨¡å¼
     * - å…ˆå¯åŠ¨ç¦»çº¿è¯†åˆ«ï¼ˆå¿«é€Ÿå“åº”ï¼‰
     * - åŒæ—¶å¯åŠ¨åœ¨çº¿è¯†åˆ«ï¼ˆæ›´å‡†ç¡®ï¼‰
     * - è¿”å›ç¦»çº¿ç»“æœï¼Œåå°ç”¨åœ¨çº¿ç»“æœä¿®æ­£
     */
    private suspend fun recognizeHybridOfflineFirst(audioData: FloatArray): RecognitionResult
}
```

#### 3.2.4 StateManager (é‡æ„)

```kotlin
/**
 * ç»Ÿä¸€çš„çŠ¶æ€ç®¡ç†å™¨
 * èŒè´£ï¼šç®¡ç†åŠ©æ‰‹çš„æ‰€æœ‰çŠ¶æ€è½¬æ¢
 */
class StateManager {
    
    /**
     * åŠ©æ‰‹çŠ¶æ€æšä¸¾ (å‚è€ƒxiaozhi DeviceState)
     */
    enum class AssistantState {
        UNKNOWN,        // æœªçŸ¥çŠ¶æ€
        IDLE,           // ç©ºé—²ï¼Œç­‰å¾…å”¤é†’
        LISTENING,      // æ­£åœ¨ç›‘å¬
        RECOGNIZING,    // æ­£åœ¨è¯†åˆ«
        THINKING,       // æ­£åœ¨æ€è€ƒï¼ˆæŠ€èƒ½å¤„ç†ï¼‰
        SPEAKING,       // æ­£åœ¨è¯´è¯
        ERROR           // é”™è¯¯çŠ¶æ€
    }
    
    // å½“å‰çŠ¶æ€
    private val _currentState = MutableStateFlow(AssistantState.UNKNOWN)
    val currentState: StateFlow<AssistantState> = _currentState.asStateFlow()
    
    // çŠ¶æ€å†å²
    private val stateHistory = mutableListOf<StateTransition>()
    
    /**
     * è½¬æ¢åˆ°æ–°çŠ¶æ€
     */
    fun transitionTo(newState: AssistantState, reason: String = "") {
        val oldState = _currentState.value
        
        // éªŒè¯çŠ¶æ€è½¬æ¢æ˜¯å¦åˆæ³•
        if (!isValidTransition(oldState, newState)) {
            Log.w(TAG, "Invalid state transition: $oldState -> $newState")
            return
        }
        
        // è®°å½•çŠ¶æ€è½¬æ¢
        val transition = StateTransition(
            from = oldState,
            to = newState,
            reason = reason,
            timestamp = System.currentTimeMillis()
        )
        stateHistory.add(transition)
        
        // æ›´æ–°çŠ¶æ€
        _currentState.value = newState
        
        // è§¦å‘çŠ¶æ€å˜åŒ–äº‹ä»¶
        onStateChanged(oldState, newState)
    }
    
    /**
     * éªŒè¯çŠ¶æ€è½¬æ¢æ˜¯å¦åˆæ³•
     */
    private fun isValidTransition(from: AssistantState, to: AssistantState): Boolean
    
    /**
     * å¼ºåˆ¶é‡ç½®åˆ°IDLEçŠ¶æ€
     */
    fun resetToIdle()
    
    /**
     * ä¸­æ–­å½“å‰æ“ä½œ
     */
    fun interrupt(reason: String)
}
```

---

## å››ã€æ”¹åŠ¨æ¸…å•

### 4.1 æ–°å¢ç±»/æ¥å£

| ç±»å | åŒ…è·¯å¾„ | è¯´æ˜ |
|-----|--------|-----|
| `AudioService` | `org.stypox.dicio.audio` | éŸ³é¢‘æœåŠ¡æ ¸å¿ƒç±» |
| `AudioCapture` | `org.stypox.dicio.audio.capture` | éŸ³é¢‘é‡‡é›† |
| `AudioProcessor` | `org.stypox.dicio.audio.processor` | éŸ³é¢‘å¤„ç†(VAD/AEC) |
| `AudioCodec` | `org.stypox.dicio.audio.codec` | éŸ³é¢‘ç¼–è§£ç  |
| `ConnectionService` | `org.stypox.dicio.connection` | WebSocketè¿æ¥æœåŠ¡ |
| `WebSocketClient` | `org.stypox.dicio.connection.ws` | WebSocketå®¢æˆ·ç«¯ |
| `ProtocolHandler` | `org.stypox.dicio.connection.protocol` | åè®®å¤„ç†å™¨ |
| `RecognitionService` | `org.stypox.dicio.recognition` | è¯†åˆ«æœåŠ¡ |
| `HybridRecognizer` | `org.stypox.dicio.recognition.hybrid` | æ··åˆè¯†åˆ«å™¨ |
| `OnlineRecognizer` | `org.stypox.dicio.recognition.online` | åœ¨çº¿è¯†åˆ«å™¨ |
| `StateManager` | `org.stypox.dicio.state` | çŠ¶æ€ç®¡ç†å™¨ |

### 4.2 é‡æ„ç°æœ‰ç±»

| ç±»å | é‡æ„å†…å®¹ | åŸå›  |
|-----|---------|-----|
| `SttInputDeviceWrapper` | ç®€åŒ–èŒè´£ï¼Œå§”æ‰˜AudioServiceå¤„ç†éŸ³é¢‘ | èŒè´£è¿‡é‡ |
| `SenseVoiceInputDevice` | æå–éŸ³é¢‘å¤„ç†åˆ°AudioService | é€»è¾‘åˆ†æ•£ |
| `VoiceAssistantStateProvider` | ç®€åŒ–ï¼Œä½¿ç”¨æ–°çš„StateManager | çŠ¶æ€ç®¡ç†å¤æ‚ |
| `VoiceAssistantStateCoordinator` | æ•´åˆåˆ°StateManager | èŒè´£é‡å  |

### 4.3 ä¿æŒä¸å˜

| ç±»å | è¯´æ˜ |
|-----|-----|
| `EnhancedFloatingWindowService` | å…¥å£æœåŠ¡ï¼Œä¿æŒä½œä¸ºæ€»å…¥å£ |
| `WakeDeviceWrapper` | å”¤é†’è¯æ£€æµ‹ï¼Œä¿æŒä¸å˜ |
| `SkillEvaluator` | æŠ€èƒ½è¯„ä¼°å™¨ï¼Œä¿æŒä¸å˜ |
| `SkillHandler`/`SkillRanker` | æŠ€èƒ½å¤„ç†ï¼Œä¿æŒä¸å˜ |
| `DraggableFloatingOrb` | æ‚¬æµ®çƒUIï¼Œä¿æŒä¸å˜ |

---

## äº”ã€å®æ–½è®¡åˆ’

### é˜¶æ®µ1ï¼šåŸºç¡€æœåŠ¡å±‚ (1-2å‘¨)

- [ ] **Task 1.1**: åˆ›å»ºAudioServiceåŸºç¡€æ¡†æ¶
  - åˆ›å»º`AudioService.kt`
  - å®ç°`AudioCapture`éŸ³é¢‘é‡‡é›†
  - å®ç°åŸºæœ¬çš„éŸ³é¢‘ç¼“å†²ç®¡ç†

- [ ] **Task 1.2**: å®ç°VADæ£€æµ‹
  - æå–ç°æœ‰VADé€»è¾‘åˆ°`AudioProcessor`
  - é›†æˆåˆ°AudioService

- [ ] **Task 1.3**: åˆ›å»ºStateManager
  - å®šä¹‰`AssistantState`æšä¸¾
  - å®ç°çŠ¶æ€è½¬æ¢é€»è¾‘
  - å®ç°çŠ¶æ€éªŒè¯

### é˜¶æ®µ2ï¼šç¦»çº¿èƒ½åŠ›é‡æ„ (1å‘¨)

- [ ] **Task 2.1**: é‡æ„SenseVoiceInputDevice
  - ä½¿ç”¨AudioServiceè·å–éŸ³é¢‘
  - ç®€åŒ–èŒè´£ä¸ºçº¯è¯†åˆ«

- [ ] **Task 2.2**: é‡æ„VoskInputDevice
  - åŒæ ·ä½¿ç”¨AudioService
  - ç»Ÿä¸€æ¥å£

- [ ] **Task 2.3**: é›†æˆæµ‹è¯•
  - ç¡®ä¿ç¦»çº¿æ¨¡å¼æ­£å¸¸å·¥ä½œ
  - æ€§èƒ½å¯¹æ¯”æµ‹è¯•

### é˜¶æ®µ3ï¼šåœ¨çº¿æœåŠ¡é›†æˆ (2-3å‘¨)

- [ ] **Task 3.1**: å®ç°ConnectionService
  - WebSocketå®¢æˆ·ç«¯å°è£…
  - åè®®å¤„ç†å™¨
  - é‡è¿æœºåˆ¶

- [ ] **Task 3.2**: å®ç°OnlineRecognizer
  - æµå¼ASRé›†æˆ
  - éƒ¨åˆ†è¯†åˆ«ç»“æœå¤„ç†

- [ ] **Task 3.3**: å®ç°OnlineTTS
  - æµå¼TTSéŸ³é¢‘æ¥æ”¶
  - å®æ—¶æ’­æ”¾

- [ ] **Task 3.4**: å®ç°Opusç¼–è§£ç 
  - é›†æˆOpusåº“
  - ç¼–è§£ç å™¨å°è£…

### é˜¶æ®µ4ï¼šæ··åˆæ¨¡å¼ (1-2å‘¨)

- [ ] **Task 4.1**: å®ç°HybridRecognizer
  - ç¦»çº¿ä¼˜å…ˆé€»è¾‘
  - åœ¨çº¿ä¿®æ­£é€»è¾‘

- [ ] **Task 4.2**: æ™ºèƒ½åˆ‡æ¢ç­–ç•¥
  - ç½‘ç»œçŠ¶æ€æ£€æµ‹
  - è‡ªåŠ¨é™çº§/å‡çº§

- [ ] **Task 4.3**: æ€§èƒ½ä¼˜åŒ–
  - å»¶è¿Ÿä¼˜åŒ–
  - å†…å­˜ä¼˜åŒ–

### é˜¶æ®µ5ï¼šFunction Calling (1å‘¨)

- [ ] **Task 5.1**: è®¾è®¡Function Callingåè®®
  - å®šä¹‰æ¶ˆæ¯æ ¼å¼
  - å®ç°è°ƒç”¨æœºåˆ¶

- [ ] **Task 5.2**: é›†æˆåˆ°SkillEvaluator
  - æŠ€èƒ½è¯†åˆ«ååˆ¤æ–­æ˜¯å¦éœ€è¦Function Call
  - æ‰§è¡Œå¹¶è¿”å›ç»“æœ

---

## å…­ã€æŠ€æœ¯ç»†èŠ‚

### 6.1 éŸ³é¢‘æ ¼å¼

- **é‡‡æ ·ç‡**: 16000 Hz
- **é€šé“æ•°**: å•å£°é“
- **ä½æ·±åº¦**: 16-bit PCM â†’ Float32
- **ç¼–ç æ ¼å¼**: Opus (åœ¨çº¿ä¼ è¾“)

### 6.2 WebSocketåè®®

å‚è€ƒxiaozhi-serverçš„åè®®ï¼š

```json
// å‘é€éŸ³é¢‘
{
  "type": "audio",
  "format": "opus",
  "sample_rate": 16000,
  "data": "<base64_encoded_opus>"
}

// æ¥æ”¶ASRç»“æœ
{
  "type": "asr_result",
  "is_final": false,
  "text": "ä½ å¥½",
  "confidence": 0.95
}

// æ¥æ”¶TTSéŸ³é¢‘
{
  "type": "tts_audio",
  "format": "opus",
  "data": "<base64_encoded_opus>"
}
```

### 6.3 ä¾èµ–åº“

æ–°å¢ä¾èµ–ï¼š

```kotlin
// OkHttp WebSocket
implementation("com.squareup.okhttp3:okhttp:4.12.0")

// Opusç¼–è§£ç 
implementation("com.github.TakuSemba:Opus-Wrapper:1.0.0")
// æˆ–ä½¿ç”¨sherpa-onnxè‡ªå¸¦çš„Opus
```

---

## ä¸ƒã€é£é™©è¯„ä¼°

| é£é™© | å½±å“ | ç¼“è§£æªæ–½ |
|-----|-----|---------|
| é‡æ„å¯¼è‡´ç°æœ‰åŠŸèƒ½ä¸ç¨³å®š | é«˜ | åˆ†é˜¶æ®µå®æ–½ï¼Œä¿æŒå‘åå…¼å®¹ |
| åœ¨çº¿æœåŠ¡å»¶è¿Ÿå½±å“ä½“éªŒ | ä¸­ | ç¦»çº¿ä¼˜å…ˆç­–ç•¥ï¼Œè¾¹æ”¶è¾¹å¤„ç† |
| éŸ³é¢‘å¤„ç†æ€§èƒ½é—®é¢˜ | ä¸­ | ä½¿ç”¨Kotlin Coroutinesä¼˜åŒ–å¹¶å‘ |
| WebSocketè¿æ¥ä¸ç¨³å®š | ä¸­ | å®ç°è‡ªåŠ¨é‡è¿å’Œé™çº§ç­–ç•¥ |

---

## å…«ã€åç»­ä¼˜åŒ–æ–¹å‘

1. **ç‹¬ç«‹ä¸ºAndroid Library Module** - è®©å…¶ä»–åº”ç”¨å¯ä»¥ä¾èµ–
2. **AIDLæœåŠ¡åŒ–** - æä¾›è·¨è¿›ç¨‹è°ƒç”¨èƒ½åŠ›
3. **å¤šè®¾å¤‡åŒæ­¥** - æ”¯æŒå¤šè®¾å¤‡ååŒ
4. **ç¦»çº¿Function Calling** - æœ¬åœ°å‡½æ•°è°ƒç”¨èƒ½åŠ›

---

## ä¹ã€æ€»ç»“

æœ¬æ¬¡æ¶æ„ä¼˜åŒ–çš„æ ¸å¿ƒç›®æ ‡æ˜¯ï¼š

1. âœ… **ç‹¬ç«‹éŸ³é¢‘æœåŠ¡** - ä»InputDeviceä¸­è§£è€¦
2. âœ… **æ··åˆè¯†åˆ«æ¨¡å¼** - ç¦»çº¿+åœ¨çº¿æ— ç¼åˆ‡æ¢
3. âœ… **æœåŠ¡åŒ–æ¶æ„** - ä¸ºæœªæ¥æ¨¡å—åŒ–æ‰“åŸºç¡€
4. âœ… **ç²¾ç¡®çŠ¶æ€ç®¡ç†** - æ¸…æ™°çš„çŠ¶æ€æœº
5. âœ… **è¾¹æ”¶è¾¹å¤„ç†** - çœŸæ­£çš„æµå¼ä½“éªŒ

å‚è€ƒxiaozhi-esp32çš„ä¼˜ç§€è®¾è®¡ï¼Œç»“åˆAndroidå¹³å°ç‰¹æ€§ï¼Œæ‰“é€ é«˜æ€§èƒ½ã€çµæ´»ã€å¯æ‰©å±•çš„è¯­éŸ³åŠ©æ‰‹æ¶æ„ã€‚


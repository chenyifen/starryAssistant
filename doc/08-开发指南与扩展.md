# Dicio 开发指南与扩展

## 开发环境搭建

### 1. 系统要求

#### 开发环境
- **操作系统**: Windows 10+, macOS 10.14+, Linux (Ubuntu 18.04+)
- **Java**: JDK 11 或更高版本 (推荐 JDK 17)
- **Android Studio**: Arctic Fox (2020.3.1) 或更高版本
- **Gradle**: 8.0+ (项目已配置)
- **Git**: 2.20+ 用于版本控制

#### 硬件要求
- **内存**: 最少 8GB RAM (推荐 16GB)
- **存储**: 至少 10GB 可用空间
- **网络**: 稳定的网络连接用于依赖下载

### 2. 项目克隆和设置

#### 克隆项目
```bash
# 克隆主项目
git clone https://github.com/Stypox/dicio-android.git
cd dicio-android

# 克隆依赖项目 (如果使用本地模式)
cd ..
git clone https://github.com/Stypox/dicio-numbers.git
git clone https://github.com/Stypox/dicio-sentences-compiler.git

# 切换到指定版本
cd dicio-numbers
git checkout 66fd44b79585f952b76d16e5578d4d6aa5bc030c

cd ../dicio-sentences-compiler  
git checkout 7d83fe5a3d6dff2fc81b5c40783a1d82ada293d3
```

#### 配置本地属性
```properties
# local.properties
sdk.dir=/path/to/android/sdk
useLocalDicioLibraries=true  # 使用本地依赖库
```

### 3. IDE 配置

#### Android Studio 设置
```kotlin
// 推荐的 IDE 设置
- Code Style: Kotlin Official
- Inspections: 启用所有 Kotlin 检查
- Plugins: 
  - Kotlin
  - Hilt
  - Protocol Buffers
  - Compose
```

#### 构建配置
```bash
# 检查 Java 版本
java -version

# 设置 JAVA_HOME (如果需要)
export JAVA_HOME=/path/to/jdk

# 构建项目
./gradlew build

# 运行测试
./gradlew test
```

## 项目结构详解

### 1. 模块组织

```
dicio-android/
├── app/                          # 主应用模块
│   ├── src/main/
│   │   ├── kotlin/              # Kotlin 源码
│   │   │   └── org/stypox/dicio/
│   │   │       ├── di/          # 依赖注入
│   │   │       ├── eval/        # 技能评估
│   │   │       ├── io/          # 输入输出
│   │   │       ├── settings/    # 设置管理
│   │   │       ├── skills/      # 技能实现
│   │   │       ├── ui/          # 用户界面
│   │   │       └── util/        # 工具类
│   │   ├── proto/               # Protocol Buffers
│   │   ├── res/                 # 资源文件
│   │   └── sentences/           # 语句定义
│   ├── src/test/                # 单元测试
│   └── src/androidTest/         # 集成测试
├── skill/                       # 技能库模块
├── sentences-compiler-plugin/   # 语句编译插件
└── doc/                        # 项目文档
```

### 2. 包结构说明

#### 核心包
- `di/`: Dagger Hilt 依赖注入配置
- `eval/`: 技能评估和执行引擎
- `io/`: 输入输出设备抽象和实现
- `settings/`: 配置管理和设置界面
- `skills/`: 各种技能的具体实现
- `ui/`: Jetpack Compose UI 组件
- `util/`: 通用工具类和扩展函数

#### 技能包结构
```
skills/
├── calculator/          # 计算器技能
├── current_time/        # 时间查询技能
├── fallback/           # 回退技能
├── listening/          # 监听控制技能
├── lyrics/             # 歌词搜索技能
├── media/              # 媒体控制技能
├── navigation/         # 导航技能
├── open/               # 应用启动技能
├── search/             # 搜索技能
├── telephone/          # 电话技能
├── timer/              # 定时器技能
└── weather/            # 天气技能
```

## 新技能开发

### 1. 技能开发流程

#### 步骤概览
1. **需求分析**: 确定技能功能和交互方式
2. **句式设计**: 定义用户输入模式
3. **技能实现**: 编写技能逻辑代码
4. **测试验证**: 单元测试和集成测试
5. **文档编写**: 更新相关文档

### 2. 创建新技能

#### 1. 定义句式结构

**skill_definitions.yml**
```yaml
- id: my_skill
  specificity: high
  sentences:
    - id: action_one
      captures:
        - id: parameter
          type: string
    - id: action_two
      captures:
        - id: number
          type: number
        - id: unit
          type: string
```

**语言句式文件** (`app/src/main/sentences/en/my_skill.yml`)
```yaml
action_one:
  - do something with .parameter.
  - perform action on .parameter.
  - execute .parameter. operation

action_two:
  - set .number. .unit.
  - configure .number. .unit. setting
```

#### 2. 实现技能类

**MySkillInfo.kt**
```kotlin
package org.stypox.dicio.skills.myskill

import android.content.Context
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Star
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.vector.rememberVectorPainter
import org.dicio.skill.context.SkillContext
import org.dicio.skill.skill.Skill
import org.dicio.skill.skill.SkillInfo
import org.stypox.dicio.R
import org.stypox.dicio.sentences.Sentences

object MySkillInfo : SkillInfo("my_skill") {
    override fun name(context: Context) =
        context.getString(R.string.skill_name_my_skill)

    override fun sentenceExample(context: Context) =
        context.getString(R.string.skill_sentence_example_my_skill)

    @Composable
    override fun icon() =
        rememberVectorPainter(Icons.Default.Star)

    override fun isAvailable(ctx: SkillContext): Boolean {
        return Sentences.MySkill[ctx.sentencesLanguage] != null
    }

    override fun build(ctx: SkillContext): Skill<*> {
        return MySkill(MySkillInfo, Sentences.MySkill[ctx.sentencesLanguage]!!)
    }
}
```

**MySkill.kt**
```kotlin
package org.stypox.dicio.skills.myskill

import org.dicio.skill.context.SkillContext
import org.dicio.skill.skill.SkillInfo
import org.dicio.skill.skill.SkillOutput
import org.dicio.skill.standard.StandardRecognizerData
import org.dicio.skill.standard.StandardRecognizerSkill
import org.stypox.dicio.sentences.Sentences.MySkill

class MySkill(
    correspondingSkillInfo: SkillInfo,
    data: StandardRecognizerData<MySkill>
) : StandardRecognizerSkill<MySkill>(correspondingSkillInfo, data) {

    override suspend fun generateOutput(
        ctx: SkillContext,
        inputData: MySkill
    ): SkillOutput {
        return when (inputData) {
            is MySkill.ActionOne -> handleActionOne(ctx, inputData)
            is MySkill.ActionTwo -> handleActionTwo(ctx, inputData)
        }
    }

    private suspend fun handleActionOne(
        ctx: SkillContext,
        input: MySkill.ActionOne
    ): SkillOutput {
        val parameter = input.parameter
        
        // 实现具体逻辑
        val result = performAction(parameter)
        
        return MySkillOutput.Success(
            text = ctx.getString(R.string.my_skill_action_one_result, result),
            data = result
        )
    }

    private suspend fun handleActionTwo(
        ctx: SkillContext,
        input: MySkill.ActionTwo
    ): SkillOutput {
        val number = input.number?.let { 
            ctx.parserFormatter?.extractNumber(it)?.first 
        }
        val unit = input.unit
        
        if (number == null) {
            return MySkillOutput.AskNumber { value ->
                handleActionTwoWithNumber(ctx, value, unit)
            }
        }
        
        return handleActionTwoWithNumber(ctx, number, unit)
    }

    private suspend fun handleActionTwoWithNumber(
        ctx: SkillContext,
        number: Number,
        unit: String?
    ): SkillOutput {
        // 实现数值处理逻辑
        val result = processNumberWithUnit(number, unit)
        
        return MySkillOutput.Success(
            text = ctx.getString(R.string.my_skill_action_two_result, number, unit),
            data = result
        )
    }

    private suspend fun performAction(parameter: String?): String {
        // 实现具体的业务逻辑
        return "Action performed on: $parameter"
    }

    private suspend fun processNumberWithUnit(number: Number, unit: String?): Any {
        // 实现数值处理逻辑
        return mapOf("number" to number, "unit" to unit)
    }
}
```

**MySkillOutput.kt**
```kotlin
package org.stypox.dicio.skills.myskill

import org.dicio.skill.skill.SkillOutput

sealed class MySkillOutput : SkillOutput() {
    
    data class Success(
        val text: String,
        val data: Any
    ) : MySkillOutput() {
        override fun getSpeechOutput(): String = text
    }
    
    data class AskNumber(
        val followUpSkill: suspend (Number) -> SkillOutput
    ) : MySkillOutput() {
        override fun getSpeechOutput(): String = 
            "Please provide a number"
        
        override fun getNextSkills(): List<Skill<String>> = 
            listOf(NumberInputSkill(followUpSkill))
    }
    
    data class Error(
        val message: String
    ) : MySkillOutput() {
        override fun getSpeechOutput(): String = message
    }
}
```

#### 3. 注册技能

**SkillHandler.kt**
```kotlin
val allSkillInfoList = listOf(
    WeatherInfo,
    SearchInfo,
    // ... 其他技能
    MySkillInfo, // 添加新技能
)
```

#### 4. 添加资源文件

**strings.xml**
```xml
<resources>
    <!-- My Skill -->
    <string name="skill_name_my_skill">My Skill</string>
    <string name="skill_sentence_example_my_skill">Do something with parameter</string>
    <string name="my_skill_action_one_result">Action completed: %1$s</string>
    <string name="my_skill_action_two_result">Set %1$s %2$s successfully</string>
</resources>
```

### 3. 高级技能开发

#### 网络请求技能
```kotlin
class NetworkSkill(
    correspondingSkillInfo: SkillInfo,
    data: StandardRecognizerData<NetworkSkillType>
) : StandardRecognizerSkill<NetworkSkillType>(correspondingSkillInfo, data) {

    private val httpClient = OkHttpClient()

    override suspend fun generateOutput(
        ctx: SkillContext,
        inputData: NetworkSkillType
    ): SkillOutput = withContext(Dispatchers.IO) {
        try {
            val response = makeNetworkRequest(inputData)
            NetworkSkillOutput.Success(response)
        } catch (e: Exception) {
            NetworkSkillOutput.Error("Network request failed: ${e.message}")
        }
    }

    private suspend fun makeNetworkRequest(input: NetworkSkillType): String {
        val request = Request.Builder()
            .url(buildUrl(input))
            .build()

        return httpClient.newCall(request).execute().use { response ->
            if (response.isSuccessful) {
                response.body?.string() ?: ""
            } else {
                throw IOException("HTTP ${response.code}")
            }
        }
    }
}
```

#### 权限相关技能
```kotlin
object PermissionSkillInfo : SkillInfo("permission_skill") {
    override val neededPermissions: List<Permission> = listOf(
        PERMISSION_READ_CONTACTS,
        PERMISSION_CALL_PHONE
    )

    // ... 其他实现
}

class PermissionSkill : StandardRecognizerSkill<PermissionSkillType> {
    
    override suspend fun generateOutput(
        ctx: SkillContext,
        inputData: PermissionSkillType
    ): SkillOutput {
        // 检查权限
        val hasPermissions = checkPermissions(ctx, neededPermissions)
        
        if (!hasPermissions) {
            return PermissionSkillOutput.RequestPermission(neededPermissions)
        }
        
        // 执行需要权限的操作
        return performPermissionRequiredAction(ctx, inputData)
    }
}
```

## UI 组件开发

### 1. 创建新的 Compose 组件

#### 基础组件
```kotlin
@Composable
fun MyCustomComponent(
    title: String,
    subtitle: String?,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { onClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 4.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = title,
                style = MaterialTheme.typography.headlineSmall
            )
            
            subtitle?.let { subtitle ->
                Spacer(modifier = Modifier.height(4.dp))
                Text(
                    text = subtitle,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}
```

#### 状态管理组件
```kotlin
@Composable
fun StatefulComponent(
    initialValue: String = "",
    onValueChange: (String) -> Unit
) {
    var value by remember { mutableStateOf(initialValue) }
    
    LaunchedEffect(value) {
        onValueChange(value)
    }
    
    Column {
        TextField(
            value = value,
            onValueChange = { value = it },
            label = { Text("Enter value") }
        )
        
        Text(
            text = "Current value: $value",
            modifier = Modifier.padding(top = 8.dp)
        )
    }
}
```

### 2. 主题和样式

#### 自定义主题
```kotlin
@Composable
fun MyCustomTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        darkTheme -> darkColorScheme(
            primary = Color(0xFF1976D2),
            secondary = Color(0xFF03DAC6)
        )
        else -> lightColorScheme(
            primary = Color(0xFF1976D2),
            secondary = Color(0xFF03DAC6)
        )
    }
    
    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
}
```

#### 自定义样式
```kotlin
object MyStyles {
    val CardElevation = 8.dp
    val CornerRadius = 12.dp
    val DefaultPadding = 16.dp
    
    @Composable
    fun primaryButtonColors() = ButtonDefaults.buttonColors(
        containerColor = MaterialTheme.colorScheme.primary,
        contentColor = MaterialTheme.colorScheme.onPrimary
    )
}
```

## 测试开发

### 1. 单元测试

#### 技能测试
```kotlin
@RunWith(JUnit4::class)
class MySkillTest {
    
    private lateinit var skill: MySkill
    private lateinit var mockContext: SkillContext
    
    @Before
    fun setup() {
        mockContext = mockk<SkillContext>()
        every { mockContext.getString(any(), *anyVararg()) } returns "Test result"
        
        skill = MySkill(MySkillInfo, mockk())
    }
    
    @Test
    fun `test action one with valid parameter`() = runTest {
        val input = MySkill.ActionOne(parameter = "test")
        
        val result = skill.generateOutput(mockContext, input)
        
        assertThat(result).isInstanceOf(MySkillOutput.Success::class.java)
        val success = result as MySkillOutput.Success
        assertThat(success.text).contains("test")
    }
    
    @Test
    fun `test action two without number`() = runTest {
        val input = MySkill.ActionTwo(number = null, unit = "meters")
        
        val result = skill.generateOutput(mockContext, input)
        
        assertThat(result).isInstanceOf(MySkillOutput.AskNumber::class.java)
    }
}
```

#### ViewModel 测试
```kotlin
@RunWith(JUnit4::class)
class HomeScreenViewModelTest {
    
    @get:Rule
    val mainDispatcherRule = MainDispatcherRule()
    
    private lateinit var viewModel: HomeScreenViewModel
    private lateinit var mockSkillEvaluator: SkillEvaluator
    
    @Before
    fun setup() {
        mockSkillEvaluator = mockk<SkillEvaluator>()
        every { mockSkillEvaluator.state } returns MutableStateFlow(InteractionLog())
        
        viewModel = HomeScreenViewModel(
            skillHandler = mockk(),
            skillEvaluator = mockSkillEvaluator,
            sttInputDevice = mockk(),
            wakeDevice = mockk()
        )
    }
    
    @Test
    fun `test initial state`() {
        val state = viewModel.uiState.value
        
        assertThat(state.isListening).isFalse()
        assertThat(state.interactions).isEmpty()
    }
}
```

### 2. UI 测试

#### Compose 测试
```kotlin
@RunWith(AndroidJUnit4::class)
class MyCustomComponentTest {
    
    @get:Rule
    val composeTestRule = createComposeRule()
    
    @Test
    fun testComponentDisplaysTitle() {
        val title = "Test Title"
        
        composeTestRule.setContent {
            MyCustomComponent(
                title = title,
                subtitle = null,
                onClick = {}
            )
        }
        
        composeTestRule
            .onNodeWithText(title)
            .assertIsDisplayed()
    }
    
    @Test
    fun testComponentClickable() {
        var clicked = false
        
        composeTestRule.setContent {
            MyCustomComponent(
                title = "Test",
                subtitle = null,
                onClick = { clicked = true }
            )
        }
        
        composeTestRule
            .onNodeWithText("Test")
            .performClick()
        
        assertThat(clicked).isTrue()
    }
}
```

### 3. 集成测试

#### 端到端测试
```kotlin
@RunWith(AndroidJUnit4::class)
@HiltAndroidTest
class EndToEndTest {
    
    @get:Rule
    val hiltRule = HiltAndroidRule(this)
    
    @get:Rule
    val activityRule = ActivityScenarioRule(MainActivity::class.java)
    
    @Before
    fun init() {
        hiltRule.inject()
    }
    
    @Test
    fun testVoiceInteractionFlow() {
        // 点击麦克风按钮
        onView(withId(R.id.mic_button))
            .perform(click())
        
        // 验证开始监听
        onView(withText("Listening..."))
            .check(matches(isDisplayed()))
        
        // 模拟语音输入
        // 这里需要使用测试用的 STT 设备
        
        // 验证结果显示
        onView(withText(containsString("Result:")))
            .check(matches(isDisplayed()))
    }
}
```

## 构建和发布

### 1. 构建配置

#### Gradle 配置优化
```kotlin
android {
    compileSdk 34
    
    defaultConfig {
        minSdk 21
        targetSdk 34
        versionCode 1
        versionName "1.0"
        
        // 启用多 dex
        multiDexEnabled true
        
        // 矢量图支持
        vectorDrawables.useSupportLibrary = true
    }
    
    buildTypes {
        debug {
            isMinifyEnabled = false
            isDebuggable = true
            applicationIdSuffix = ".debug"
        }
        
        release {
            isMinifyEnabled = true
            isShrinkResources = true
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
            
            // 签名配置
            signingConfig = signingConfigs.getByName("release")
        }
    }
    
    // 构建优化
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }
    
    kotlinOptions {
        jvmTarget = "11"
        freeCompilerArgs += listOf(
            "-opt-in=kotlin.RequiresOptIn",
            "-opt-in=kotlinx.coroutines.ExperimentalCoroutinesApi"
        )
    }
}
```

#### ProGuard 配置
```proguard
# proguard-rules.pro

# Keep Dicio classes
-keep class org.stypox.dicio.** { *; }

# Keep Vosk classes
-keep class org.vosk.** { *; }

# Keep Protocol Buffers
-keep class * extends com.google.protobuf.GeneratedMessageLite { *; }

# Keep Hilt generated classes
-keep class dagger.hilt.** { *; }
-keep class * extends dagger.hilt.android.HiltAndroidApp
-keep @dagger.hilt.android.AndroidEntryPoint class * {
    *;
}

# Keep Compose classes
-keep class androidx.compose.** { *; }
```

### 2. 版本管理

#### 版本号策略
```kotlin
// build.gradle.kts
android {
    defaultConfig {
        versionCode = generateVersionCode()
        versionName = "3.2.0"
    }
}

fun generateVersionCode(): Int {
    val major = 3
    val minor = 2
    val patch = 0
    return major * 10000 + minor * 100 + patch
}
```

#### Git 标签和发布
```bash
# 创建版本标签
git tag -a v3.2.0 -m "Release version 3.2.0"
git push origin v3.2.0

# 创建发布分支
git checkout -b release/3.2.0
git push origin release/3.2.0
```

### 3. 持续集成

#### GitHub Actions 配置
```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [ master, develop ]
  pull_request:
    branches: [ master ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up JDK 11
      uses: actions/setup-java@v3
      with:
        java-version: '11'
        distribution: 'temurin'
        
    - name: Cache Gradle packages
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        
    - name: Grant execute permission for gradlew
      run: chmod +x gradlew
      
    - name: Run tests
      run: ./gradlew test
      
    - name: Run lint
      run: ./gradlew lint
      
    - name: Build APK
      run: ./gradlew assembleDebug
```

## 贡献指南

### 1. 代码规范

#### Kotlin 编码规范
```kotlin
// 类命名：PascalCase
class MyAwesomeClass

// 函数命名：camelCase
fun performAction()

// 常量命名：UPPER_SNAKE_CASE
const val MAX_RETRY_COUNT = 3

// 私有属性：下划线前缀
private val _state = MutableStateFlow(...)
val state: StateFlow<...> = _state.asStateFlow()

// 文档注释
/**
 * Performs a complex operation with the given parameters.
 * 
 * @param input The input data to process
 * @param options Configuration options for the operation
 * @return The result of the operation
 * @throws IllegalArgumentException if input is invalid
 */
suspend fun performComplexOperation(
    input: String,
    options: OperationOptions
): OperationResult {
    // Implementation
}
```

#### 提交信息规范
```
type(scope): description

body

footer
```

示例：
```
feat(skills): add weather forecast skill

- Implement 5-day weather forecast
- Add location-based weather queries
- Support multiple weather providers

Closes #123
```

### 2. Pull Request 流程

#### PR 检查清单
- [ ] 代码遵循项目编码规范
- [ ] 添加了必要的测试
- [ ] 更新了相关文档
- [ ] 通过了所有 CI 检查
- [ ] 功能经过手动测试验证

#### PR 模板
```markdown
## 变更描述
简要描述此 PR 的变更内容

## 变更类型
- [ ] Bug 修复
- [ ] 新功能
- [ ] 性能优化
- [ ] 重构
- [ ] 文档更新

## 测试
描述如何测试这些变更

## 截图
如果适用，添加截图说明变更

## 检查清单
- [ ] 代码遵循项目规范
- [ ] 添加了测试
- [ ] 更新了文档
```

### 3. 问题报告

#### Bug 报告模板
```markdown
## Bug 描述
清晰简洁地描述 bug

## 复现步骤
1. 打开应用
2. 点击 '...'
3. 输入 '...'
4. 看到错误

## 期望行为
描述期望发生的行为

## 实际行为
描述实际发生的行为

## 环境信息
- 设备: [e.g. Pixel 6]
- Android 版本: [e.g. 13]
- 应用版本: [e.g. 3.2.0]

## 附加信息
添加任何其他相关信息
```

## 部署和分发

### 1. F-Droid 发布

#### 元数据配置
```yaml
# fastlane/metadata/android/en-US/
title.txt: "Dicio"
short_description.txt: "Open source voice assistant"
full_description.txt: |
  Dicio is a free and open source voice assistant running on Android.
  
  Features:
  - Completely offline speech recognition
  - Customizable skills system
  - Privacy-focused design
  - Multi-language support
```

### 2. GitHub Releases

#### 自动化发布脚本
```bash
#!/bin/bash
# release.sh

VERSION=$1
if [ -z "$VERSION" ]; then
    echo "Usage: $0 <version>"
    exit 1
fi

# 构建发布版本
./gradlew assembleRelease

# 创建标签
git tag -a "v$VERSION" -m "Release version $VERSION"
git push origin "v$VERSION"

# 上传到 GitHub Releases
gh release create "v$VERSION" \
    app/build/outputs/apk/release/app-release.apk \
    --title "Dicio v$VERSION" \
    --notes-file CHANGELOG.md
```

通过这个全面的开发指南，开发者可以快速上手 Dicio 项目的开发，理解项目架构，并贡献高质量的代码。

# 唤醒功能调试指南

## 概述

本文档提供了Dicio应用唤醒功能的详细调试指南，包括问题诊断、解决方案和调试工具的使用。

## 调试日志系统

### DebugLogger工具类

项目中已集成了`DebugLogger`工具类，提供分类调试日志：

```kotlin
// 位置：app/src/main/kotlin/org/stypox/dicio/util/DebugLogger.kt

object DebugLogger {
    private const val DEBUG_ENABLED = true // 主开关
    
    // 分类开关
    private const val DEBUG_WAKE_WORD = DEBUG_ENABLED && true
    private const val DEBUG_VOICE_RECOGNITION = DEBUG_ENABLED && true
    private const val DEBUG_AUDIO_PROCESSING = DEBUG_ENABLED && true
    private const val DEBUG_MODEL_MANAGEMENT = DEBUG_ENABLED && true
    private const val DEBUG_STATE_MACHINE = DEBUG_ENABLED && true
}
```

### 日志类别说明

| 前缀 | 功能 | 示例 |
|------|------|------|
| 🔊 | 唤醒词相关 | `🔊[OpenWakeWordDevice] 🚀 Initializing OpenWakeWordDevice` |
| 🎤 | 语音识别 | `🎤[VoskInputDevice] 🔄 Loading Vosk model...` |
| 🎵 | 音频处理 | `🎵[WakeService] 🎵 AudioRecord config: source=VOICE_RECOGNITION` |
| 📦 | 模型管理 | `📦[AssetModelManager] ✅ Successfully copied models from assets` |
| ⚙️ | 状态机 | `⚙️[OpenWakeWordDevice] State changed to Loading` |
| 📊 | 音频统计 | `📊[OpenWakeWordDevice] Frame: 1152, Amplitude: 0.000` |
| 🎯 | 检测结果 | `🎯[OpenWakeWordDevice] ❌ NOT_DETECTED - Confidence: 0.001` |
| ⏱️ | 性能监控 | `⏱️[OpenWakeWordDevice] Process audio frame took 11ms` |

## 当前问题分析

### 问题现象

根据最新日志，发现以下问题：

1. **音频幅度异常低**：`Amplitude: 0.000` 或接近0的值
2. **置信度固定在最低值**：`Confidence: 0.001`
3. **持续未检测到**：`❌ NOT_DETECTED`
4. **音频帧大小正常**：`Frame: 1152`（符合预期）

### 根本原因

**麦克风输入问题**：音频幅度接近0表明：
- 麦克风权限可能未正确授予
- AudioRecord配置可能不兼容设备硬件
- 音频输入源可能被其他应用占用

## 问题诊断步骤

### 1. 检查麦克风权限

```bash
# 通过ADB检查权限状态
adb shell dumpsys package org.stypox.dicio.master | grep RECORD_AUDIO
```

### 2. 验证AudioRecord配置

当前配置（在WakeService.kt中）：
```kotlin
val ar = AudioRecord(
    MediaRecorder.AudioSource.VOICE_RECOGNITION,  // 音频源
    16000,                                        // 采样率
    AudioFormat.CHANNEL_IN_MONO,                 // 单声道
    AudioFormat.ENCODING_PCM_16BIT,              // 16位PCM
    6400,                                        // 缓冲区大小
)
```

### 3. 音频输入测试

添加音频输入测试代码：
```kotlin
// 在WakeService.listenForWakeWord()中添加
val state = ar.recordingState
val audioSessionId = ar.audioSessionId
DebugLogger.logAudioProcessing(TAG, "AudioRecord state: $state, sessionId: $audioSessionId")

// 检查实际读取的字节数
val bytesRead = ar.read(audio, 0, audio.size)
if (bytesRead <= 0) {
    DebugLogger.logWakeWordError(TAG, "AudioRecord read failed: $bytesRead")
}
```

## 解决方案

### 方案1：运行时权限检查

在WakeService中添加更严格的权限检查：

```kotlin
private fun checkMicrophonePermission(): Boolean {
    val permission = ContextCompat.checkSelfPermission(this, RECORD_AUDIO)
    DebugLogger.logWakeWord(TAG, "Microphone permission status: $permission")
    
    if (permission != PERMISSION_GRANTED) {
        DebugLogger.logWakeWordError(TAG, "Microphone permission not granted")
        return false
    }
    
    // 额外检查：尝试创建AudioRecord实例
    return try {
        val testAr = AudioRecord(
            MediaRecorder.AudioSource.MIC,
            16000,
            AudioFormat.CHANNEL_IN_MONO,
            AudioFormat.ENCODING_PCM_16BIT,
            1024
        )
        val canRecord = testAr.state == AudioRecord.STATE_INITIALIZED
        testAr.release()
        DebugLogger.logWakeWord(TAG, "AudioRecord test result: $canRecord")
        canRecord
    } catch (e: Exception) {
        DebugLogger.logWakeWordError(TAG, "AudioRecord test failed", e)
        false
    }
}
```

### 方案2：AudioRecord配置优化

尝试不同的音频源配置：

```kotlin
private fun createAudioRecord(): AudioRecord? {
    val sources = arrayOf(
        MediaRecorder.AudioSource.VOICE_RECOGNITION,
        MediaRecorder.AudioSource.MIC,
        MediaRecorder.AudioSource.DEFAULT
    )
    
    for (source in sources) {
        try {
            val ar = AudioRecord(
                source,
                16000,
                AudioFormat.CHANNEL_IN_MONO,
                AudioFormat.ENCODING_PCM_16BIT,
                6400
            )
            
            if (ar.state == AudioRecord.STATE_INITIALIZED) {
                DebugLogger.logAudioProcessing(TAG, "Successfully created AudioRecord with source: $source")
                return ar
            } else {
                ar.release()
                DebugLogger.logWakeWordError(TAG, "Failed to initialize AudioRecord with source: $source")
            }
        } catch (e: Exception) {
            DebugLogger.logWakeWordError(TAG, "Exception creating AudioRecord with source: $source", e)
        }
    }
    
    return null
}
```

### 方案3：音频会话管理

添加音频会话管理：

```kotlin
private fun setupAudioSession(ar: AudioRecord) {
    try {
        val audioManager = getSystemService(Context.AUDIO_SERVICE) as AudioManager
        
        // 请求音频焦点
        val focusRequest = AudioFocusRequest.Builder(AudioManager.AUDIOFOCUS_GAIN_TRANSIENT)
            .setAudioAttributes(
                AudioAttributes.Builder()
                    .setUsage(AudioAttributes.USAGE_VOICE_COMMUNICATION)
                    .setContentType(AudioAttributes.CONTENT_TYPE_SPEECH)
                    .build()
            )
            .build()
            
        val result = audioManager.requestAudioFocus(focusRequest)
        DebugLogger.logAudioProcessing(TAG, "Audio focus request result: $result")
        
        // 设置音频模式
        audioManager.mode = AudioManager.MODE_IN_COMMUNICATION
        DebugLogger.logAudioProcessing(TAG, "Audio mode set to: ${audioManager.mode}")
        
    } catch (e: Exception) {
        DebugLogger.logWakeWordError(TAG, "Failed to setup audio session", e)
    }
}
```

## 调试命令

### ADB命令集合

```bash
# 检查应用权限
adb shell dumpsys package org.stypox.dicio.master | grep permission

# 检查音频设备
adb shell dumpsys audio | grep -A 10 "Audio Hardware"

# 检查正在录音的应用
adb shell dumpsys media.audio_flinger | grep -i record

# 实时查看日志
adb logcat | grep -E "(OpenWakeWordDevice|WakeService|AudioRecord)"

# 过滤调试日志
adb logcat | grep -E "🔊|🎤|🎵|📊|🎯|⏱️"
```

### 权限授予

```bash
# 手动授予麦克风权限
adb shell pm grant org.stypox.dicio.master android.permission.RECORD_AUDIO

# 检查权限状态
adb shell pm list permissions -d -g | grep RECORD_AUDIO
```

## 性能监控

### 关键指标

1. **音频幅度**：正常范围 0.01-1.0
2. **处理时间**：应 < 20ms per frame
3. **置信度**：正常范围 0.0-1.0
4. **帧大小**：固定 1152 samples

### 异常模式识别

| 模式 | 可能原因 | 解决方案 |
|------|----------|----------|
| Amplitude = 0.000 | 麦克风无输入 | 检查权限和硬件 |
| Confidence = 0.001 | 模型未正确加载 | 重新初始化模型 |
| Processing > 50ms | CPU过载 | 优化处理逻辑 |
| 频繁状态切换 | 资源竞争 | 检查并发访问 |

## 一键开关调试

### 快速禁用调试日志

修改`DebugLogger.kt`中的开关：

```kotlin
object DebugLogger {
    private const val DEBUG_ENABLED = false // 设为false禁用所有日志
    
    // 或者分别控制
    private const val DEBUG_WAKE_WORD = false
    private const val DEBUG_AUDIO_PROCESSING = false
}
```

### 编译时移除调试代码

使用ProGuard规则（在`proguard-rules.pro`中）：

```proguard
# 移除调试日志调用
-assumenosideeffects class org.stypox.dicio.util.DebugLogger {
    public static void logWakeWord(...);
    public static void logAudioProcessing(...);
    public static void logWakeWordError(...);
}
```

## 下一步行动

基于当前问题（音频幅度为0），建议按以下顺序执行：

1. **立即执行**：检查并重新授予麦克风权限
2. **短期**：实现AudioRecord配置优化
3. **中期**：添加音频会话管理
4. **长期**：实现自适应音频配置

## 常见问题FAQ

### Q: 为什么音频幅度始终为0？
A: 通常是麦克风权限问题或AudioRecord配置不兼容设备硬件。

### Q: 如何验证模型是否正确加载？
A: 检查日志中的"✅ OWW model loaded successfully"消息。

### Q: 置信度为什么固定在0.001？
A: 当音频输入为静音时，模型输出最低置信度值。

### Q: 如何临时禁用唤醒功能？
A: 在设置中关闭唤醒服务，或将`DEBUG_ENABLED`设为false。

---

*最后更新：2025年1月*
*版本：1.0*
# Dicio 依赖注入与模块化设计

## 依赖注入架构概述

Dicio 采用 Dagger Hilt 作为依赖注入框架，实现了清晰的模块化架构。通过依赖注入，系统实现了松耦合、可测试、可维护的代码结构，支持不同组件的灵活替换和配置。

## 技术栈

### 依赖注入技术
- **Dagger Hilt**: Google 官方推荐的 DI 框架
- **Kotlin Coroutines**: 异步依赖管理
- **StateFlow**: 响应式依赖更新
- **Singleton**: 单例生命周期管理

### 相关依赖
```kotlin
com.google.dagger:hilt-android:2.55
com.google.dagger:hilt-android-compiler:2.55
androidx.hilt:hilt-navigation-compose:1.2.0
```

## 应用级配置

### 1. Application 类

#### App
- **文件**: `app/src/main/kotlin/org/stypox/dicio/App.kt`
- **功能**: Hilt 应用入口点

```kotlin
@HiltAndroidApp
class App : Application() {
    override fun onCreate() {
        super.onCreate()
        // 应用初始化逻辑
    }
}
```

### 2. Activity 注入

#### MainActivity
```kotlin
@AndroidEntryPoint
class MainActivity : BaseActivity() {
    
    @Inject lateinit var skillEvaluator: SkillEvaluator
    @Inject lateinit var sttInputDevice: SttInputDeviceWrapper
    @Inject lateinit var wakeDevice: WakeDeviceWrapper
    
    // Activity 生命周期方法
}
```

#### BaseActivity
```kotlin
abstract class BaseActivity : ComponentActivity() {
    
    @Inject lateinit var activityForResultManager: ActivityForResultManager
    @Inject lateinit var localeManager: LocaleManager
    @Inject lateinit var dataStore: DataStore<UserSettings>
    
    // 基础 Activity 功能
}
```

## 核心模块设计

### 1. IO 模块

#### IoModule
- **文件**: `app/src/main/kotlin/org/stypox/dicio/di/IoModule.kt`
- **功能**: 输入输出设备依赖注入

```kotlin
@Module
@InstallIn(SingletonComponent::class)
class IoModule {
    
    @Provides
    @Singleton
    fun provideOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .build()
    }
    
    @Provides
    @Singleton
    fun provideVoskInputDevice(
        @ApplicationContext appContext: Context,
        okHttpClient: OkHttpClient,
        localeManager: LocaleManager,
    ): VoskInputDevice {
        return VoskInputDevice(appContext, okHttpClient, localeManager)
    }
    
    @Provides
    @Singleton
    fun provideAndroidSttInputDevice(
        @ApplicationContext appContext: Context,
        localeManager: LocaleManager,
    ): AndroidSttInputDevice {
        return AndroidSttInputDevice(appContext, localeManager)
    }
    
    @Provides
    @Singleton
    fun provideExternalPopupInputDevice(): ExternalPopupInputDevice {
        return ExternalPopupInputDevice()
    }
    
    @Provides
    @Singleton
    fun provideSttInputDeviceWrapper(
        dataStore: DataStore<UserSettings>,
        voskInputDevice: VoskInputDevice,
        androidSttInputDevice: AndroidSttInputDevice,
        externalPopupInputDevice: ExternalPopupInputDevice,
    ): SttInputDeviceWrapper {
        return SttInputDeviceWrapper(
            dataStore,
            voskInputDevice,
            androidSttInputDevice,
            externalPopupInputDevice
        )
    }
    
    @Provides
    @Singleton
    fun provideHeyDicioWakeDevice(
        sttInputDevice: SttInputDeviceWrapper,
    ): HeyDicioWakeDevice {
        return HeyDicioWakeDevice(sttInputDevice)
    }
    
    @Provides
    @Singleton
    fun provideOpenWakeWordDevice(
        @ApplicationContext appContext: Context,
        okHttpClient: OkHttpClient,
    ): OpenWakeWordDevice {
        return OpenWakeWordDevice(appContext, okHttpClient)
    }
    
    @Provides
    @Singleton
    fun provideWakeDeviceWrapper(
        dataStore: DataStore<UserSettings>,
        heyDicioWakeDevice: HeyDicioWakeDevice,
        openWakeWordDevice: OpenWakeWordDevice,
    ): WakeDeviceWrapper? {
        return WakeDeviceWrapper(
            dataStore,
            heyDicioWakeDevice,
            openWakeWordDevice
        )
    }
    
    @Provides
    @Singleton
    fun provideAndroidTtsSpeechDevice(
        @ApplicationContext appContext: Context,
        localeManager: LocaleManager,
    ): AndroidTtsSpeechDevice {
        return AndroidTtsSpeechDevice(appContext, localeManager)
    }
    
    @Provides
    @Singleton
    fun provideSpeechOutputDeviceWrapper(
        dataStore: DataStore<UserSettings>,
        androidTtsSpeechDevice: AndroidTtsSpeechDevice,
        toastSpeechDevice: ToastSpeechDevice,
        snackbarSpeechDevice: SnackbarSpeechDevice,
    ): SpeechOutputDeviceWrapper {
        return SpeechOutputDeviceWrapper(
            dataStore,
            androidTtsSpeechDevice,
            toastSpeechDevice,
            snackbarSpeechDevice
        )
    }
}
```

### 2. 本地化模块

#### LocaleManagerModule
- **文件**: `app/src/main/kotlin/org/stypox/dicio/di/LocaleManagerModule.kt`
- **功能**: 语言环境管理

```kotlin
@Module
@InstallIn(SingletonComponent::class)
class LocaleManagerModule {
    
    @Provides
    @Singleton
    fun provideLocaleManager(
        @ApplicationContext context: Context,
        dataStore: DataStore<UserSettings>
    ): LocaleManager {
        return LocaleManager(context, dataStore)
    }
}
```

### 3. 用户设置模块

#### UserSettingsModule
- **文件**: `app/src/main/kotlin/org/stypox/dicio/settings/datastore/UserSettingsModule.kt`
- **功能**: 数据存储配置

```kotlin
@Module
@InstallIn(SingletonComponent::class)
class UserSettingsModule {
    
    @Provides
    @Singleton
    fun provideUserSettingsDataStore(
        @ApplicationContext context: Context
    ): DataStore<UserSettings> {
        return DataStoreFactory.create(
            serializer = UserSettingsSerializer,
            corruptionHandler = ReplaceFileCorruptionHandler {
                UserSettingsSerializer.defaultValue
            },
            migrations = listOf(
                getSharedPreferencesMigration(context)
            ),
            produceFile = {
                context.dataStoreFile("settings.pb")
            }
        )
    }
}
```

### 4. 技能系统模块

#### SkillModule
- **文件**: `app/src/main/kotlin/org/stypox/dicio/di/SkillModule.kt`
- **功能**: 技能系统依赖注入

```kotlin
@Module
@InstallIn(SingletonComponent::class)
class SkillModule {
    
    @Provides
    @Singleton
    fun provideSkillContextInternal(
        @ApplicationContext appContext: Context,
        localeManager: LocaleManager,
        speechOutputDeviceWrapper: SpeechOutputDeviceWrapper,
    ): SkillContextInternal {
        return SkillContextInternal(
            android = appContext,
            localeManager = localeManager,
            speechOutputDevice = speechOutputDeviceWrapper
        )
    }
    
    @Provides
    @Singleton
    fun provideSkillHandler(
        dataStore: DataStore<UserSettings>,
        localeManager: LocaleManager,
        skillContext: SkillContextInternal,
    ): SkillHandler {
        return SkillHandler(dataStore, localeManager, skillContext)
    }
    
    @Provides
    @Singleton
    fun provideSkillEvaluator(
        skillHandler: SkillHandler,
        speechOutputDeviceWrapper: SpeechOutputDeviceWrapper,
        sttInputDevice: SttInputDeviceWrapper,
    ): SkillEvaluator {
        return SkillEvaluatorImpl(
            skillHandler,
            speechOutputDeviceWrapper,
            sttInputDevice
        )
    }
}
```

## 设备包装器设计

### 1. STT 设备包装器

#### SttInputDeviceWrapper
- **文件**: `app/src/main/kotlin/org/stypox/dicio/di/SttInputDeviceWrapper.kt`
- **功能**: STT 设备统一管理

```kotlin
@Singleton
class SttInputDeviceWrapper @Inject constructor(
    private val dataStore: DataStore<UserSettings>,
    private val voskInputDevice: VoskInputDevice,
    private val androidSttInputDevice: AndroidSttInputDevice,
    private val externalPopupInputDevice: ExternalPopupInputDevice,
) : SttInputDevice {
    
    private val scope = CoroutineScope(Dispatchers.Default)
    
    // 当前设备状态
    private val currentInputDevice: StateFlow<InputDevice> = dataStore.data
        .map { it.inputDevice }
        .distinctUntilChanged()
        .stateIn(
            scope = scope,
            started = SharingStarted.Eagerly,
            initialValue = InputDevice.INPUT_DEVICE_VOSK
        )
    
    // UI 状态合并
    override val uiState: StateFlow<SttState> = combine(
        currentInputDevice,
        voskInputDevice.uiState,
        androidSttInputDevice.uiState,
        externalPopupInputDevice.uiState
    ) { device, voskState, androidState, popupState ->
        when (device) {
            InputDevice.INPUT_DEVICE_VOSK -> voskState
            InputDevice.INPUT_DEVICE_ANDROID_STT -> androidState
            InputDevice.INPUT_DEVICE_EXTERNAL_POPUP -> popupState
            else -> voskState
        }
    }.stateIn(
        scope = scope,
        started = SharingStarted.Eagerly,
        initialValue = SttState.NotAvailable
    )
    
    // 设备选择逻辑
    private fun getCurrentDevice(): SttInputDevice {
        return when (currentInputDevice.value) {
            InputDevice.INPUT_DEVICE_VOSK -> voskInputDevice
            InputDevice.INPUT_DEVICE_ANDROID_STT -> androidSttInputDevice
            InputDevice.INPUT_DEVICE_EXTERNAL_POPUP -> externalPopupInputDevice
            else -> voskInputDevice
        }
    }
    
    // 委托方法实现
    override fun tryLoad(thenStartListeningEventListener: ((InputEvent) -> Unit)?) {
        getCurrentDevice().tryLoad(thenStartListeningEventListener)
    }
    
    override fun startListening(eventListener: (InputEvent) -> Unit) {
        getCurrentDevice().startListening(eventListener)
    }
    
    override fun stopListening() {
        getCurrentDevice().stopListening()
    }
    
    override fun reinitializeToReleaseResources() {
        // 重新初始化所有设备以释放资源
        voskInputDevice.reinitializeToReleaseResources()
        androidSttInputDevice.reinitializeToReleaseResources()
        externalPopupInputDevice.reinitializeToReleaseResources()
    }
}
```

### 2. 唤醒设备包装器

#### WakeDeviceWrapper
- **文件**: `app/src/main/kotlin/org/stypox/dicio/di/WakeDeviceWrapper.kt`
- **功能**: 唤醒设备统一管理

```kotlin
@Singleton
class WakeDeviceWrapper @Inject constructor(
    private val dataStore: DataStore<UserSettings>,
    private val heyDicioWakeDevice: HeyDicioWakeDevice,
    private val openWakeWordDevice: OpenWakeWordDevice,
) : WakeDevice {
    
    private val scope = CoroutineScope(Dispatchers.Default)
    
    private val currentWakeDevice: StateFlow<WakeDevice> = dataStore.data
        .map { it.wakeDevice }
        .distinctUntilChanged()
        .stateIn(
            scope = scope,
            started = SharingStarted.Eagerly,
            initialValue = WakeDevice.WAKE_DEVICE_NOTHING
        )
    
    val isHeyDicio: StateFlow<Boolean> = currentWakeDevice
        .map { it == WakeDevice.WAKE_DEVICE_HEY_DICIO }
        .stateIn(
            scope = scope,
            started = SharingStarted.Eagerly,
            initialValue = false
        )
    
    override val state: StateFlow<WakeState> = combine(
        currentWakeDevice,
        heyDicioWakeDevice.state,
        openWakeWordDevice.state
    ) { device, heyDicioState, owwState ->
        when (device) {
            WakeDevice.WAKE_DEVICE_HEY_DICIO -> heyDicioState
            WakeDevice.WAKE_DEVICE_OPEN_WAKE_WORD -> owwState
            else -> WakeState.NotLoaded
        }
    }.stateIn(
        scope = scope,
        started = SharingStarted.Eagerly,
        initialValue = WakeState.NotLoaded
    )
    
    private fun getCurrentDevice(): WakeDevice? {
        return when (currentWakeDevice.value) {
            WakeDevice.WAKE_DEVICE_HEY_DICIO -> heyDicioWakeDevice
            WakeDevice.WAKE_DEVICE_OPEN_WAKE_WORD -> openWakeWordDevice
            else -> null
        }
    }
    
    override fun tryLoad() {
        getCurrentDevice()?.tryLoad()
    }
    
    override fun startListening(eventListener: (WakeEvent) -> Unit) {
        getCurrentDevice()?.startListening(eventListener)
    }
    
    override fun stopListening() {
        getCurrentDevice()?.stopListening()
    }
    
    override fun reinitializeToReleaseResources() {
        heyDicioWakeDevice.reinitializeToReleaseResources()
        openWakeWordDevice.reinitializeToReleaseResources()
    }
}
```

### 3. 语音输出设备包装器

#### SpeechOutputDeviceWrapper
```kotlin
@Singleton
class SpeechOutputDeviceWrapper @Inject constructor(
    private val dataStore: DataStore<UserSettings>,
    private val androidTtsSpeechDevice: AndroidTtsSpeechDevice,
    private val toastSpeechDevice: ToastSpeechDevice,
    private val snackbarSpeechDevice: SnackbarSpeechDevice,
) : SpeechOutputDevice {
    
    private val currentOutputDevice: StateFlow<SpeechOutputDevice> = dataStore.data
        .map { it.speechOutputDevice }
        .distinctUntilChanged()
        .stateIn(
            scope = scope,
            started = SharingStarted.Eagerly,
            initialValue = SpeechOutputDevice.SPEECH_OUTPUT_DEVICE_ANDROID_TTS
        )
    
    private fun getCurrentDevice(): SpeechOutputDevice {
        return when (currentOutputDevice.value) {
            SpeechOutputDevice.SPEECH_OUTPUT_DEVICE_ANDROID_TTS -> androidTtsSpeechDevice
            SpeechOutputDevice.SPEECH_OUTPUT_DEVICE_TOAST -> toastSpeechDevice
            SpeechOutputDevice.SPEECH_OUTPUT_DEVICE_SNACKBAR -> snackbarSpeechDevice
            else -> androidTtsSpeechDevice
        }
    }
    
    override fun speak(speechOutput: String) {
        getCurrentDevice().speak(speechOutput)
    }
    
    override fun stopSpeaking() {
        getCurrentDevice().stopSpeaking()
    }
    
    override fun cleanup() {
        androidTtsSpeechDevice.cleanup()
        toastSpeechDevice.cleanup()
        snackbarSpeechDevice.cleanup()
    }
    
    override fun runWhenFinishedSpeaking(runnable: Runnable) {
        getCurrentDevice().runWhenFinishedSpeaking(runnable)
    }
}
```

## ViewModel 依赖注入

### 1. Hilt ViewModel

#### HomeScreenViewModel
```kotlin
@HiltViewModel
class HomeScreenViewModel @Inject constructor(
    val skillHandler: SkillHandler,
    val skillEvaluator: SkillEvaluator,
    val sttInputDevice: SttInputDeviceWrapper,
    val wakeDevice: WakeDeviceWrapper
) : ViewModel() {
    
    // ViewModel 逻辑
}
```

#### MainSettingsViewModel
```kotlin
@HiltViewModel
class MainSettingsViewModel @Inject constructor(
    application: Application,
    private val dataStore: DataStore<UserSettings>,
    private val wakeDeviceWrapper: WakeDeviceWrapper?
) : AndroidViewModel(application) {
    
    // 设置管理逻辑
}
```

#### SkillSettingsViewModel
```kotlin
@HiltViewModel
class SkillSettingsViewModel @Inject constructor(
    private val dataStore: DataStore<UserSettings>,
    private val skillHandler: SkillHandler,
) : ViewModel() {
    
    // 技能设置逻辑
}
```

## 服务依赖注入

### 1. Android 服务

#### SttService
```kotlin
@AndroidEntryPoint
class SttService : RecognitionService() {
    
    @Inject lateinit var sttInputDevice: SttInputDeviceWrapper
    @Inject lateinit var localeManager: LocaleManager
    
    // STT 服务实现
}
```

#### WakeService
```kotlin
@AndroidEntryPoint
class WakeService : Service() {
    
    @Inject lateinit var wakeDevice: WakeDeviceWrapper
    @Inject lateinit var skillEvaluator: SkillEvaluator
    
    // 唤醒服务实现
}
```

## 工具类依赖注入

### 1. Activity 结果管理

#### ActivityForResultManager
- **文件**: `app/src/main/kotlin/org/stypox/dicio/di/ActivityForResultManager.kt`
- **功能**: 统一的 Activity 结果处理

```kotlin
@Singleton
class ActivityForResultManager @Inject constructor() {
    
    private var currentLauncher: ActivityResultLauncher<Intent>? = null
    
    fun setLauncher(launcher: ActivityResultLauncher<Intent>) {
        currentLauncher = launcher
    }
    
    fun launch(intent: Intent) {
        currentLauncher?.launch(intent)
    }
}
```

### 2. 技能上下文

#### SkillContextInternal
```kotlin
@Singleton
class SkillContextInternal @Inject constructor(
    override val android: Context,
    private val localeManager: LocaleManager,
    private val speechOutputDevice: SpeechOutputDeviceWrapper,
) : SkillContext {
    
    override val sentencesLanguage: String
        get() = LocaleUtils.localeToLanguage(localeManager.locale.value)
    
    override val parserFormatter: ParserFormatter?
        get() = ParserFormatterUtils.getParserFormatter(
            android, 
            localeManager.locale.value
        )
    
    override fun getSpeechOutputDevice(): SpeechOutputDevice {
        return speechOutputDevice
    }
}
```

## 作用域管理

### 1. Singleton 作用域
- **用途**: 全局单例，应用生命周期
- **示例**: DataStore, LocaleManager, SkillHandler

### 2. Activity 作用域
- **用途**: Activity 生命周期
- **示例**: ActivityForResultManager

### 3. ViewModel 作用域
- **用途**: ViewModel 生命周期
- **示例**: UI 状态管理

## 测试支持

### 1. 测试模块

#### TestModule
```kotlin
@Module
@TestInstallIn(
    components = [SingletonComponent::class],
    replaces = [IoModule::class]
)
class TestIoModule {
    
    @Provides
    @Singleton
    fun provideTestSttInputDevice(): SttInputDevice {
        return TestSttInputDevice()
    }
    
    @Provides
    @Singleton
    fun provideTestSpeechOutputDevice(): SpeechOutputDevice {
        return TestSpeechOutputDevice()
    }
}
```

### 2. Mock 依赖
```kotlin
class TestSttInputDevice : SttInputDevice {
    override val uiState = MutableStateFlow(SttState.Available)
    
    override fun tryLoad(thenStartListeningEventListener: ((InputEvent) -> Unit)?) {
        // 测试实现
    }
    
    override fun startListening(eventListener: (InputEvent) -> Unit) {
        // 模拟语音输入
        eventListener(InputEvent.Final(listOf("test input" to 1.0f)))
    }
    
    override fun stopListening() {
        // 测试实现
    }
    
    override fun reinitializeToReleaseResources() {
        // 测试实现
    }
}
```

## 性能优化

### 1. 懒加载
```kotlin
@Module
@InstallIn(SingletonComponent::class)
class LazyModule {
    
    @Provides
    @Singleton
    fun provideExpensiveResource(): Lazy<ExpensiveResource> {
        return lazy { ExpensiveResource() }
    }
}
```

### 2. 条件注入
```kotlin
@Module
@InstallIn(SingletonComponent::class)
class ConditionalModule {
    
    @Provides
    @Singleton
    fun provideWakeDevice(
        @ApplicationContext context: Context
    ): WakeDevice? {
        return if (hasWakeWordSupport(context)) {
            OpenWakeWordDevice(context)
        } else {
            null
        }
    }
}
```

### 3. 资源管理
```kotlin
@Singleton
class ResourceManager @Inject constructor() {
    
    private val resources = mutableMapOf<String, Any>()
    
    fun <T> getOrCreate(key: String, factory: () -> T): T {
        @Suppress("UNCHECKED_CAST")
        return resources.getOrPut(key) { factory() } as T
    }
    
    fun release(key: String) {
        resources.remove(key)?.let { resource ->
            if (resource is Closeable) {
                resource.close()
            }
        }
    }
}
```

## 最佳实践

### 1. 模块设计原则
- **单一职责**: 每个模块专注特定功能域
- **依赖最小化**: 减少模块间依赖
- **接口抽象**: 依赖接口而非实现

### 2. 生命周期管理
- **合适的作用域**: 选择正确的组件作用域
- **资源清理**: 及时释放不需要的资源
- **内存泄漏防护**: 避免持有长生命周期引用

### 3. 测试友好
- **接口注入**: 便于 Mock 和测试
- **测试模块**: 提供测试专用实现
- **依赖隔离**: 便于单元测试

通过 Dagger Hilt 的依赖注入系统，Dicio 实现了清晰的模块化架构，提高了代码的可维护性、可测试性和可扩展性。

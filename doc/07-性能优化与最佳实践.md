# Dicio 性能优化与最佳实践

## 性能优化概述

Dicio 作为语音助手应用，对性能有着极高的要求。系统需要在保证快速响应的同时，合理管理内存、电池和网络资源。本文档详细介绍了 Dicio 在各个层面的性能优化策略和最佳实践。

## 应用启动优化

### 1. 启动时间优化

#### 冷启动优化
```kotlin
@HiltAndroidApp
class App : Application() {
    override fun onCreate() {
        super.onCreate()
        
        // 异步初始化非关键组件
        GlobalScope.launch(Dispatchers.Default) {
            initializeNonCriticalComponents()
        }
        
        // 预加载关键资源
        preloadCriticalResources()
    }
    
    private suspend fun initializeNonCriticalComponents() {
        // 延迟初始化语音模型
        // 预热网络连接
        // 初始化分析工具
    }
    
    private fun preloadCriticalResources() {
        // 预加载主题资源
        // 初始化关键服务
    }
}
```

#### MainActivity 优化
```kotlin
@AndroidEntryPoint
class MainActivity : BaseActivity() {
    
    override fun onCreate(savedInstanceState: Bundle?) {
        // 启用边缘到边缘显示，减少布局层次
        enableEdgeToEdge()
        
        super.onCreate(savedInstanceState)
        
        // 异步处理非关键初始化
        lifecycleScope.launch {
            initializeAsyncComponents()
        }
        
        // 立即设置 UI，避免白屏
        composeSetContent {
            AppTheme {
                Navigation()
            }
        }
    }
    
    private suspend fun initializeAsyncComponents() {
        // 权限检查
        // 设备初始化
        // 后台服务启动
    }
}
```

### 2. 资源预加载

#### 关键资源预加载
```kotlin
class ResourcePreloader @Inject constructor(
    @ApplicationContext private val context: Context
) {
    
    fun preloadCriticalResources() {
        // 预加载字体
        preloadFonts()
        
        // 预加载图标
        preloadIcons()
        
        // 预加载音频资源
        preloadAudioResources()
    }
    
    private fun preloadFonts() {
        val typeface = ResourcesCompat.getFont(context, R.font.roboto)
        // 缓存字体资源
    }
    
    private fun preloadIcons() {
        val icons = listOf(
            R.drawable.ic_mic,
            R.drawable.ic_settings,
            R.drawable.ic_skills
        )
        icons.forEach { iconRes ->
            ContextCompat.getDrawable(context, iconRes)
        }
    }
}
```

## 内存优化

### 1. 内存泄漏防护

#### ViewModel 内存管理
```kotlin
@HiltViewModel
class HomeScreenViewModel @Inject constructor(
    private val skillEvaluator: SkillEvaluator,
    private val sttInputDevice: SttInputDeviceWrapper
) : ViewModel() {
    
    private val _uiState = MutableStateFlow(HomeUiState())
    val uiState: StateFlow<HomeUiState> = _uiState.asStateFlow()
    
    // 使用 WeakReference 避免内存泄漏
    private var activityRef: WeakReference<Activity>? = null
    
    fun setActivity(activity: Activity) {
        activityRef = WeakReference(activity)
    }
    
    override fun onCleared() {
        super.onCleared()
        // 清理资源
        activityRef?.clear()
        // 取消协程
        // 释放监听器
    }
}
```

#### 语音设备内存管理
```kotlin
class VoskInputDevice {
    
    private var speechService: SpeechService? = null
    private var model: Model? = null
    
    override fun reinitializeToReleaseResources() {
        // 释放语音服务
        speechService?.stop()
        speechService?.shutdown()
        speechService = null
        
        // 释放模型资源
        model?.close()
        model = null
        
        // 强制垃圾回收
        System.gc()
    }
    
    fun loadModel(): Model? {
        return try {
            // 检查内存是否足够
            if (isMemoryAvailable()) {
                Model(modelDirectory.absolutePath)
            } else {
                Log.w(TAG, "Insufficient memory for model loading")
                null
            }
        } catch (e: OutOfMemoryError) {
            Log.e(TAG, "Out of memory loading model", e)
            null
        }
    }
    
    private fun isMemoryAvailable(): Boolean {
        val runtime = Runtime.getRuntime()
        val maxMemory = runtime.maxMemory()
        val usedMemory = runtime.totalMemory() - runtime.freeMemory()
        val availableMemory = maxMemory - usedMemory
        
        return availableMemory > MODEL_MEMORY_REQUIREMENT
    }
}
```

### 2. 对象池和缓存

#### 音频缓冲区对象池
```kotlin
class AudioBufferPool {
    private val pool = ArrayDeque<FloatArray>()
    private val maxPoolSize = 10
    
    fun acquire(size: Int): FloatArray {
        return pool.pollFirst()?.takeIf { it.size == size } 
            ?: FloatArray(size)
    }
    
    fun release(buffer: FloatArray) {
        if (pool.size < maxPoolSize) {
            buffer.fill(0f) // 清理数据
            pool.offerLast(buffer)
        }
    }
}
```

#### 技能结果缓存
```kotlin
class SkillResultCache @Inject constructor() {
    
    private val cache = LruCache<String, SkillOutput>(50)
    
    fun get(input: String): SkillOutput? {
        return cache.get(input.hashCode().toString())
    }
    
    fun put(input: String, output: SkillOutput) {
        cache.put(input.hashCode().toString(), output)
    }
    
    fun clear() {
        cache.evictAll()
    }
}
```

## UI 性能优化

### 1. Compose 性能优化

#### 重组优化
```kotlin
@Composable
fun HomeScreen(
    uiState: HomeUiState,
    onEvent: (HomeEvent) -> Unit
) {
    // 使用 remember 避免重复计算
    val interactions = remember(uiState.interactions) {
        uiState.interactions.takeLast(50) // 限制显示数量
    }
    
    // 使用 derivedStateOf 优化派生状态
    val hasError by remember {
        derivedStateOf { uiState.error != null }
    }
    
    LazyColumn(
        // 使用 key 优化列表性能
        key = { interaction -> interaction.id }
    ) {
        items(interactions) { interaction ->
            InteractionItem(
                interaction = interaction,
                // 使用稳定的参数避免重组
                modifier = Modifier.fillMaxWidth()
            )
        }
    }
}

// 使用 @Stable 注解标记稳定类
@Stable
data class HomeUiState(
    val isListening: Boolean = false,
    val interactions: List<Interaction> = emptyList(),
    val error: String? = null
)
```

#### 列表性能优化
```kotlin
@Composable
fun InteractionList(
    interactions: List<Interaction>,
    modifier: Modifier = Modifier
) {
    LazyColumn(
        modifier = modifier,
        // 设置合适的内容填充
        contentPadding = PaddingValues(16.dp),
        // 优化滚动性能
        flingBehavior = rememberAsyncFlingBehavior()
    ) {
        items(
            items = interactions,
            key = { it.id }, // 使用稳定的 key
            contentType = { it.type } // 指定内容类型
        ) { interaction ->
            InteractionItem(
                interaction = interaction,
                modifier = Modifier
                    .fillMaxWidth()
                    .animateItemPlacement() // 添加动画
            )
        }
    }
}
```

### 2. 图片和资源优化

#### 图片加载优化
```kotlin
@Composable
fun SkillIcon(
    skillInfo: SkillInfo,
    modifier: Modifier = Modifier
) {
    // 使用 Coil 进行图片加载优化
    AsyncImage(
        model = ImageRequest.Builder(LocalContext.current)
            .data(skillInfo.iconUrl)
            .memoryCachePolicy(CachePolicy.ENABLED)
            .diskCachePolicy(CachePolicy.ENABLED)
            .build(),
        contentDescription = skillInfo.name,
        modifier = modifier,
        // 设置占位符和错误图片
        placeholder = painterResource(R.drawable.ic_skill_placeholder),
        error = painterResource(R.drawable.ic_skill_error)
    )
}
```

#### 矢量图标优化
```kotlin
@Composable
fun OptimizedIcon(
    @DrawableRes iconRes: Int,
    contentDescription: String?,
    modifier: Modifier = Modifier,
    tint: Color = LocalContentColor.current
) {
    // 缓存矢量图标
    val painter = remember(iconRes) {
        painterResource(iconRes)
    }
    
    Icon(
        painter = painter,
        contentDescription = contentDescription,
        modifier = modifier,
        tint = tint
    )
}
```

## 语音处理性能优化

### 1. 音频处理优化

#### 实时音频处理
```kotlin
class OptimizedAudioProcessor {
    
    private val audioBufferPool = AudioBufferPool()
    private val processingExecutor = Executors.newSingleThreadExecutor()
    
    fun processAudioStream(audioData: ByteArray) {
        processingExecutor.execute {
            val floatBuffer = audioBufferPool.acquire(audioData.size / 2)
            
            try {
                // 优化的音频转换
                convertToFloat(audioData, floatBuffer)
                
                // 并行处理音频特征
                val features = extractFeaturesParallel(floatBuffer)
                
                // 处理结果
                processFeatures(features)
                
            } finally {
                audioBufferPool.release(floatBuffer)
            }
        }
    }
    
    private fun convertToFloat(input: ByteArray, output: FloatArray) {
        // 使用 SIMD 优化的转换算法
        for (i in output.indices) {
            val sample = (input[i * 2].toInt() and 0xFF) or 
                        (input[i * 2 + 1].toInt() shl 8)
            output[i] = sample / 32768.0f
        }
    }
    
    private fun extractFeaturesParallel(audioBuffer: FloatArray): AudioFeatures {
        return runBlocking {
            val mfccDeferred = async { extractMFCC(audioBuffer) }
            val energyDeferred = async { extractEnergy(audioBuffer) }
            val pitchDeferred = async { extractPitch(audioBuffer) }
            
            AudioFeatures(
                mfcc = mfccDeferred.await(),
                energy = energyDeferred.await(),
                pitch = pitchDeferred.await()
            )
        }
    }
}
```

#### 语音识别优化
```kotlin
class OptimizedVoskRecognizer {
    
    private val recognitionQueue = Channel<AudioChunk>(capacity = 100)
    private val resultCache = LruCache<String, RecognitionResult>(100)
    
    init {
        // 启动识别协程
        GlobalScope.launch {
            processRecognitionQueue()
        }
    }
    
    private suspend fun processRecognitionQueue() {
        for (audioChunk in recognitionQueue) {
            // 检查缓存
            val cacheKey = audioChunk.hash()
            val cachedResult = resultCache.get(cacheKey)
            
            if (cachedResult != null) {
                emitResult(cachedResult)
                continue
            }
            
            // 执行识别
            val result = performRecognition(audioChunk)
            
            // 缓存结果
            resultCache.put(cacheKey, result)
            
            emitResult(result)
        }
    }
    
    fun submitAudio(audioChunk: AudioChunk) {
        // 非阻塞提交
        recognitionQueue.trySend(audioChunk)
    }
}
```

### 2. 模型加载优化

#### 懒加载和预加载策略
```kotlin
class ModelManager @Inject constructor(
    @ApplicationContext private val context: Context
) {
    
    private val modelCache = mutableMapOf<String, Model>()
    private val loadingJobs = mutableMapOf<String, Job>()
    
    suspend fun getModel(language: String): Model? {
        // 检查缓存
        modelCache[language]?.let { return it }
        
        // 检查是否正在加载
        loadingJobs[language]?.let { job ->
            job.join()
            return modelCache[language]
        }
        
        // 开始加载
        val job = GlobalScope.launch {
            loadModel(language)
        }
        loadingJobs[language] = job
        
        job.join()
        loadingJobs.remove(language)
        
        return modelCache[language]
    }
    
    private suspend fun loadModel(language: String) {
        try {
            val modelPath = getModelPath(language)
            if (File(modelPath).exists()) {
                val model = withContext(Dispatchers.IO) {
                    Model(modelPath)
                }
                modelCache[language] = model
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to load model for $language", e)
        }
    }
    
    fun preloadModels(languages: List<String>) {
        languages.forEach { language ->
            GlobalScope.launch {
                getModel(language)
            }
        }
    }
    
    fun releaseModel(language: String) {
        modelCache.remove(language)?.close()
    }
}
```

## 网络和数据优化

### 1. 网络请求优化

#### HTTP 客户端优化
```kotlin
@Module
@InstallIn(SingletonComponent::class)
class NetworkModule {
    
    @Provides
    @Singleton
    fun provideOptimizedOkHttpClient(): OkHttpClient {
        return OkHttpClient.Builder()
            // 连接池优化
            .connectionPool(ConnectionPool(10, 5, TimeUnit.MINUTES))
            // 超时设置
            .connectTimeout(10, TimeUnit.SECONDS)
            .readTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            // 启用 HTTP/2
            .protocols(listOf(Protocol.HTTP_2, Protocol.HTTP_1_1))
            // 添加缓存
            .cache(Cache(File(context.cacheDir, "http_cache"), 50L * 1024 * 1024))
            // 添加拦截器
            .addInterceptor(CacheInterceptor())
            .addInterceptor(RetryInterceptor())
            .build()
    }
}

class CacheInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {
        val request = chain.request()
        
        // 添加缓存控制
        val cacheRequest = request.newBuilder()
            .header("Cache-Control", "public, max-age=300")
            .build()
        
        return chain.proceed(cacheRequest)
    }
}
```

#### 请求去重和合并
```kotlin
class RequestDeduplicator {
    
    private val pendingRequests = mutableMapOf<String, Deferred<String>>()
    
    suspend fun request(url: String): String {
        // 检查是否有相同的请求正在进行
        pendingRequests[url]?.let { deferred ->
            return deferred.await()
        }
        
        // 创建新请求
        val deferred = GlobalScope.async {
            performRequest(url)
        }
        
        pendingRequests[url] = deferred
        
        try {
            return deferred.await()
        } finally {
            pendingRequests.remove(url)
        }
    }
    
    private suspend fun performRequest(url: String): String {
        // 实际网络请求
        return withContext(Dispatchers.IO) {
            // HTTP 请求实现
            ""
        }
    }
}
```

### 2. 数据存储优化

#### DataStore 优化
```kotlin
class OptimizedDataStore @Inject constructor(
    private val dataStore: DataStore<UserSettings>
) {
    
    // 批量更新减少 I/O
    suspend fun batchUpdate(updates: List<(UserSettings.Builder) -> Unit>) {
        dataStore.updateData { currentSettings ->
            val builder = currentSettings.toBuilder()
            updates.forEach { update ->
                update(builder)
            }
            builder.build()
        }
    }
    
    // 缓存频繁访问的数据
    private val settingsCache = dataStore.data
        .stateIn(
            scope = GlobalScope,
            started = SharingStarted.Eagerly,
            initialValue = UserSettings.getDefaultInstance()
        )
    
    fun getCachedSettings(): UserSettings {
        return settingsCache.value
    }
}
```

## 电池优化

### 1. 后台任务优化

#### 智能唤醒服务
```kotlin
class OptimizedWakeService : Service() {
    
    private var isOptimizedMode = false
    private val batteryManager by lazy { 
        getSystemService(Context.BATTERY_SERVICE) as BatteryManager 
    }
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // 根据电池状态调整性能
        adjustPerformanceBasedOnBattery()
        
        // 启动前台服务
        startForeground(NOTIFICATION_ID, createOptimizedNotification())
        
        return START_STICKY
    }
    
    private fun adjustPerformanceBasedOnBattery() {
        val batteryLevel = batteryManager.getIntProperty(
            BatteryManager.BATTERY_PROPERTY_CAPACITY
        )
        
        isOptimizedMode = batteryLevel < 20
        
        if (isOptimizedMode) {
            // 降低采样率
            // 减少处理频率
            // 简化算法
        }
    }
    
    private fun createOptimizedNotification(): Notification {
        return NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle(getString(R.string.wake_service_title))
            .setContentText(
                if (isOptimizedMode) 
                    getString(R.string.wake_service_battery_optimized)
                else 
                    getString(R.string.wake_service_normal)
            )
            .setSmallIcon(R.drawable.ic_mic)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setShowWhen(false)
            .build()
    }
}
```

### 2. CPU 使用优化

#### 自适应处理频率
```kotlin
class AdaptiveProcessor {
    
    private var processingInterval = 100L // 默认 100ms
    private val cpuUsageMonitor = CpuUsageMonitor()
    
    fun startProcessing() {
        GlobalScope.launch {
            while (isActive) {
                val startTime = System.currentTimeMillis()
                
                // 执行处理
                processAudioFrame()
                
                // 监控 CPU 使用率
                val cpuUsage = cpuUsageMonitor.getCurrentUsage()
                
                // 自适应调整间隔
                adjustProcessingInterval(cpuUsage)
                
                val processingTime = System.currentTimeMillis() - startTime
                val sleepTime = maxOf(0, processingInterval - processingTime)
                
                delay(sleepTime)
            }
        }
    }
    
    private fun adjustProcessingInterval(cpuUsage: Float) {
        when {
            cpuUsage > 80f -> processingInterval = minOf(processingInterval * 1.2, 500).toLong()
            cpuUsage < 30f -> processingInterval = maxOf(processingInterval * 0.8, 50).toLong()
        }
    }
}
```

## 测试和监控

### 1. 性能测试

#### 基准测试
```kotlin
@RunWith(AndroidJUnit4::class)
class PerformanceBenchmark {
    
    @get:Rule
    val benchmarkRule = BenchmarkRule()
    
    @Test
    fun benchmarkSkillEvaluation() {
        val skillEvaluator = createSkillEvaluator()
        val testInput = "what's the weather like"
        
        benchmarkRule.measureRepeated {
            skillEvaluator.evaluateSkills(testInput)
        }
    }
    
    @Test
    fun benchmarkAudioProcessing() {
        val processor = AudioProcessor()
        val audioData = generateTestAudio()
        
        benchmarkRule.measureRepeated {
            processor.processAudio(audioData)
        }
    }
}
```

#### 内存泄漏检测
```kotlin
@RunWith(AndroidJUnit4::class)
class MemoryLeakTest {
    
    @get:Rule
    val leakCanaryRule = DetectLeaksAfterTestSuccess()
    
    @Test
    fun testHomeScreenMemoryLeak() {
        val scenario = ActivityScenario.launch(MainActivity::class.java)
        
        // 执行操作
        onView(withId(R.id.mic_button)).perform(click())
        
        // 旋转屏幕测试
        scenario.onActivity { activity ->
            activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE
        }
        
        scenario.close()
        
        // LeakCanary 会自动检测泄漏
    }
}
```

### 2. 性能监控

#### 实时性能监控
```kotlin
class PerformanceMonitor @Inject constructor() {
    
    private val metrics = mutableMapOf<String, Long>()
    
    fun startTiming(operation: String) {
        metrics[operation] = System.currentTimeMillis()
    }
    
    fun endTiming(operation: String) {
        val startTime = metrics.remove(operation) ?: return
        val duration = System.currentTimeMillis() - startTime
        
        Log.d(TAG, "$operation took ${duration}ms")
        
        // 发送到分析服务
        if (duration > getThreshold(operation)) {
            reportSlowOperation(operation, duration)
        }
    }
    
    inline fun <T> measureTime(operation: String, block: () -> T): T {
        startTiming(operation)
        return try {
            block()
        } finally {
            endTiming(operation)
        }
    }
    
    private fun getThreshold(operation: String): Long {
        return when (operation) {
            "skill_evaluation" -> 500L
            "audio_processing" -> 100L
            "ui_render" -> 16L // 60fps
            else -> 1000L
        }
    }
}
```

## 最佳实践总结

### 1. 代码层面
- **异步优先**: 所有耗时操作使用协程
- **资源管理**: 及时释放不需要的资源
- **缓存策略**: 合理使用内存和磁盘缓存
- **对象复用**: 使用对象池减少 GC 压力

### 2. 架构层面
- **模块化设计**: 按需加载模块
- **接口抽象**: 便于性能优化和替换
- **状态管理**: 使用响应式状态管理
- **依赖注入**: 合理管理对象生命周期

### 3. 用户体验
- **快速启动**: 优化冷启动时间
- **流畅交互**: 保持 60fps 的 UI 性能
- **电池友好**: 智能调整功耗
- **内存效率**: 避免内存泄漏和 OOM

### 4. 监控和测试
- **性能基准**: 建立性能基准测试
- **持续监控**: 实时监控关键指标
- **自动化测试**: 集成性能测试到 CI/CD
- **用户反馈**: 收集真实使用场景的性能数据

通过这些性能优化策略和最佳实践，Dicio 能够在各种设备上提供流畅、高效的语音助手体验。

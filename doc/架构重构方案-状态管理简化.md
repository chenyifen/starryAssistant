# è¯­éŸ³åŠ©æ‰‹æ¶æ„é‡æ„æ–¹æ¡ˆ - çŠ¶æ€ç®¡ç†ç®€åŒ–

> ç‰ˆæœ¬: 2.0  
> æ—¥æœŸ: 2025-10-14  
> ç›®æ ‡: ç®€åŒ–çŠ¶æ€ç®¡ç†ï¼Œæ”¯æŒéšæ—¶æ‰“æ–­

## ğŸ¯ æ ¸å¿ƒé—®é¢˜åˆ†æ

### é—®é¢˜1: çŠ¶æ€é‡å¤

**å½“å‰æ¶æ„**ï¼š
```kotlin
// ä¸¤å¥—çŠ¶æ€ç³»ç»Ÿ
VoiceAssistantUIState: IDLE, WAKE_DETECTED, LISTENING, PROCESSING, SPEAKING, ERROR
SttState: NotInitialized, NotLoaded, Loading, Loaded, Listening, ...
```

**é—®é¢˜**ï¼š
- çŠ¶æ€æ˜ å°„å¤æ‚ï¼š`SttState.Listening` â†’ `VoiceAssistantUIState.LISTENING`
- çŠ¶æ€ä¸ä¸€è‡´é£é™©ï¼šä¸¤ä¸ªçŠ¶æ€å¯èƒ½ä¸åŒæ­¥
- ä»£ç å†—ä½™ï¼šStateCoordinator åªåšçŠ¶æ€è½¬æ¢

### é—®é¢˜2: StateCoordinator å¿…è¦æ€§

**å½“å‰èŒè´£**ï¼š
```kotlin
class VoiceAssistantStateCoordinator {
    // ç›‘å¬ SttState
    // è½¬æ¢ä¸º VoiceAssistantUIState
    // é€šçŸ¥ UI å±‚
}
```

**åˆ†æ**ï¼š
- âœ… è§£è€¦ï¼šUI å±‚ä¸ç›´æ¥ä¾èµ– STT å®ç°
- âŒ è¿‡åº¦è®¾è®¡ï¼šåªæ˜¯ç®€å•çš„çŠ¶æ€æ˜ å°„
- âŒ ä¸­é—´å±‚ï¼šå¢åŠ å¤æ‚åº¦ï¼Œéš¾ä»¥è°ƒè¯•

**ç»“è®º**: âš ï¸ å¯ä»¥ç®€åŒ–ï¼Œä½†ä¿ç•™éƒ¨åˆ†èŒè´£

### é—®é¢˜3: éšæ—¶æ‰“æ–­åŠŸèƒ½ç¼ºå¤±

**éœ€æ±‚**ï¼š
```
ç”¨æˆ·è¯´è¯ï¼ˆASRè¯†åˆ«ä¸­ï¼‰
    â†“
æ£€æµ‹åˆ°å”¤é†’è¯
    â†“
ä¸­æ–­å½“å‰è¯†åˆ«
    â†“
æ¸…ç©ºéŸ³é¢‘buffer
    â†“
é‡æ–°å¼€å§‹è¯†åˆ«
```

**å½“å‰é—®é¢˜**ï¼š
- WakeService å’Œ SenseVoiceInputDevice çš„ AudioRecord å†²çª
- æ²¡æœ‰ä¸­æ–­æœºåˆ¶
- æ²¡æœ‰ buffer æ¸…ç©ºé€»è¾‘

---

## ğŸ“Š å‚è€ƒï¼šVOSK çŠ¶æ€ç®¡ç†

### VOSK çš„ä¼˜ç§€è®¾è®¡

```kotlin
// å•ä¸€çŠ¶æ€æº
sealed interface VoskState {
    object NotDownloaded : VoskState
    data class Downloading(val progress: Progress) : VoskState
    object NotLoaded : VoskState
    data class Loading(val thenStartListening: Boolean) : VoskState
    object Loaded : VoskState
    object Listening : VoskState
    data class Error(val throwable: Throwable) : VoskState
}

// UI ç›´æ¥ä½¿ç”¨ VoskState
when (voskState) {
    is VoskState.Listening -> showListening()
    is VoskState.Loaded -> showReady()
    // ...
}
```

**ä¼˜ç‚¹**ï¼š
1. âœ… å•ä¸€çŠ¶æ€æºï¼ˆSingle Source of Truthï¼‰
2. âœ… çŠ¶æ€å®Œæ•´æè¿°äº†ç³»ç»Ÿçš„æ‰€æœ‰æƒ…å†µ
3. âœ… UI ç›´æ¥æ˜ å°„çŠ¶æ€ï¼Œæ— ä¸­é—´å±‚
4. âœ… æ˜“äºæµ‹è¯•å’Œè°ƒè¯•

---

## ğŸ—ï¸ é‡æ„æ–¹æ¡ˆ

### æ–¹æ¡ˆA: æ¿€è¿›é‡æ„ï¼ˆæ¨èï¼‰

#### 1. ç»Ÿä¸€çŠ¶æ€å®šä¹‰

```kotlin
/**
 * è¯­éŸ³åŠ©æ‰‹ç»Ÿä¸€çŠ¶æ€
 * å‚è€ƒ VOSK è®¾è®¡ï¼Œåˆå¹¶ SttState å’Œ VoiceAssistantUIState
 */
sealed interface VoiceAssistantState {
    
    // ========== åˆå§‹åŒ–é˜¶æ®µ ==========
    /** æœªåˆå§‹åŒ– */
    data object NotInitialized : VoiceAssistantState
    
    /** æ­£åœ¨åŠ è½½ */
    data class Loading(val progress: Float) : VoiceAssistantState
    
    /** åŠ è½½å¤±è´¥ */
    data class LoadingError(val error: Throwable) : VoiceAssistantState
    
    // ========== è¿è¡Œé˜¶æ®µ ==========
    /** ç©ºé—² - ç­‰å¾…å”¤é†’è¯ */
    data object Idle : VoiceAssistantState
    
    /** ç›‘å¬ä¸­ - æ­£åœ¨å½•éŸ³è¯†åˆ« */
    data class Listening(
        val startTime: Long,
        val partialText: String = ""
    ) : VoiceAssistantState
    
    /** å¤„ç†ä¸­ - æ‰§è¡ŒæŠ€èƒ½åŒ¹é… */
    data class Processing(
        val text: String
    ) : VoiceAssistantState
    
    /** æ’­æŠ¥ä¸­ - TTS æ’­æ”¾ */
    data class Speaking(
        val text: String
    ) : VoiceAssistantState
    
    // ========== ç‰¹æ®ŠçŠ¶æ€ ==========
    /** é”™è¯¯ */
    data class Error(
        val error: Throwable,
        val canRecover: Boolean = true
    ) : VoiceAssistantState
    
    /** è¢«ä¸­æ–­ - æ£€æµ‹åˆ°æ–°å”¤é†’è¯ */
    data object Interrupted : VoiceAssistantState
}
```

#### 2. ç®€åŒ–çš„ StateManager

```kotlin
/**
 * è¯­éŸ³åŠ©æ‰‹çŠ¶æ€ç®¡ç†å™¨
 * èŒè´£ï¼š
 * 1. ç»´æŠ¤ç»Ÿä¸€çš„çŠ¶æ€
 * 2. å¤„ç†çŠ¶æ€è½¬æ¢é€»è¾‘
 * 3. æä¾›çŠ¶æ€æŸ¥è¯¢æ¥å£
 * 
 * ä¸å†éœ€è¦ï¼š
 * - VoiceAssistantStateCoordinatorï¼ˆåˆ é™¤ï¼‰
 * - VoiceAssistantUIStateï¼ˆåˆ é™¤ï¼‰
 */
@Singleton
class VoiceAssistantStateManager @Inject constructor(
    private val sttInputDevice: SttInputDeviceWrapper,
    private val skillEvaluator: SkillEvaluator,
    private val ttsDevice: SpeechOutputDeviceWrapper
) {
    
    private val _state = MutableStateFlow<VoiceAssistantState>(VoiceAssistantState.NotInitialized)
    val state: StateFlow<VoiceAssistantState> = _state.asStateFlow()
    
    // ========== çŠ¶æ€è½¬æ¢æ–¹æ³• ==========
    
    fun onWakeWordDetected() {
        // å¦‚æœæ­£åœ¨è¯†åˆ«ï¼Œå…ˆä¸­æ–­
        if (_state.value is VoiceAssistantState.Listening) {
            interrupt()
        }
        
        // å¼€å§‹æ–°çš„è¯†åˆ«
        _state.value = VoiceAssistantState.Listening(
            startTime = System.currentTimeMillis()
        )
    }
    
    fun onPartialResult(text: String) {
        val current = _state.value
        if (current is VoiceAssistantState.Listening) {
            _state.value = current.copy(partialText = text)
        }
    }
    
    fun onFinalResult(text: String) {
        _state.value = VoiceAssistantState.Processing(text)
    }
    
    fun onTtsSpeaking(text: String) {
        _state.value = VoiceAssistantState.Speaking(text)
    }
    
    fun onTtsCompleted() {
        _state.value = VoiceAssistantState.Idle
    }
    
    // ========== ä¸­æ–­æœºåˆ¶ ==========
    
    fun interrupt() {
        Log.d(TAG, "ğŸ›‘ ä¸­æ–­å½“å‰çŠ¶æ€: ${_state.value}")
        
        when (val current = _state.value) {
            is VoiceAssistantState.Listening -> {
                // åœæ­¢ STT
                sttInputDevice.stopListening()
                // æ¸…ç©º bufferï¼ˆç”± SenseVoiceInputDevice å†…éƒ¨å¤„ç†ï¼‰
            }
            is VoiceAssistantState.Processing -> {
                // å–æ¶ˆæŠ€èƒ½å¤„ç†
                skillEvaluator.cancel()
            }
            is VoiceAssistantState.Speaking -> {
                // åœæ­¢ TTS
                ttsDevice.stopSpeaking()
            }
            else -> {
                // å…¶ä»–çŠ¶æ€ä¸éœ€è¦ä¸­æ–­
            }
        }
        
        _state.value = VoiceAssistantState.Interrupted
    }
    
    // ========== çŠ¶æ€æŸ¥è¯¢ ==========
    
    fun canStartListening(): Boolean {
        return _state.value is VoiceAssistantState.Idle ||
               _state.value is VoiceAssistantState.Interrupted
    }
    
    fun isActive(): Boolean {
        return _state.value !is VoiceAssistantState.Idle &&
               _state.value !is VoiceAssistantState.NotInitialized
    }
}
```

#### 3. UI ç›´æ¥ä½¿ç”¨çŠ¶æ€

```kotlin
// DraggableFloatingOrb.kt
@Composable
fun FloatingOrb(stateManager: VoiceAssistantStateManager) {
    val state by stateManager.state.collectAsState()
    
    when (state) {
        is VoiceAssistantState.Idle -> {
            // æ˜¾ç¤ºç©ºé—²åŠ¨ç”»
            LottieAnimation(animation = "idle.json")
        }
        
        is VoiceAssistantState.Listening -> {
            // æ˜¾ç¤ºç›‘å¬åŠ¨ç”» + å®æ—¶æ–‡æœ¬
            LottieAnimation(animation = "listening.json")
            Text(state.partialText)
        }
        
        is VoiceAssistantState.Processing -> {
            // æ˜¾ç¤ºå¤„ç†åŠ¨ç”»
            LottieAnimation(animation = "processing.json")
            Text(state.text)
        }
        
        is VoiceAssistantState.Speaking -> {
            // æ˜¾ç¤ºæ’­æŠ¥åŠ¨ç”» + TTSæ–‡æœ¬
            LottieAnimation(animation = "speaking.json")
            Text(state.text)
        }
        
        is VoiceAssistantState.Error -> {
            // æ˜¾ç¤ºé”™è¯¯
            ErrorView(state.error)
        }
        
        else -> {
            // Loading ç­‰çŠ¶æ€
        }
    }
}
```

#### 4. éšæ—¶æ‰“æ–­å®ç°

```kotlin
// WakeService.kt
private fun onWakeWordDetected() {
    Log.d(TAG, "ğŸ¯ æ£€æµ‹åˆ°å”¤é†’è¯")
    
    // é€šè¿‡ StateManager å¤„ç†ä¸­æ–­
    stateManager.interrupt()
    
    // çŸ­æš‚å»¶è¿Ÿåå¼€å§‹æ–°çš„è¯†åˆ«
    handler.postDelayed({
        stateManager.onWakeWordDetected()
        sttInputDevice.tryLoad(::handleInputEvent)
    }, 100)  // 100ms ç¼“å†²æ—¶é—´
}

// SenseVoiceInputDevice.kt
fun clearBufferAndRestart() {
    Log.d(TAG, "ğŸ§¹ æ¸…ç©ºbufferå¹¶é‡å¯")
    
    // æ¸…ç©ºéŸ³é¢‘buffer
    speechBuffer.clear()
    isSpeechDetected = false
    speechStartTime = 0L
    lastRecognitionTime = 0L
    
    // é‡ç½®è¯†åˆ«å™¨
    senseVoiceRecognizer?.reset()
    vad?.reset()
    
    // é‡æ–°å¼€å§‹å½•éŸ³
    isRecording.set(true)
}
```

---

### æ–¹æ¡ˆB: æ¸è¿›å¼é‡æ„ï¼ˆä¿å®ˆï¼‰

ä¿ç•™ç°æœ‰æ¶æ„ï¼Œåªåšå…³é”®æ”¹è¿›ï¼š

#### 1. å¢å¼º StateCoordinator

```kotlin
class VoiceAssistantStateCoordinator {
    
    // æ–°å¢ï¼šä¸­æ–­æ–¹æ³•
    fun interrupt() {
        when (_uiState.value) {
            VoiceAssistantUIState.LISTENING -> {
                sttInputDevice.stopListening()
                updateUIState(VoiceAssistantUIState.INTERRUPTED)
            }
            VoiceAssistantUIState.SPEAKING -> {
                speechOutputDevice.stopSpeaking()
                updateUIState(VoiceAssistantUIState.INTERRUPTED)
            }
            else -> {
                // æ— éœ€ä¸­æ–­
            }
        }
    }
    
    // æ–°å¢ï¼šä»ä¸­æ–­æ¢å¤
    fun resumeFromInterruption() {
        updateUIState(VoiceAssistantUIState.LISTENING)
    }
}

// æ–°å¢çŠ¶æ€
enum class VoiceAssistantUIState {
    IDLE,
    LISTENING,
    PROCESSING,
    SPEAKING,
    INTERRUPTED,  // æ–°å¢
    ERROR
}
```

#### 2. AudioRecord èµ„æºå…±äº«

```kotlin
// æ–°å¢ï¼šAudioRecord ç®¡ç†å™¨
object AudioRecordManager {
    private var currentOwner: String? = null
    private var currentRecord: AudioRecord? = null
    
    fun acquire(owner: String, config: AudioConfig): AudioRecord? {
        // å¦‚æœæœ‰å…¶ä»–ownerï¼Œå…ˆé‡Šæ”¾
        if (currentOwner != null && currentOwner != owner) {
            release(currentOwner!!)
        }
        
        currentRecord = AudioRecord(...)
        currentOwner = owner
        return currentRecord
    }
    
    fun release(owner: String) {
        if (currentOwner == owner) {
            currentRecord?.stop()
            currentRecord?.release()
            currentRecord = null
            currentOwner = null
        }
    }
}

// WakeService ä½¿ç”¨
val audioRecord = AudioRecordManager.acquire("WakeService", config)

// SenseVoiceInputDevice ä½¿ç”¨
val audioRecord = AudioRecordManager.acquire("SenseVoice", config)
```

---

## ğŸ“ˆ å¯¹æ¯”åˆ†æ

### æ–¹æ¡ˆå¯¹æ¯”

| ç‰¹æ€§ | æ–¹æ¡ˆAï¼ˆæ¿€è¿›ï¼‰ | æ–¹æ¡ˆBï¼ˆä¿å®ˆï¼‰ | å½“å‰æ¶æ„ |
|------|-------------|-------------|---------|
| çŠ¶æ€ç»Ÿä¸€æ€§ | âœ… å•ä¸€çŠ¶æ€ | âŒ åŒçŠ¶æ€ | âŒ åŒçŠ¶æ€ |
| ä»£ç å¤æ‚åº¦ | â­â­â­ | â­â­â­â­ | â­â­â­â­â­ |
| ä¸­æ–­æ”¯æŒ | âœ… å†…ç½® | âš ï¸ éœ€é¢å¤–å®ç° | âŒ æ—  |
| é‡æ„é£é™© | ğŸ”´ é«˜ | ğŸŸ¡ ä¸­ | ğŸŸ¢ ä½ |
| ç»´æŠ¤æˆæœ¬ | ğŸŸ¢ ä½ | ğŸŸ¡ ä¸­ | ğŸ”´ é«˜ |
| å‚è€ƒ VOSK | âœ… ç›¸ä¼¼ | âŒ ä¸åŒ | âŒ ä¸åŒ |

### è¿ç§»æˆæœ¬

**æ–¹æ¡ˆAï¼ˆæ¿€è¿›ï¼‰**ï¼š
- åˆ é™¤æ–‡ä»¶ï¼š2ä¸ªï¼ˆStateCoordinator, VoiceAssistantUIStateï¼‰
- ä¿®æ”¹æ–‡ä»¶ï¼šçº¦15ä¸ª
- æ–°å¢æ–‡ä»¶ï¼š1ä¸ªï¼ˆVoiceAssistantStateManagerï¼‰
- å·¥ä½œé‡ï¼š2-3å¤©

**æ–¹æ¡ˆBï¼ˆä¿å®ˆï¼‰**ï¼š
- åˆ é™¤æ–‡ä»¶ï¼š0ä¸ª
- ä¿®æ”¹æ–‡ä»¶ï¼šçº¦5ä¸ª
- æ–°å¢æ–‡ä»¶ï¼š1ä¸ªï¼ˆAudioRecordManagerï¼‰
- å·¥ä½œé‡ï¼š1å¤©

---

## ğŸ¯ æ¨èæ–¹æ¡ˆ

### çŸ­æœŸï¼ˆ1å‘¨å†…ï¼‰ï¼šæ–¹æ¡ˆB

**ç†ç”±**ï¼š
1. å¿«é€Ÿè§£å†³éšæ—¶æ‰“æ–­é—®é¢˜
2. é£é™©å¯æ§
3. ä¸å½±å“ç°æœ‰åŠŸèƒ½

**å®æ–½æ­¥éª¤**ï¼š
1. åˆ›å»º `AudioRecordManager`
2. åœ¨ `StateCoordinator` æ·»åŠ  `interrupt()`
3. åœ¨ `WakeService` æ£€æµ‹åˆ°å”¤é†’è¯æ—¶è°ƒç”¨ `interrupt()`
4. æµ‹è¯•ä¸­æ–­åŠŸèƒ½

### é•¿æœŸï¼ˆ1-2ä¸ªæœˆï¼‰ï¼šæ–¹æ¡ˆA

**ç†ç”±**ï¼š
1. æ¶æ„æ›´æ¸…æ™°
2. ç¬¦åˆ VOSK æœ€ä½³å®è·µ
3. æ˜“äºç»´æŠ¤å’Œæ‰©å±•

**å®æ–½æ­¥éª¤**ï¼š
1. åˆ›å»º `VoiceAssistantState` å®šä¹‰
2. å®ç° `VoiceAssistantStateManager`
3. é€æ­¥è¿ç§» UI ç»„ä»¶
4. åˆ é™¤æ—§çš„ StateCoordinator
5. å…¨é¢æµ‹è¯•

---

## ğŸ’¡ éšæ—¶æ‰“æ–­çš„å®Œæ•´å®ç°

### æ ¸å¿ƒæµç¨‹

```mermaid
sequenceDiagram
    participant User as ç”¨æˆ·
    participant Wake as WakeService
    participant STT as SenseVoice
    participant State as StateManager
    
    User->>Wake: è¯´è¯ï¼ˆæ­£åœ¨è¯†åˆ«ï¼‰
    Wake->>Wake: æ£€æµ‹åˆ°å”¤é†’è¯
    Wake->>State: interrupt()
    
    State->>STT: stopListening()
    STT->>STT: æ¸…ç©ºbuffer
    STT-->>State: å·²åœæ­¢
    
    State->>Wake: ä¸­æ–­å®Œæˆ
    Wake->>STT: tryLoad()
    STT->>STT: é‡æ–°å¼€å§‹å½•éŸ³
    STT-->>State: Listening
```

### å…³é”®ä»£ç 

#### 1. WakeService æ£€æµ‹é€»è¾‘

```kotlin
private fun processAudioFrame(audio: ShortArray) {
    // æ£€æµ‹å”¤é†’è¯
    val wakeWordDetected = wakeDevice.processFrame(audio)
    
    if (wakeWordDetected) {
        // æ£€æŸ¥æ˜¯å¦åœ¨backoffæœŸé—´
        val now = Instant.now()
        if (now > nextWakeWordAllowed) {
            nextWakeWordAllowed = now.plusMillis(WAKE_WORD_BACKOFF_MILLIS)
            
            // âœ… å…³é”®ï¼šæ— è®ºå½“å‰çŠ¶æ€ï¼Œéƒ½æ‰§è¡Œä¸­æ–­
            onWakeWordDetected()
        }
    }
}

private fun onWakeWordDetected() {
    Log.d(TAG, "ğŸ¯ å”¤é†’è¯æ£€æµ‹åˆ°")
    
    // 1. ä¸­æ–­å½“å‰æ‰€æœ‰æ´»åŠ¨
    stateManager.interrupt()
    
    // 2. çŸ­æš‚å»¶è¿Ÿåé‡æ–°å¼€å§‹
    handler.postDelayed({
        // é€šçŸ¥çŠ¶æ€ç®¡ç†å™¨
        stateManager.onWakeWordDetected()
        
        // å¯åŠ¨STT
        val started = sttInputDevice.tryLoad(::handleInputEvent)
        if (started) {
            Log.d(TAG, "âœ… STTé‡æ–°å¯åŠ¨æˆåŠŸ")
        } else {
            Log.e(TAG, "âŒ STTé‡æ–°å¯åŠ¨å¤±è´¥")
        }
    }, 100)  // 100msç¼“å†²
}
```

#### 2. SenseVoiceInputDevice ä¸­æ–­å¤„ç†

```kotlin
/**
 * è¢«å¤–éƒ¨ä¸­æ–­æ—¶è°ƒç”¨
 * æ¸…ç©ºæ‰€æœ‰çŠ¶æ€ï¼Œå‡†å¤‡é‡æ–°å¼€å§‹
 */
fun onInterrupted() {
    Log.d(TAG, "âš¡ æ”¶åˆ°ä¸­æ–­ä¿¡å·")
    
    // åœæ­¢å½“å‰å½•éŸ³
    stopListening()
    
    // ç­‰å¾…åç¨‹ç»“æŸ
    // ç”±äº stopListening() å·²è®¾ç½® isRecording = false
    // åç¨‹ä¼šè‡ªç„¶ç»“æŸ
}

/**
 * é‡ç½®æ‰€æœ‰çŠ¶æ€ï¼ˆå†…éƒ¨æ–¹æ³•å¢å¼ºï¼‰
 */
private fun resetRecordingState() {
    speechBuffer.clear()
    isSpeechDetected = false
    speechStartTime = 0L
    lastRecognitionTime = 0L
    lastSpeechTime = 0L
    lastEnergyLogTime = 0L
    lastText = ""
    added = false
    vad?.reset()
    
    // é‡æ–°åˆ›å»ºChannel
    samplesChannel.close()
    samplesChannel = Channel(capacity = Channel.UNLIMITED)
    
    Log.d(TAG, "ğŸ”„ çŠ¶æ€å·²å®Œå…¨é‡ç½®")
}
```

#### 3. AudioRecord èµ„æºç®¡ç†

```kotlin
/**
 * å…¨å±€ AudioRecord ç®¡ç†å™¨
 * ç¡®ä¿åŒä¸€æ—¶é—´åªæœ‰ä¸€ä¸ª AudioRecord å®ä¾‹
 */
object AudioRecordManager {
    private const val TAG = "AudioRecordManager"
    private var currentOwner: String? = null
    private var currentRecord: AudioRecord? = null
    
    /**
     * è·å– AudioRecord
     * å¦‚æœå·²è¢«å…¶ä»–ownerå ç”¨ï¼Œä¼šå…ˆé‡Šæ”¾
     */
    @Synchronized
    fun acquire(owner: String, config: AudioConfig): AudioRecord? {
        Log.d(TAG, "ğŸ“± $owner è¯·æ±‚ AudioRecord")
        
        // å¦‚æœå·²è¢«å ç”¨ï¼Œå…ˆé‡Šæ”¾
        if (currentOwner != null && currentOwner != owner) {
            Log.d(TAG, "âš ï¸ AudioRecord è¢« $currentOwner å ç”¨ï¼Œå…ˆé‡Šæ”¾")
            release(currentOwner!!)
        }
        
        // åˆ›å»ºæ–°çš„ AudioRecord
        try {
            val bufferSize = AudioRecord.getMinBufferSize(
                config.sampleRate,
                config.channelConfig,
                config.audioFormat
            )
            
            currentRecord = AudioRecord(
                config.audioSource,
                config.sampleRate,
                config.channelConfig,
                config.audioFormat,
                bufferSize * 2
            )
            
            currentOwner = owner
            Log.d(TAG, "âœ… AudioRecord åˆ›å»ºæˆåŠŸï¼Œowner: $owner")
            
            return currentRecord
        } catch (e: Exception) {
            Log.e(TAG, "âŒ AudioRecord åˆ›å»ºå¤±è´¥", e)
            return null
        }
    }
    
    /**
     * é‡Šæ”¾ AudioRecord
     */
    @Synchronized
    fun release(owner: String) {
        if (currentOwner == owner) {
            Log.d(TAG, "ğŸ—‘ï¸ é‡Šæ”¾ AudioRecordï¼Œowner: $owner")
            
            currentRecord?.let {
                try {
                    if (it.recordingState == AudioRecord.RECORDSTATE_RECORDING) {
                        it.stop()
                    }
                    it.release()
                } catch (e: Exception) {
                    Log.w(TAG, "é‡Šæ”¾å¤±è´¥", e)
                }
            }
            
            currentRecord = null
            currentOwner = null
        } else {
            Log.w(TAG, "âš ï¸ $owner å°è¯•é‡Šæ”¾ä¸å±äºå®ƒçš„ AudioRecord")
        }
    }
    
    /**
     * è·å–å½“å‰owner
     */
    @Synchronized
    fun getCurrentOwner(): String? = currentOwner
}

data class AudioConfig(
    val audioSource: Int = MediaRecorder.AudioSource.MIC,
    val sampleRate: Int = 16000,
    val channelConfig: Int = AudioFormat.CHANNEL_IN_MONO,
    val audioFormat: Int = AudioFormat.ENCODING_PCM_16BIT
)
```

---

## âœ… å®æ–½æ¸…å•

### Phase 1: ä¿®å¤ç¼–è¯‘ + AudioRecordç®¡ç†ï¼ˆç«‹å³ï¼‰
- [x] ä¿®å¤ `Idle` çŠ¶æ€ç¼–è¯‘é”™è¯¯
- [ ] åˆ›å»º `AudioRecordManager`
- [ ] WakeService æ¥å…¥ AudioRecordManager
- [ ] SenseVoiceInputDevice æ¥å…¥ AudioRecordManager
- [ ] æµ‹è¯•èµ„æºç«äº‰

### Phase 2: ä¸­æ–­æœºåˆ¶ï¼ˆæœ¬å‘¨ï¼‰
- [ ] StateCoordinator æ·»åŠ  `interrupt()`
- [ ] SenseVoiceInputDevice æ·»åŠ  `onInterrupted()`
- [ ] WakeService æ£€æµ‹å”¤é†’è¯æ—¶è°ƒç”¨ä¸­æ–­
- [ ] æµ‹è¯•éšæ—¶æ‰“æ–­åŠŸèƒ½

### Phase 3: æ¶æ„é‡æ„ï¼ˆä¸‹ä¸ªæœˆï¼‰
- [ ] è®¾è®¡ `VoiceAssistantState`
- [ ] å®ç° `VoiceAssistantStateManager`
- [ ] è¿ç§» UI ç»„ä»¶
- [ ] åˆ é™¤ StateCoordinator
- [ ] å…¨é¢å›å½’æµ‹è¯•

---

## ğŸ“š å‚è€ƒèµ„æ–™

### VOSK ç›¸å…³
- [VOSK Android Demo](https://github.com/alphacep/vosk-android-demo)
- [VOSK State Management](https://github.com/alphacep/vosk-android-demo/blob/master/app/src/main/java/org/kaldi/demo/VoskActivity.java)

### Android æœ€ä½³å®è·µ
- [Single Source of Truth](https://developer.android.com/topic/architecture#single-source-of-truth)
- [State Management](https://developer.android.com/topic/architecture/ui-layer/stateholders)
- [AudioRecord Best Practices](https://developer.android.com/guide/topics/media/mediarecorder)

---

**æ–‡æ¡£ç»“æŸ**


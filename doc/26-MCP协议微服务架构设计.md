# Dicio Android MCPåè®®å¾®æœåŠ¡æ¶æ„è®¾è®¡

## ğŸ“‹ ç›®å½•

1. [æ¶æ„æ¦‚è§ˆ](#æ¶æ„æ¦‚è§ˆ)
2. [æ ¸å¿ƒè®¾è®¡åŸåˆ™](#æ ¸å¿ƒè®¾è®¡åŸåˆ™)
3. [MCPåè®®é€šä¿¡æ¶æ„](#mcpåè®®é€šä¿¡æ¶æ„)
4. [æœåŠ¡æ¨¡å—è®¾è®¡](#æœåŠ¡æ¨¡å—è®¾è®¡)
5. [äº‘ç«¯æœåŠ¡é›†æˆ](#äº‘ç«¯æœåŠ¡é›†æˆ)
6. [é¡¹ç›®ç»“æ„è§„åˆ’](#é¡¹ç›®ç»“æ„è§„åˆ’)
7. [å®ç°è®¡åˆ’](#å®ç°è®¡åˆ’)
8. [æ€§èƒ½ä¼˜åŒ–](#æ€§èƒ½ä¼˜åŒ–)
9. [å®‰å…¨æœºåˆ¶](#å®‰å…¨æœºåˆ¶)
10. [éƒ¨ç½²æ–¹æ¡ˆ](#éƒ¨ç½²æ–¹æ¡ˆ)

---

## ğŸ—ï¸ æ¶æ„æ¦‚è§ˆ

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Dicioè¯­éŸ³åŠ©æ‰‹å®¢æˆ·ç«¯                        â”‚
â”‚              (ä¸»UIåº”ç”¨ + æœåŠ¡åè°ƒå™¨)                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚ MCPåè®®é€šä¿¡
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                æœåŠ¡æ³¨å†Œä¸­å¿ƒ + æœåŠ¡è·¯ç”±å™¨                        â”‚
â”‚          (ServiceRegistry + ServiceRouter)                 â”‚
â””â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
  â”‚     â”‚     â”‚     â”‚     â”‚     â”‚     â”‚     â”‚     â”‚     â”‚
  v     v     v     v     v     v     v     v     v     v
â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â”
â”‚KWSâ”‚ â”‚KWSâ”‚ â”‚ASRâ”‚ â”‚ASRâ”‚ â”‚TTSâ”‚ â”‚TTSâ”‚ â”‚NLUâ”‚ â”‚CMDâ”‚ â”‚AUDâ”‚ â”‚MODâ”‚
â”‚æœ¬åœ°â”‚ â”‚æœ¬åœ°â”‚ â”‚æœ¬åœ°â”‚ â”‚äº‘ç«¯â”‚ â”‚æœ¬åœ°â”‚ â”‚äº‘ç«¯â”‚ â”‚äº‘ç«¯â”‚ â”‚æ··åˆâ”‚ â”‚   â”‚ â”‚   â”‚
â””â”€â”¬â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”¬â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”¬â”€â”˜ â””â”€â”¬â”€â”˜ â””â”€â”¬â”€â”˜ â””â”€â”€â”€â”˜ â””â”€â”€â”€â”˜
  â”‚                 â”‚             â”‚     â”‚     â”‚
  v                 v             v     v     v
â”Œâ”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ç¡¬ä»¶â”‚            â”‚ API â”‚       â”‚ API â”‚ â”‚   æ··åˆAPI  â”‚
â”‚è®¾å¤‡â”‚            â”‚ç½‘å…³ â”‚       â”‚ç½‘å…³ â”‚ â”‚   ç½‘å…³     â”‚
â””â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â”‚             â”‚         â”‚
                    v             v         v
              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
              â”‚äº‘ç«¯ASR   â”‚  â”‚äº‘ç«¯TTS   â”‚ â”‚äº‘ç«¯NLU   â”‚
              â”‚(ç™¾åº¦/ç§‘å¤§)â”‚  â”‚(é˜¿é‡Œ/è…¾è®¯)â”‚ â”‚(OpenAIç­‰)â”‚
              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### è®¾è®¡ç†å¿µ

- **æ¨¡å—åŒ–**: æ¯ä¸ªåŠŸèƒ½ç‹¬ç«‹ä¸ºä¸€ä¸ªæœåŠ¡æ¨¡å—
- **å¯æ‰©å±•**: æ”¯æŒæ–°æœåŠ¡çš„åŠ¨æ€æ³¨å†Œå’Œå‘ç°
- **é«˜å¯ç”¨**: å¤šå®ä¾‹éƒ¨ç½²ï¼Œæ•…éšœè‡ªåŠ¨åˆ‡æ¢
- **æ··åˆäº‘**: æœ¬åœ°+äº‘ç«¯æœåŠ¡æ— ç¼ç»“åˆ
- **æ€§èƒ½ä¼˜åŒ–**: èµ„æºå…±äº«ï¼Œæ™ºèƒ½è°ƒåº¦
- **å®‰å…¨ç¬¬ä¸€**: ç«¯åˆ°ç«¯åŠ å¯†ï¼Œæƒé™æ§åˆ¶

---

## ğŸ¯ æ ¸å¿ƒè®¾è®¡åŸåˆ™

### 1. æœåŠ¡æŠ½è±¡åŸåˆ™
- ç»Ÿä¸€çš„æœåŠ¡æ¥å£å®šä¹‰
- é€æ˜çš„æœ¬åœ°/äº‘ç«¯æœåŠ¡åˆ‡æ¢
- æ ‡å‡†åŒ–çš„æ•°æ®æ ¼å¼å’Œåè®®

### 2. é«˜å¯ç”¨åŸåˆ™
- æœåŠ¡å¥åº·ç›‘æ§å’Œè‡ªåŠ¨æ¢å¤
- å¤šå®ä¾‹è´Ÿè½½å‡è¡¡
- ä¼˜é›…é™çº§æœºåˆ¶

### 3. æ€§èƒ½ä¼˜åŒ–åŸåˆ™
- èµ„æºæ± åŒ–å’Œå¤ç”¨
- æ™ºèƒ½ç¼“å­˜ç­–ç•¥
- å¼‚æ­¥éé˜»å¡é€šä¿¡

### 4. å®‰å…¨åŸåˆ™
- æœ€å°æƒé™åŸåˆ™
- æ•°æ®åŠ å¯†ä¼ è¾“
- æœåŠ¡é—´è®¿é—®æ§åˆ¶

---

## ğŸ”— MCPåè®®é€šä¿¡æ¶æ„

### MCPæ¶ˆæ¯å®šä¹‰

```kotlin
// MCPæ¶ˆæ¯åŸºç±»
sealed class MCPMessage {
    data class Request(
        val id: String,
        val method: String,
        val params: Map<String, Any>,
        val timestamp: Long = System.currentTimeMillis()
    ) : MCPMessage()
    
    data class Response(
        val id: String,
        val result: Any?,
        val error: MCPError?,
        val timestamp: Long = System.currentTimeMillis()
    ) : MCPMessage()
    
    data class Notification(
        val method: String,
        val params: Map<String, Any>,
        val timestamp: Long = System.currentTimeMillis()
    ) : MCPMessage()
}

data class MCPError(
    val code: Int,
    val message: String,
    val data: Any? = null
)
```

### æœåŠ¡æ³¨å†Œä¸­å¿ƒ

```kotlin
@Component
class ServiceRegistry {
    private val services = ConcurrentHashMap<String, ServiceDescriptor>()
    private val serviceHealth = ConcurrentHashMap<String, HealthStatus>()
    
    suspend fun registerService(descriptor: ServiceDescriptor): Result<Unit>
    suspend fun discoverServices(type: ServiceType): List<ServiceDescriptor>
    suspend fun getService(serviceId: String): ServiceDescriptor?
    suspend fun unregisterService(serviceId: String): Result<Unit>
    
    fun startHealthCheck() // å®šæœŸå¥åº·æ£€æŸ¥
}

data class ServiceDescriptor(
    val id: String,
    val name: String,
    val type: ServiceType,
    val version: String,
    val endpoint: String,
    val capabilities: Set<String>,
    val metadata: Map<String, String>
)
```

### MCPå®¢æˆ·ç«¯å®ç°

```kotlin
class MCPClient(private val serviceConnection: ServiceConnection) {
    suspend fun call(method: String, params: Map<String, Any>): Result<Any>
    suspend fun notify(method: String, params: Map<String, Any>): Result<Unit>
    fun subscribe(method: String): Flow<MCPMessage.Notification>
}
```

---

## ğŸ§© æœåŠ¡æ¨¡å—è®¾è®¡

### 1. è¯­éŸ³å”¤é†’æœåŠ¡ (KWS)

#### æœåŠ¡æ¥å£å®šä¹‰

```kotlin
interface KWSService {
    suspend fun startListening(config: KWSConfig): Result<Unit>
    suspend fun stopListening(): Result<Unit>
    suspend fun setWakeWord(model: WakeWordModel): Result<Unit>
    suspend fun getStatus(): KWSStatus
    fun onWakeWordDetected(): Flow<WakeWordEvent>
}

data class KWSConfig(
    val model: WakeWordModel,
    val sensitivity: Float = 0.5f,
    val continuousMode: Boolean = true
)

data class WakeWordEvent(
    val timestamp: Long,
    val confidence: Float,
    val audioBuffer: ByteArray? = null
)
```

#### æ”¯æŒçš„å”¤é†’å¼•æ“

1. **OpenWakeWordå¼•æ“**
   - æ”¯æŒè‡ªå®šä¹‰å”¤é†’è¯
   - é«˜å‡†ç¡®ç‡ï¼Œä½è¯¯è§¦å‘
   - ç¦»çº¿è¿è¡Œ

2. **Sherpa-ONNX KWSå¼•æ“**
   - åŸºäºONNX Runtime
   - å¤šè¯­è¨€æ”¯æŒ
   - è½»é‡çº§éƒ¨ç½²

3. **HeyDicioå¼•æ“**
   - ç®€å•å…³é”®è¯åŒ¹é…
   - å¿«é€Ÿå“åº”
   - ä½èµ„æºæ¶ˆè€—

#### æœåŠ¡å®ç°ç¤ºä¾‹

```kotlin
@AndroidEntryPoint
class KWSService : BaseVoiceService(), KWSServiceInterface {
    
    @Inject lateinit var openWakeWordEngine: OpenWakeWordEngine
    @Inject lateinit var sherpaKWSEngine: SherpaKWSEngine
    @Inject lateinit var resourceManager: ResourceManager
    
    private var currentEngine: WakeWordEngine? = null
    private var isListening = AtomicBoolean(false)
    private val scope = CoroutineScope(Dispatchers.Default + SupervisorJob())
    
    override fun getServiceId() = "kws-primary"
    override fun getServiceType() = ServiceType.KWS
    override fun getCapabilities() = setOf(
        "openwakeword", "sherpa-kws", "custom-models", "streaming"
    )
    
    override suspend fun startListening(config: KWSConfig): Result<Unit> {
        return try {
            // 1. è·å–éŸ³é¢‘èµ„æº
            val audioResource = resourceManager.acquireAudioResource(getServiceId())
                .getOrThrow()
            
            // 2. é€‰æ‹©å¹¶åˆå§‹åŒ–å¼•æ“
            currentEngine = selectEngine(config.model)
            currentEngine?.initialize(config)
            
            // 3. å¼€å§‹ç›‘å¬
            isListening.set(true)
            scope.launch {
                listenForWakeWord(audioResource, config)
            }
            
            Result.success(Unit)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
    
    private suspend fun listenForWakeWord(
        audioResource: AudioResource, 
        config: KWSConfig
    ) {
        val audioRecord = audioResource.createAudioRecord()
        val buffer = ShortArray(FRAME_SIZE)
        
        while (isListening.get() && !Thread.currentThread().isInterrupted) {
            try {
                val samplesRead = audioRecord.read(buffer, 0, buffer.size)
                if (samplesRead > 0) {
                    val detected = currentEngine?.processFrame(buffer) ?: false
                    if (detected) {
                        handleWakeWordDetected(config)
                    }
                }
                yield() // è®©å‡ºCPUæ—¶é—´
            } catch (e: Exception) {
                Log.e(TAG, "Audio processing error", e)
                break
            }
        }
    }
    
    companion object {
        private const val TAG = "KWSService"
        private const val FRAME_SIZE = 1024
    }
}
```

### 2. è¯­éŸ³è¯†åˆ«æœåŠ¡ (ASR)

#### æœåŠ¡æ¥å£å®šä¹‰

```kotlin
interface ASRService {
    suspend fun startRecognition(config: ASRConfig): Result<String>
    suspend fun processAudioStream(audioStream: Flow<ByteArray>): Flow<ASRResult>
    suspend fun processAudioFile(audioData: ByteArray): Result<ASRResult>
    suspend fun stopRecognition(): Result<Unit>
    suspend fun getAvailableModels(): List<ASRModel>
}

data class ASRConfig(
    val model: ASRModel,
    val language: String,
    val streaming: Boolean = true,
    val maxDuration: Long = 30_000L
)

data class ASRResult(
    val text: String,
    val confidence: Float,
    val isPartial: Boolean = false,
    val timestamp: Long = System.currentTimeMillis()
)
```

#### æ”¯æŒçš„ASRå¼•æ“

1. **Voskå¼•æ“**
   - å®Œå…¨ç¦»çº¿
   - å¤šè¯­è¨€æ”¯æŒ
   - å®æ—¶æµå¼è¯†åˆ«

2. **SenseVoiceå¼•æ“**
   - é«˜ç²¾åº¦è¯†åˆ«
   - ä¸­æ–‡ä¼˜åŒ–
   - å¿«é€Ÿå“åº”

3. **Sherpa-ONNX ASRå¼•æ“**
   - åŸºäºONNX Runtime
   - è½»é‡çº§éƒ¨ç½²
   - å¤šæ¨¡å‹æ”¯æŒ

4. **äº‘ç«¯ASRæœåŠ¡**
   - ç™¾åº¦è¯­éŸ³è¯†åˆ«
   - ç§‘å¤§è®¯é£
   - é˜¿é‡Œäº‘ASR
   - è…¾è®¯äº‘ASR

### 3. è¯­éŸ³åˆæˆæœåŠ¡ (TTS)

#### æœåŠ¡æ¥å£å®šä¹‰

```kotlin
interface TTSService {
    suspend fun synthesize(text: String, config: TTSConfig): Result<ByteArray>
    suspend fun synthesizeStreaming(text: String, config: TTSConfig): Flow<ByteArray>
    suspend fun play(text: String, config: TTSConfig): Result<Unit>
    suspend fun stop(): Result<Unit>
    suspend fun getAvailableVoices(): List<TTSVoice>
}

data class TTSConfig(
    val voice: TTSVoice,
    val speed: Float = 1.0f,
    val pitch: Float = 1.0f,
    val volume: Float = 1.0f
)
```

#### æ”¯æŒçš„TTSå¼•æ“

1. **Androidç³»ç»ŸTTS**
   - ç³»ç»Ÿé›†æˆ
   - å¤šè¯­è¨€æ”¯æŒ
   - æ ‡å‡†åŒ–æ¥å£

2. **Sherpa-ONNX TTS**
   - ç¦»çº¿åˆæˆ
   - é«˜è´¨é‡éŸ³é¢‘
   - è‡ªå®šä¹‰éŸ³è‰²

3. **PiperTTS**
   - å¼€æºè§£å†³æ–¹æ¡ˆ
   - å¿«é€Ÿåˆæˆ
   - å¤šéŸ³è‰²æ”¯æŒ

4. **äº‘ç«¯TTSæœåŠ¡**
   - é˜¿é‡Œäº‘TTS
   - è…¾è®¯äº‘TTS
   - ç™¾åº¦TTS
   - å¾®è½¯TTS

### 4. è‡ªç„¶è¯­è¨€ç†è§£æœåŠ¡ (NLU)

#### æœåŠ¡æ¥å£å®šä¹‰

```kotlin
interface NLUService {
    suspend fun parseIntent(text: String, context: ConversationContext): Result<Intent>
    suspend fun extractEntities(text: String): List<Entity>
    suspend fun updateContext(context: ConversationContext): Result<Unit>
    suspend fun getAvailableSkills(): List<SkillInfo>
}

data class Intent(
    val skillId: String,
    val action: String,
    val entities: Map<String, Any>,
    val confidence: Float
)
```

#### NLUå®ç°æ–¹æ¡ˆ

1. **æœ¬åœ°è§„åˆ™å¼•æ“**
   - åŸºäºç°æœ‰DicioæŠ€èƒ½ç³»ç»Ÿ
   - å¿«é€Ÿå“åº”
   - éšç§ä¿æŠ¤

2. **äº‘ç«¯AIæœåŠ¡**
   - OpenAI GPT
   - ç™¾åº¦UNIT
   - ç§‘å¤§è®¯é£AIUI
   - å¾®è½¯LUIS

### 5. æŒ‡ä»¤æ‰§è¡ŒæœåŠ¡ (CMD)

#### æœåŠ¡æ¥å£å®šä¹‰

```kotlin
interface CMDService {
    suspend fun executeCommand(command: Command): Result<CommandResult>
    suspend fun getCommandStatus(commandId: String): CommandStatus
    suspend fun cancelCommand(commandId: String): Result<Unit>
    suspend fun getAvailableCommands(): List<CommandInfo>
}

data class Command(
    val id: String,
    val type: CommandType,
    val parameters: Map<String, Any>,
    val timeout: Long = 30_000L
)
```

---

## ğŸŒ äº‘ç«¯æœåŠ¡é›†æˆ

### æœåŠ¡æä¾›è€…æŠ½è±¡

```kotlin
interface ServiceProvider {
    val providerId: String
    val providerType: ProviderType
    val capabilities: Set<String>
    val metadata: Map<String, Any>
    
    suspend fun initialize(config: ProviderConfig): Result<Unit>
    suspend fun healthCheck(): HealthStatus
    suspend fun destroy(): Result<Unit>
}

enum class ProviderType {
    LOCAL,      // æœ¬åœ°æœåŠ¡
    CLOUD,      // äº‘ç«¯æœåŠ¡
    HYBRID      // æ··åˆæœåŠ¡ï¼ˆæœ¬åœ°+äº‘ç«¯ï¼‰
}
```

### äº‘ç«¯æœåŠ¡åŸºç±»

```kotlin
abstract class CloudServiceProvider(
    override val providerId: String,
    private val apiConfig: CloudAPIConfig
) : ServiceProvider {
    
    override val providerType = ProviderType.CLOUD
    
    protected val httpClient: OkHttpClient by lazy {
        OkHttpClient.Builder()
            .connectTimeout(apiConfig.connectTimeout, TimeUnit.SECONDS)
            .readTimeout(apiConfig.readTimeout, TimeUnit.SECONDS)
            .writeTimeout(apiConfig.writeTimeout, TimeUnit.SECONDS)
            .addInterceptor(AuthenticationInterceptor(apiConfig))
            .addInterceptor(RetryInterceptor(apiConfig.maxRetries))
            .addInterceptor(LoggingInterceptor())
            .build()
    }
    
    protected suspend fun <T> makeApiCall(
        call: suspend () -> T,
        fallback: (suspend () -> T)? = null
    ): Result<T> {
        return try {
            val result = call()
            Result.success(result)
        } catch (e: Exception) {
            when (e) {
                is SocketTimeoutException,
                is ConnectException,
                is UnknownHostException -> {
                    // ç½‘ç»œé”™è¯¯ï¼Œå°è¯•é™çº§
                    fallback?.let { 
                        try {
                            Result.success(it())
                        } catch (fallbackError: Exception) {
                            Result.failure(fallbackError)
                        }
                    } ?: Result.failure(NetworkException("ç½‘ç»œè¿æ¥å¤±è´¥", e))
                }
                else -> Result.failure(e)
            }
        }
    }
}
```

### äº‘ç«¯APIé…ç½®

```kotlin
data class CloudAPIConfig(
    val baseUrl: String,
    val apiKey: String,
    val secretKey: String? = null,
    val connectTimeout: Long = 30L,
    val readTimeout: Long = 30L,
    val writeTimeout: Long = 30L,
    val maxRetries: Int = 3,
    val retryDelayMs: Long = 1000L,
    val batchSize: Int = 10,
    val enableCache: Boolean = true,
    val cacheTimeoutMs: Long = 300_000L // 5åˆ†é’Ÿ
)
```

### æœåŠ¡è·¯ç”±å’Œæ™ºèƒ½é€‰æ‹©

```kotlin
@Singleton
class ServiceRouter @Inject constructor(
    private val serviceRegistry: ServiceRegistry,
    private val configManager: ConfigManager,
    private val networkMonitor: NetworkMonitor
) {
    
    suspend fun findBestService(
        serviceType: ServiceType,
        requirements: ServiceRequirements = ServiceRequirements()
    ): ServiceDescriptor? {
        val availableServices = serviceRegistry.getServicesByType(serviceType)
        
        return when (requirements.priority) {
            ServicePriority.PERFORMANCE -> selectByPerformance(availableServices)
            ServicePriority.ACCURACY -> selectByAccuracy(availableServices)
            ServicePriority.OFFLINE -> selectOfflineFirst(availableServices)
            ServicePriority.COST -> selectByCost(availableServices)
            ServicePriority.AUTO -> selectAutomatically(availableServices, requirements)
        }
    }
    
    private suspend fun selectAutomatically(
        services: List<ServiceDescriptor>,
        requirements: ServiceRequirements
    ): ServiceDescriptor? {
        val networkAvailable = networkMonitor.isNetworkAvailable()
        val batteryLevel = getBatteryLevel()
        val isCharging = isDeviceCharging()
        
        return when {
            // ç½‘ç»œä¸å¯ç”¨ï¼Œä¼˜é€‰æœ¬åœ°æœåŠ¡
            !networkAvailable -> {
                services.filter { it.type == ProviderType.LOCAL }.firstOrNull()
            }
            
            // ç”µé‡ä½ä¸”æœªå……ç”µï¼Œä¼˜é€‰æœ¬åœ°æœåŠ¡
            batteryLevel < 20 && !isCharging -> {
                services.filter { it.type == ProviderType.LOCAL }.firstOrNull()
            }
            
            // éœ€è¦é«˜å‡†ç¡®åº¦ï¼Œä¼˜é€‰äº‘ç«¯æœåŠ¡
            requirements.accuracy > 0.9f -> {
                services.filter { it.type == ProviderType.CLOUD }
                    .maxByOrNull { it.metadata["accuracy"] as? Float ?: 0.0f }
            }
            
            // éœ€è¦ä½å»¶è¿Ÿï¼Œä¼˜é€‰æœ¬åœ°æœåŠ¡
            requirements.maxLatency < 1000L -> {
                services.filter { it.type == ProviderType.LOCAL }.firstOrNull()
            }
            
            // é»˜è®¤æƒ…å†µï¼šæ··åˆç­–ç•¥
            else -> {
                services.maxByOrNull { calculateServiceScore(it, requirements) }
            }
        }
    }
}
```

---

## ğŸ“ é¡¹ç›®ç»“æ„è§„åˆ’

```
dicio-android/
â”œâ”€â”€ app/                                    # ä¸»UIåº”ç”¨
â”‚   â”œâ”€â”€ src/main/kotlin/org/stypox/dicio/
â”‚   â”‚   â”œâ”€â”€ coordinator/                    # æœåŠ¡åè°ƒå™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ VoiceAssistantCoordinator.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ VoiceFlowManager.kt
â”‚   â”‚   â”‚   â””â”€â”€ ServiceOrchestrator.kt
â”‚   â”‚   â”œâ”€â”€ flow/                          # æµç¨‹ç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ VoiceInteractionFlow.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ StateManager.kt
â”‚   â”‚   â”‚   â””â”€â”€ FlowTransition.kt
â”‚   â”‚   â”œâ”€â”€ ui/                            # UIç•Œé¢
â”‚   â”‚   â”‚   â”œâ”€â”€ home/
â”‚   â”‚   â”‚   â”œâ”€â”€ settings/
â”‚   â”‚   â”‚   â””â”€â”€ components/
â”‚   â”‚   â””â”€â”€ mcp/                           # MCPå®¢æˆ·ç«¯
â”‚   â”‚       â”œâ”€â”€ MCPClient.kt
â”‚   â”‚       â”œâ”€â”€ MessageHandler.kt
â”‚   â”‚       â””â”€â”€ ConnectionManager.kt
â”‚   â””â”€â”€ build.gradle.kts
â”‚
â”œâ”€â”€ mcp-core/                              # MCPåè®®æ ¸å¿ƒåº“
â”‚   â”œâ”€â”€ src/main/kotlin/org/stypox/dicio/mcp/
â”‚   â”‚   â”œâ”€â”€ protocol/                      # åè®®å®šä¹‰
â”‚   â”‚   â”‚   â”œâ”€â”€ MCPMessage.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ MCPError.kt
â”‚   â”‚   â”‚   â””â”€â”€ ServiceContract.kt
â”‚   â”‚   â”œâ”€â”€ client/                        # å®¢æˆ·ç«¯å®ç°
â”‚   â”‚   â”‚   â”œâ”€â”€ MCPClient.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ ConnectionPool.kt
â”‚   â”‚   â”‚   â””â”€â”€ CallManager.kt
â”‚   â”‚   â”œâ”€â”€ server/                        # æœåŠ¡ç«¯å®ç°
â”‚   â”‚   â”‚   â”œâ”€â”€ MCPServer.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ RequestHandler.kt
â”‚   â”‚   â”‚   â””â”€â”€ ResponseManager.kt
â”‚   â”‚   â””â”€â”€ security/                      # å®‰å…¨æœºåˆ¶
â”‚   â”‚       â”œâ”€â”€ AuthenticationManager.kt
â”‚   â”‚       â”œâ”€â”€ EncryptionUtils.kt
â”‚   â”‚       â””â”€â”€ AccessController.kt
â”‚   â””â”€â”€ build.gradle.kts
â”‚
â”œâ”€â”€ service-registry/                      # æœåŠ¡æ³¨å†Œä¸­å¿ƒ
â”‚   â”œâ”€â”€ src/main/kotlin/org/stypox/dicio/registry/
â”‚   â”‚   â”œâ”€â”€ ServiceRegistry.kt
â”‚   â”‚   â”œâ”€â”€ ServiceRouter.kt
â”‚   â”‚   â”œâ”€â”€ HealthChecker.kt
â”‚   â”‚   â””â”€â”€ LoadBalancer.kt
â”‚   â””â”€â”€ build.gradle.kts
â”‚
â”œâ”€â”€ kws-service/                          # è¯­éŸ³å”¤é†’æœåŠ¡
â”‚   â”œâ”€â”€ src/main/kotlin/org/stypox/dicio/kws/
â”‚   â”‚   â”œâ”€â”€ openwakeword/                 # OpenWakeWordå®ç°
â”‚   â”‚   â”‚   â”œâ”€â”€ OpenWakeWordEngine.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ ModelManager.kt
â”‚   â”‚   â”‚   â””â”€â”€ AudioProcessor.kt
â”‚   â”‚   â”œâ”€â”€ sherpa/                       # Sherpa-ONNX KWSå®ç°
â”‚   â”‚   â”‚   â”œâ”€â”€ SherpaKWSEngine.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ ONNXModelLoader.kt
â”‚   â”‚   â”‚   â””â”€â”€ KWSPreprocessor.kt
â”‚   â”‚   â””â”€â”€ service/                      # æœåŠ¡å®ç°
â”‚   â”‚       â”œâ”€â”€ KWSService.kt
â”‚   â”‚       â”œâ”€â”€ WakeWordDetector.kt
â”‚   â”‚       â””â”€â”€ AudioStreamManager.kt
â”‚   â””â”€â”€ build.gradle.kts
â”‚
â”œâ”€â”€ asr-service/                          # è¯­éŸ³è¯†åˆ«æœåŠ¡
â”‚   â”œâ”€â”€ src/main/kotlin/org/stypox/dicio/asr/
â”‚   â”‚   â”œâ”€â”€ vosk/                         # Voskå®ç°
â”‚   â”‚   â”‚   â”œâ”€â”€ VoskEngine.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ VoskModelManager.kt
â”‚   â”‚   â”‚   â””â”€â”€ VoskRecognizer.kt
â”‚   â”‚   â”œâ”€â”€ sensevoice/                   # SenseVoiceå®ç°
â”‚   â”‚   â”‚   â”œâ”€â”€ SenseVoiceEngine.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ AudioBuffer.kt
â”‚   â”‚   â”‚   â””â”€â”€ SenseVoiceModelManager.kt
â”‚   â”‚   â”œâ”€â”€ sherpa/                       # Sherpa-ONNX ASRå®ç°
â”‚   â”‚   â”‚   â”œâ”€â”€ SherpaASREngine.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ StreamingRecognizer.kt
â”‚   â”‚   â”‚   â””â”€â”€ BatchRecognizer.kt
â”‚   â”‚   â”œâ”€â”€ cloud/                        # äº‘ç«¯ASRå®ç°
â”‚   â”‚   â”‚   â”œâ”€â”€ BaiduASRProvider.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ XunfeiASRProvider.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ AlibabaASRProvider.kt
â”‚   â”‚   â”‚   â””â”€â”€ TencentASRProvider.kt
â”‚   â”‚   â””â”€â”€ service/                      # æœåŠ¡å®ç°
â”‚   â”‚       â”œâ”€â”€ ASRService.kt
â”‚   â”‚       â”œâ”€â”€ RecognitionSession.kt
â”‚   â”‚       â””â”€â”€ AudioStreamProcessor.kt
â”‚   â””â”€â”€ build.gradle.kts
â”‚
â”œâ”€â”€ tts-service/                          # è¯­éŸ³åˆæˆæœåŠ¡
â”‚   â”œâ”€â”€ src/main/kotlin/org/stypox/dicio/tts/
â”‚   â”‚   â”œâ”€â”€ android/                      # Android TTS
â”‚   â”‚   â”‚   â”œâ”€â”€ AndroidTTSEngine.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ SystemTTSWrapper.kt
â”‚   â”‚   â”‚   â””â”€â”€ VoiceManager.kt
â”‚   â”‚   â”œâ”€â”€ sherpa/                       # Sherpa-ONNX TTS
â”‚   â”‚   â”‚   â”œâ”€â”€ SherpaTTSEngine.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ VoiceModelManager.kt
â”‚   â”‚   â”‚   â””â”€â”€ AudioSynthesizer.kt
â”‚   â”‚   â”œâ”€â”€ piper/                        # PiperTTS
â”‚   â”‚   â”‚   â”œâ”€â”€ PiperTTSEngine.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ PhonemeTTSConverter.kt
â”‚   â”‚   â”‚   â””â”€â”€ ModelLoader.kt
â”‚   â”‚   â”œâ”€â”€ cloud/                        # äº‘ç«¯TTSå®ç°
â”‚   â”‚   â”‚   â”œâ”€â”€ AlibabaTTSProvider.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ TencentTTSProvider.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ BaiduTTSProvider.kt
â”‚   â”‚   â”‚   â””â”€â”€ MicrosoftTTSProvider.kt
â”‚   â”‚   â””â”€â”€ service/                      # æœåŠ¡å®ç°
â”‚   â”‚       â”œâ”€â”€ TTSService.kt
â”‚   â”‚       â”œâ”€â”€ SynthesisManager.kt
â”‚   â”‚       â””â”€â”€ AudioPlayer.kt
â”‚   â””â”€â”€ build.gradle.kts
â”‚
â”œâ”€â”€ nlu-service/                          # æ„å›¾ç†è§£æœåŠ¡
â”‚   â”œâ”€â”€ src/main/kotlin/org/stypox/dicio/nlu/
â”‚   â”‚   â”œâ”€â”€ skills/                       # æŠ€èƒ½å®šä¹‰
â”‚   â”‚   â”‚   â”œâ”€â”€ SkillRegistry.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ SkillMatcher.kt
â”‚   â”‚   â”‚   â””â”€â”€ SkillExecutor.kt
â”‚   â”‚   â”œâ”€â”€ intent/                       # æ„å›¾è¯†åˆ«
â”‚   â”‚   â”‚   â”œâ”€â”€ IntentClassifier.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ EntityExtractor.kt
â”‚   â”‚   â”‚   â””â”€â”€ ContextManager.kt
â”‚   â”‚   â”œâ”€â”€ cloud/                        # äº‘ç«¯NLUå®ç°
â”‚   â”‚   â”‚   â”œâ”€â”€ OpenAINLUProvider.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ BaiduUNITProvider.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ XunfeiAIUIProvider.kt
â”‚   â”‚   â”‚   â””â”€â”€ MicrosoftLUISProvider.kt
â”‚   â”‚   â””â”€â”€ service/                      # æœåŠ¡å®ç°
â”‚   â”‚       â”œâ”€â”€ NLUService.kt
â”‚   â”‚       â”œâ”€â”€ IntentParser.kt
â”‚   â”‚       â””â”€â”€ ConversationManager.kt
â”‚   â””â”€â”€ build.gradle.kts
â”‚
â”œâ”€â”€ cmd-service/                          # æŒ‡ä»¤æ‰§è¡ŒæœåŠ¡
â”‚   â”œâ”€â”€ src/main/kotlin/org/stypox/dicio/cmd/
â”‚   â”‚   â”œâ”€â”€ system/                       # ç³»ç»ŸæŒ‡ä»¤
â”‚   â”‚   â”‚   â”œâ”€â”€ SystemController.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ DeviceManager.kt
â”‚   â”‚   â”‚   â””â”€â”€ AppLauncher.kt
â”‚   â”‚   â”œâ”€â”€ skills/                       # æŠ€èƒ½æ‰§è¡Œ
â”‚   â”‚   â”‚   â”œâ”€â”€ WeatherSkill.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ MusicSkill.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ TimerSkill.kt
â”‚   â”‚   â”‚   â””â”€â”€ SearchSkill.kt
â”‚   â”‚   â”œâ”€â”€ cloud/                        # äº‘ç«¯APIè°ƒç”¨
â”‚   â”‚   â”‚   â”œâ”€â”€ WeatherAPIClient.kt
â”‚   â”‚   â”‚   â”œâ”€â”€ NewsAPIClient.kt
â”‚   â”‚   â”‚   â””â”€â”€ SmartHomeController.kt
â”‚   â”‚   â””â”€â”€ service/                      # æœåŠ¡å®ç°
â”‚   â”‚       â”œâ”€â”€ CMDService.kt
â”‚   â”‚       â”œâ”€â”€ CommandExecutor.kt
â”‚   â”‚       â””â”€â”€ ResultFormatter.kt
â”‚   â””â”€â”€ build.gradle.kts
â”‚
â””â”€â”€ shared/                               # å…±äº«åº“
    â”œâ”€â”€ models/                           # æ•°æ®æ¨¡å‹
    â”‚   â”œâ”€â”€ ServiceDescriptor.kt
    â”‚   â”œâ”€â”€ ASRResult.kt
    â”‚   â”œâ”€â”€ TTSConfig.kt
    â”‚   â””â”€â”€ Intent.kt
    â”œâ”€â”€ utils/                            # å·¥å…·ç±»
    â”‚   â”œâ”€â”€ AudioUtils.kt
    â”‚   â”œâ”€â”€ NetworkUtils.kt
    â”‚   â”œâ”€â”€ EncryptionUtils.kt
    â”‚   â””â”€â”€ PerformanceMonitor.kt
    â””â”€â”€ build.gradle.kts
```

---

## ğŸ“‹ å®ç°è®¡åˆ’

### é˜¶æ®µ1: åŸºç¡€æ¶æ„æ­å»º (2-3å‘¨)

#### 1.1 MCPåè®®æ ¸å¿ƒåº“å¼€å‘
- [ ] æ¶ˆæ¯åè®®å®šä¹‰
- [ ] å®¢æˆ·ç«¯/æœåŠ¡ç«¯åŸºç¡€æ¡†æ¶
- [ ] å®‰å…¨æœºåˆ¶å®ç°
- [ ] å•å…ƒæµ‹è¯•ç¼–å†™

#### 1.2 æœåŠ¡æ³¨å†Œä¸­å¿ƒå¼€å‘
- [ ] æœåŠ¡æ³¨å†Œ/å‘ç°æœºåˆ¶
- [ ] å¥åº·æ£€æŸ¥ç³»ç»Ÿ
- [ ] è´Ÿè½½å‡è¡¡å™¨
- [ ] æœåŠ¡è·¯ç”±å™¨

#### 1.3 åŸºç¡€æœåŠ¡æ¡†æ¶
- [ ] BaseVoiceServiceæŠ½è±¡ç±»
- [ ] æœåŠ¡ç”Ÿå‘½å‘¨æœŸç®¡ç†
- [ ] èµ„æºç®¡ç†å™¨
- [ ] é…ç½®ç®¡ç†ç³»ç»Ÿ

### é˜¶æ®µ2: æ ¸å¿ƒæœåŠ¡å¼€å‘ (3-4å‘¨)

#### 2.1 è¯­éŸ³å”¤é†’æœåŠ¡ (KWS)
- [ ] OpenWakeWordå¼•æ“é›†æˆ
- [ ] Sherpa-ONNX KWSå¼•æ“é›†æˆ
- [ ] éŸ³é¢‘æµå¤„ç†ä¼˜åŒ–
- [ ] å¤šæ¨¡å‹æ”¯æŒ

#### 2.2 è¯­éŸ³è¯†åˆ«æœåŠ¡ (ASR)
- [ ] Voskå¼•æ“é›†æˆ
- [ ] SenseVoiceå¼•æ“é›†æˆ
- [ ] æµå¼è¯†åˆ«å®ç°
- [ ] æ‰¹é‡è¯†åˆ«æ”¯æŒ

#### 2.3 è¯­éŸ³åˆæˆæœåŠ¡ (TTS)
- [ ] Android TTSé›†æˆ
- [ ] Sherpa-ONNX TTSé›†æˆ
- [ ] PiperTTSé›†æˆ
- [ ] éŸ³è´¨ä¼˜åŒ–

### é˜¶æ®µ3: äº‘ç«¯æœåŠ¡é›†æˆ (2-3å‘¨)

#### 3.1 äº‘ç«¯ASRæœåŠ¡
- [ ] ç™¾åº¦è¯­éŸ³è¯†åˆ«API
- [ ] ç§‘å¤§è®¯é£API
- [ ] é˜¿é‡Œäº‘ASR API
- [ ] è…¾è®¯äº‘ASR API

#### 3.2 äº‘ç«¯NLUæœåŠ¡
- [ ] OpenAI GPTé›†æˆ
- [ ] ç™¾åº¦UNIT API
- [ ] ç§‘å¤§è®¯é£AIUI API
- [ ] å¾®è½¯LUIS API

#### 3.3 äº‘ç«¯TTSæœåŠ¡
- [ ] é˜¿é‡Œäº‘TTS API
- [ ] è…¾è®¯äº‘TTS API
- [ ] ç™¾åº¦TTS API
- [ ] å¾®è½¯TTS API

### é˜¶æ®µ4: ä¸»åº”ç”¨å¼€å‘ (2-3å‘¨)

#### 4.1 æœåŠ¡åè°ƒå™¨
- [ ] VoiceAssistantCoordinatorå®ç°
- [ ] æµç¨‹ç®¡ç†å™¨å¼€å‘
- [ ] çŠ¶æ€æœºå®ç°
- [ ] é”™è¯¯å¤„ç†æœºåˆ¶

#### 4.2 ç”¨æˆ·ç•Œé¢
- [ ] ä¸»ç•Œé¢è®¾è®¡
- [ ] è®¾ç½®é¡µé¢
- [ ] æœåŠ¡çŠ¶æ€ç›‘æ§
- [ ] æ€§èƒ½ä»ªè¡¨æ¿

#### 4.3 é…ç½®å’Œç®¡ç†
- [ ] æœåŠ¡é…ç½®ç•Œé¢
- [ ] äº‘ç«¯APIå¯†é’¥ç®¡ç†
- [ ] æƒé™ç®¡ç†
- [ ] æ—¥å¿—æŸ¥çœ‹å™¨

### é˜¶æ®µ5: æµ‹è¯•å’Œä¼˜åŒ– (2-3å‘¨)

#### 5.1 åŠŸèƒ½æµ‹è¯•
- [ ] å•å…ƒæµ‹è¯•å®Œå–„
- [ ] é›†æˆæµ‹è¯•
- [ ] ç«¯åˆ°ç«¯æµ‹è¯•
- [ ] æ€§èƒ½æµ‹è¯•

#### 5.2 æ€§èƒ½ä¼˜åŒ–
- [ ] å†…å­˜ä½¿ç”¨ä¼˜åŒ–
- [ ] å¯åŠ¨æ—¶é—´ä¼˜åŒ–
- [ ] å“åº”å»¶è¿Ÿä¼˜åŒ–
- [ ] ç”µæ± ä½¿ç”¨ä¼˜åŒ–

#### 5.3 ç¨³å®šæ€§æµ‹è¯•
- [ ] é•¿æ—¶é—´è¿è¡Œæµ‹è¯•
- [ ] å‹åŠ›æµ‹è¯•
- [ ] æ•…éšœæ¢å¤æµ‹è¯•
- [ ] å…¼å®¹æ€§æµ‹è¯•

---

## âš¡ æ€§èƒ½ä¼˜åŒ–

### 1. èµ„æºç®¡ç†ä¼˜åŒ–

```kotlin
class ServiceResourceManager {
    private val serviceInstances = ConcurrentHashMap<String, ServiceInstance>()
    private val resourcePools = ConcurrentHashMap<String, ResourcePool>()
    
    suspend fun getOrCreateService(serviceId: String): ServiceInstance {
        return serviceInstances.getOrPut(serviceId) {
            createServiceInstance(serviceId)
        }
    }
    
    suspend fun recycleIdleServices() {
        val currentTime = System.currentTimeMillis()
        val idleThreshold = 5 * 60 * 1000L // 5åˆ†é’Ÿ
        
        serviceInstances.entries.removeAll { (serviceId, instance) ->
            if (currentTime - instance.lastAccessTime > idleThreshold) {
                try {
                    instance.destroy()
                    Log.d(TAG, "Recycled idle service: $serviceId")
                    true
                } catch (e: Exception) {
                    Log.e(TAG, "Failed to destroy service: $serviceId", e)
                    false
                }
            } else {
                false
            }
        }
    }
    
    fun optimizeMemoryUsage() {
        // 1. æ¸…ç†æ¨¡å‹ç¼“å­˜
        clearOldModelCache()
        
        // 2. å‹ç¼©éŸ³é¢‘ç¼“å†²åŒº
        compressAudioBuffers()
        
        // 3. é‡Šæ”¾ä¸å¿…è¦çš„èµ„æº
        releaseUnusedResources()
        
        // 4. è§¦å‘GC
        System.gc()
    }
}
```

### 2. ç¼“å­˜ç­–ç•¥

```kotlin
@Singleton
class MultiLevelCacheManager {
    
    // L1ç¼“å­˜ï¼šå†…å­˜ç¼“å­˜
    private val memoryCache = LRUCache<String, Any>(maxSize = 100)
    
    // L2ç¼“å­˜ï¼šç£ç›˜ç¼“å­˜
    private val diskCache = DiskLruCache.open(cacheDir, 1, 1, 50 * 1024 * 1024)
    
    // L3ç¼“å­˜ï¼šäº‘ç«¯ç¼“å­˜
    private val cloudCache = CloudCacheClient()
    
    suspend fun <T> getOrCompute(
        key: String,
        type: Class<T>,
        computer: suspend () -> T
    ): T {
        // L1ç¼“å­˜æŸ¥æ‰¾
        memoryCache.get(key)?.let { 
            return it as T 
        }
        
        // L2ç¼“å­˜æŸ¥æ‰¾
        diskCache.get(key)?.let { snapshot ->
            val data = deserialize<T>(snapshot.getInputStream(0), type)
            memoryCache.put(key, data) // å›å¡«L1ç¼“å­˜
            return data
        }
        
        // L3ç¼“å­˜æŸ¥æ‰¾ï¼ˆä»…å¯¹ç‰¹å®šç±»å‹ï¼‰
        if (shouldUseCloudCache(type)) {
            cloudCache.get(key, type)?.let { data ->
                memoryCache.put(key, data) // å›å¡«L1ç¼“å­˜
                diskCache.put(key, serialize(data)) // å›å¡«L2ç¼“å­˜
                return data
            }
        }
        
        // è®¡ç®—ç»“æœ
        val result = computer()
        
        // å†™å…¥å„çº§ç¼“å­˜
        memoryCache.put(key, result)
        diskCache.put(key, serialize(result))
        if (shouldUseCloudCache(type)) {
            cloudCache.put(key, result)
        }
        
        return result
    }
}
```

### 3. éŸ³é¢‘å¤„ç†ä¼˜åŒ–

```kotlin
class OptimizedAudioProcessor {
    
    private val audioQueue = ArrayBlockingQueue<FloatArray>(10)
    private val processingPool = Executors.newFixedThreadPool(2)
    
    fun processAudioStream(inputStream: Flow<ByteArray>): Flow<ProcessedAudio> = flow {
        // ä½¿ç”¨åç¨‹å¹¶è¡Œå¤„ç†éŸ³é¢‘
        inputStream
            .buffer(capacity = 5) // ç¼“å†²5ä¸ªéŸ³é¢‘å—
            .map { audioData ->
                async(Dispatchers.Default) {
                    processAudioChunk(audioData)
                }
            }
            .collect { deferredResult ->
                emit(deferredResult.await())
            }
    }
    
    private suspend fun processAudioChunk(audioData: ByteArray): ProcessedAudio {
        return withContext(Dispatchers.Default) {
            // 1. é™å™ªå¤„ç†
            val denoisedAudio = denoiseAudio(audioData)
            
            // 2. éŸ³é‡æ ‡å‡†åŒ–
            val normalizedAudio = normalizeVolume(denoisedAudio)
            
            // 3. ç‰¹å¾æå–
            val features = extractFeatures(normalizedAudio)
            
            ProcessedAudio(normalizedAudio, features)
        }
    }
    
    private fun denoiseAudio(audioData: ByteArray): ByteArray {
        // ä½¿ç”¨Wieneræ»¤æ³¢æˆ–è°±å‡æ³•è¿›è¡Œé™å™ª
        return AudioDenoiser.denoise(audioData)
    }
    
    private fun normalizeVolume(audioData: ByteArray): ByteArray {
        // éŸ³é‡æ ‡å‡†åŒ–åˆ°åˆé€‚èŒƒå›´
        return AudioNormalizer.normalize(audioData, targetRMS = 0.1f)
    }
    
    private fun extractFeatures(audioData: ByteArray): AudioFeatures {
        // æå–MFCCã€èƒ½é‡ç­‰ç‰¹å¾
        return AudioFeatureExtractor.extract(audioData)
    }
}
```

### 4. ç½‘ç»œä¼˜åŒ–

```kotlin
class OptimizedNetworkClient {
    
    private val connectionPool = ConnectionPool(
        maxIdleConnections = 5,
        keepAliveDuration = 30,
        timeUnit = TimeUnit.SECONDS
    )
    
    private val httpClient = OkHttpClient.Builder()
        .connectionPool(connectionPool)
        .addInterceptor(CompressionInterceptor())
        .addInterceptor(BatchingInterceptor())
        .addNetworkInterceptor(CacheInterceptor())
        .build()
    
    suspend fun batchApiCalls(requests: List<ApiRequest>): List<ApiResponse> {
        // æ‰¹é‡å¤„ç†APIè¯·æ±‚
        return requests.chunked(10).flatMap { batch ->
            batch.map { request ->
                async { makeApiCall(request) }
            }.awaitAll()
        }
    }
    
    private suspend fun makeApiCall(request: ApiRequest): ApiResponse {
        return withContext(Dispatchers.IO) {
            val httpRequest = request.toOkHttpRequest()
            val response = httpClient.newCall(httpRequest).execute()
            ApiResponse.fromOkHttpResponse(response)
        }
    }
}
```

---

## ğŸ”’ å®‰å…¨æœºåˆ¶

### 1. æœåŠ¡é—´è®¤è¯

```kotlin
class ServiceAuthenticationManager {
    
    private val serviceTokens = ConcurrentHashMap<String, ServiceToken>()
    private val keyStore = AndroidKeyStore()
    
    suspend fun generateServiceToken(serviceId: String): ServiceToken {
        val timestamp = System.currentTimeMillis()
        val nonce = UUID.randomUUID().toString()
        val payload = "$serviceId:$timestamp:$nonce"
        
        val signature = keyStore.sign(payload)
        
        val token = ServiceToken(
            serviceId = serviceId,
            timestamp = timestamp,
            nonce = nonce,
            signature = signature,
            expiresAt = timestamp + TOKEN_VALIDITY_MS
        )
        
        serviceTokens[serviceId] = token
        return token
    }
    
    suspend fun validateServiceToken(token: ServiceToken): Boolean {
        return try {
            // æ£€æŸ¥è¿‡æœŸæ—¶é—´
            if (token.expiresAt < System.currentTimeMillis()) {
                return false
            }
            
            // éªŒè¯ç­¾å
            val payload = "${token.serviceId}:${token.timestamp}:${token.nonce}"
            keyStore.verify(payload, token.signature)
        } catch (e: Exception) {
            Log.e(TAG, "Token validation failed", e)
            false
        }
    }
    
    companion object {
        private const val TOKEN_VALIDITY_MS = 24 * 60 * 60 * 1000L // 24å°æ—¶
        private const val TAG = "ServiceAuthenticationManager"
    }
}
```

### 2. æ•°æ®åŠ å¯†

```kotlin
class DataEncryptionManager {
    
    private val keyAlias = "DicioServiceKey"
    private val transformation = "AES/GCM/NoPadding"
    
    init {
        generateKeyIfNeeded()
    }
    
    private fun generateKeyIfNeeded() {
        if (!keyExists()) {
            val keyGenerator = KeyGenerator.getInstance(KeyProperties.KEY_ALGORITHM_AES, "AndroidKeyStore")
            val keyGenParameterSpec = KeyGenParameterSpec.Builder(
                keyAlias,
                KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
            )
                .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                .setRandomizedEncryptionRequired(true)
                .setUserAuthenticationRequired(false)
                .build()
            
            keyGenerator.init(keyGenParameterSpec)
            keyGenerator.generateKey()
        }
    }
    
    fun encrypt(data: ByteArray): EncryptedData {
        val keyStore = KeyStore.getInstance("AndroidKeyStore")
        keyStore.load(null)
        
        val key = keyStore.getKey(keyAlias, null) as SecretKey
        val cipher = Cipher.getInstance(transformation)
        cipher.init(Cipher.ENCRYPT_MODE, key)
        
        val encryptedBytes = cipher.doFinal(data)
        val iv = cipher.iv
        
        return EncryptedData(
            data = encryptedBytes,
            iv = iv,
            algorithm = transformation
        )
    }
    
    fun decrypt(encryptedData: EncryptedData): ByteArray {
        val keyStore = KeyStore.getInstance("AndroidKeyStore")
        keyStore.load(null)
        
        val key = keyStore.getKey(keyAlias, null) as SecretKey
        val cipher = Cipher.getInstance(transformation)
        val spec = GCMParameterSpec(128, encryptedData.iv)
        cipher.init(Cipher.DECRYPT_MODE, key, spec)
        
        return cipher.doFinal(encryptedData.data)
    }
    
    private fun keyExists(): Boolean {
        return try {
            val keyStore = KeyStore.getInstance("AndroidKeyStore")
            keyStore.load(null)
            keyStore.containsAlias(keyAlias)
        } catch (e: Exception) {
            false
        }
    }
}

data class EncryptedData(
    val data: ByteArray,
    val iv: ByteArray,
    val algorithm: String
)
```

### 3. æƒé™æ§åˆ¶

```kotlin
class ServicePermissionManager {
    
    private val permissions = mapOf(
        "kws-service" to setOf(
            "android.permission.RECORD_AUDIO",
            "android.permission.WAKE_LOCK"
        ),
        "asr-service" to setOf(
            "android.permission.RECORD_AUDIO",
            "android.permission.INTERNET"
        ),
        "tts-service" to setOf(
            "android.permission.MODIFY_AUDIO_SETTINGS",
            "android.permission.INTERNET"
        ),
        "nlu-service" to setOf(
            "android.permission.INTERNET"
        ),
        "cmd-service" to setOf(
            "android.permission.SYSTEM_ALERT_WINDOW",
            "android.permission.WRITE_EXTERNAL_STORAGE"
        )
    )
    
    private val serviceAccessMatrix = mapOf(
        "dicio-main" to setOf("kws-service", "asr-service", "tts-service", "nlu-service", "cmd-service"),
        "kws-service" to setOf("asr-service"),
        "asr-service" to setOf("nlu-service"),
        "nlu-service" to setOf("cmd-service"),
        "cmd-service" to setOf("tts-service")
    )
    
    fun checkServiceAccess(clientServiceId: String, targetServiceId: String): Boolean {
        return serviceAccessMatrix[clientServiceId]?.contains(targetServiceId) ?: false
    }
    
    fun checkPermissions(serviceId: String, context: Context): PermissionCheckResult {
        val requiredPermissions = permissions[serviceId] ?: emptySet()
        val deniedPermissions = mutableSetOf<String>()
        
        for (permission in requiredPermissions) {
            if (ContextCompat.checkSelfPermission(context, permission) != PackageManager.PERMISSION_GRANTED) {
                deniedPermissions.add(permission)
            }
        }
        
        return PermissionCheckResult(
            allGranted = deniedPermissions.isEmpty(),
            grantedPermissions = requiredPermissions - deniedPermissions,
            deniedPermissions = deniedPermissions
        )
    }
}

data class PermissionCheckResult(
    val allGranted: Boolean,
    val grantedPermissions: Set<String>,
    val deniedPermissions: Set<String>
)
```

---

## ğŸš€ éƒ¨ç½²æ–¹æ¡ˆ

### 1. å¤šAPKæ„å»ºé…ç½®

#### ä¸»åº”ç”¨ (app/build.gradle.kts)
```kotlin
android {
    defaultConfig {
        applicationId = "org.stypox.dicio"
        minSdk = 24
        targetSdk = 34
        
        // ä¸»åº”ç”¨é…ç½®
        manifestPlaceholders["appType"] = "main"
    }
    
    buildTypes {
        release {
            isMinifyEnabled = true
            proguardFiles("proguard-android-optimize.txt", "proguard-rules.pro")
        }
    }
}

dependencies {
    implementation(project(":mcp-core"))
    implementation(project(":service-registry"))
    implementation(project(":shared"))
    
    // UIç›¸å…³ä¾èµ–
    implementation(libs.androidx.compose.bom)
    implementation(libs.androidx.activity.compose)
    implementation(libs.androidx.navigation.compose)
    
    // ä¾èµ–æ³¨å…¥
    implementation(libs.hilt.android)
    kapt(libs.hilt.compiler)
}
```

#### KWSæœåŠ¡ (kws-service/build.gradle.kts)
```kotlin
android {
    defaultConfig {
        applicationId = "org.stypox.dicio.kws"
        minSdk = 24
        targetSdk = 34
        
        // æœåŠ¡ä¸“ç”¨é…ç½®
        manifestPlaceholders["serviceType"] = "kws"
        manifestPlaceholders["servicePriority"] = "high"
    }
    
    buildTypes {
        release {
            isMinifyEnabled = true
            proguardFiles("proguard-kws-service.pro")
        }
    }
}

dependencies {
    implementation(project(":mcp-core"))
    implementation(project(":shared"))
    
    // KWSä¸“ç”¨ä¾èµ–
    implementation("ai.onnxruntime:onnxruntime-android:1.15.1")
    implementation("org.tensorflow:tensorflow-lite:2.13.0")
    
    // OpenWakeWord
    implementation("com.github.dscripka:openwakeword-android:1.0.0")
}
```

### 2. æœåŠ¡æ¸…å•é…ç½®

#### KWSæœåŠ¡æ¸…å• (kws-service/src/main/AndroidManifest.xml)
```xml
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:name=".KWSServiceApplication"
        android:process=":kws_service"
        android:exported="false">
        
        <service
            android:name=".KWSService"
            android:enabled="true"
            android:exported="true"
            android:permission="org.stypox.dicio.permission.VOICE_SERVICE">
            <intent-filter>
                <action android:name="org.stypox.dicio.action.KWS_SERVICE" />
                <category android:name="android.intent.category.DEFAULT" />
            </intent-filter>
            
            <meta-data
                android:name="service.type"
                android:value="kws" />
            <meta-data
                android:name="service.version"
                android:value="1.0.0" />
            <meta-data
                android:name="service.capabilities"
                android:value="openwakeword,sherpa-kws,custom-models" />
        </service>
    </application>
    
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_MICROPHONE" />
</manifest>
```

### 3. è‡ªåŠ¨åŒ–æ„å»ºè„šæœ¬

#### æ„å»ºè„šæœ¬ (build-all-services.sh)
```bash
#!/bin/bash

set -e

echo "ğŸš€ å¼€å§‹æ„å»ºDicioå¾®æœåŠ¡æ¶æ„"

# æ„å»ºé¡ºåºï¼šä¾èµ–åº“ -> æœåŠ¡ -> ä¸»åº”ç”¨
MODULES=(
    "shared"
    "mcp-core" 
    "service-registry"
    "kws-service"
    "asr-service"
    "tts-service"
    "nlu-service"
    "cmd-service"
    "app"
)

BUILD_TYPE=${1:-debug}
PARALLEL_JOBS=${2:-4}

echo "ğŸ“‹ æ„å»ºé…ç½®ï¼š"
echo "   æ„å»ºç±»å‹: $BUILD_TYPE"
echo "   å¹¶è¡Œä»»åŠ¡: $PARALLEL_JOBS"
echo "   ç›®æ ‡æ¨¡å—: ${MODULES[*]}"

# æ¸…ç†ä¹‹å‰çš„æ„å»º
echo "ğŸ§¹ æ¸…ç†ä¹‹å‰çš„æ„å»º..."
./gradlew clean

# å¹¶è¡Œæ„å»ºæ‰€æœ‰æ¨¡å—
echo "ğŸ”¨ å¼€å§‹å¹¶è¡Œæ„å»º..."
for module in "${MODULES[@]}"; do
    (
        echo "ğŸ“¦ æ„å»ºæ¨¡å—: $module"
        ./gradlew ":$module:assemble${BUILD_TYPE^}" \
            --parallel \
            --max-workers=$PARALLEL_JOBS \
            --build-cache \
            --configuration-cache
        echo "âœ… æ¨¡å— $module æ„å»ºå®Œæˆ"
    ) &
done

# ç­‰å¾…æ‰€æœ‰æ„å»ºå®Œæˆ
wait

echo "ğŸ‰ æ‰€æœ‰æ¨¡å—æ„å»ºå®Œæˆ"

# æ”¶é›†APKæ–‡ä»¶
echo "ğŸ“¦ æ”¶é›†æ„å»ºäº§ç‰©..."
OUTPUT_DIR="build/outputs/apks"
mkdir -p "$OUTPUT_DIR"

for module in "${MODULES[@]}"; do
    if [ -d "$module/build/outputs/apk" ]; then
        cp -r "$module/build/outputs/apk/"* "$OUTPUT_DIR/"
        echo "   âœ… æ”¶é›† $module APK"
    fi
done

echo "ğŸ æ„å»ºå®Œæˆï¼APKæ–‡ä»¶ä½äº: $OUTPUT_DIR"
ls -la "$OUTPUT_DIR"
```

#### éƒ¨ç½²è„šæœ¬ (deploy-services.sh)
```bash
#!/bin/bash

set -e

ADB=${ADB:-adb}
DEVICE_ID=${1:-""}
INSTALL_TYPE=${2:-"replace"}

if [ -n "$DEVICE_ID" ]; then
    ADB="$ADB -s $DEVICE_ID"
fi

echo "ğŸ“± å¼€å§‹éƒ¨ç½²æœåŠ¡åˆ°è®¾å¤‡"

# æ£€æŸ¥è®¾å¤‡è¿æ¥
if ! $ADB devices | grep -q "device$"; then
    echo "âŒ æœªæ‰¾åˆ°è¿æ¥çš„Androidè®¾å¤‡"
    exit 1
fi

# APKå®‰è£…é¡ºåº
APKS=(
    "shared-debug.apk"
    "mcp-core-debug.apk"
    "service-registry-debug.apk"
    "kws-service-debug.apk"
    "asr-service-debug.apk"
    "tts-service-debug.apk"
    "nlu-service-debug.apk"
    "cmd-service-debug.apk"
    "app-debug.apk"
)

OUTPUT_DIR="build/outputs/apks"

# å®‰è£…APK
for apk in "${APKS[@]}"; do
    if [ -f "$OUTPUT_DIR/$apk" ]; then
        echo "ğŸ“¦ å®‰è£…: $apk"
        if [ "$INSTALL_TYPE" = "replace" ]; then
            $ADB install -r "$OUTPUT_DIR/$apk"
        else
            $ADB install "$OUTPUT_DIR/$apk"
        fi
        echo "   âœ… $apk å®‰è£…å®Œæˆ"
    else
        echo "   âš ï¸  æœªæ‰¾åˆ°: $apk"
    fi
done

# å¯åŠ¨ä¸»åº”ç”¨
echo "ğŸš€ å¯åŠ¨ä¸»åº”ç”¨"
$ADB shell am start -n org.stypox.dicio/.MainActivity

echo "ğŸ‰ éƒ¨ç½²å®Œæˆï¼"
```

### 4. Dockerå®¹å™¨åŒ–ï¼ˆå¯é€‰ï¼‰

#### Dockerfile
```dockerfile
FROM openjdk:11-jdk

# å®‰è£…Android SDK
ENV ANDROID_SDK_ROOT=/opt/android-sdk
ENV PATH=${PATH}:${ANDROID_SDK_ROOT}/tools:${ANDROID_SDK_ROOT}/platform-tools

# å®‰è£…æ„å»ºä¾èµ–
RUN apt-get update && apt-get install -y \
    wget \
    unzip \
    git \
    && rm -rf /var/lib/apt/lists/*

# ä¸‹è½½Android SDK
RUN mkdir -p ${ANDROID_SDK_ROOT} && \
    cd ${ANDROID_SDK_ROOT} && \
    wget https://dl.google.com/android/repository/commandlinetools-linux-9477386_latest.zip && \
    unzip commandlinetools-linux-9477386_latest.zip && \
    rm commandlinetools-linux-9477386_latest.zip

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /workspace

# å¤åˆ¶é¡¹ç›®æ–‡ä»¶
COPY . .

# æ„å»ºåº”ç”¨
RUN ./gradlew assembleDebug --no-daemon

# è¾“å‡ºç›®å½•
VOLUME ["/workspace/build/outputs"]

CMD ["./build-all-services.sh", "debug"]
```

---

## ğŸ“Š ç›‘æ§å’Œç»´æŠ¤

### 1. æ€§èƒ½ç›‘æ§

```kotlin
class ServicePerformanceMonitor @Inject constructor() {
    private val metrics = ConcurrentHashMap<String, ServiceMetrics>()
    
    fun recordServiceCall(
        serviceId: String,
        method: String,
        duration: Long,
        success: Boolean
    ) {
        val metric = metrics.getOrPut(serviceId) { ServiceMetrics(serviceId) }
        metric.recordCall(method, duration, success)
    }
    
    fun getServiceHealth(serviceId: String): ServiceHealth {
        val metric = metrics[serviceId] ?: return ServiceHealth.Unknown
        
        return ServiceHealth(
            serviceId = serviceId,
            avgResponseTime = metric.getAverageResponseTime(),
            successRate = metric.getSuccessRate(),
            memoryUsage = getServiceMemoryUsage(serviceId),
            cpuUsage = getServiceCpuUsage(serviceId),
            status = determineHealthStatus(metric)
        )
    }
    
    suspend fun generatePerformanceReport(): PerformanceReport {
        val allMetrics = metrics.values.map { it.generateReport() }
        return PerformanceReport(
            timestamp = System.currentTimeMillis(),
            serviceReports = allMetrics,
            systemOverview = generateSystemOverview()
        )
    }
}
```

### 2. æ—¥å¿—èšåˆ

```kotlin
class LogAggregator {
    private val logBuffer = CircularBuffer<LogEntry>(capacity = 10000)
    
    fun log(level: LogLevel, tag: String, message: String, throwable: Throwable? = null) {
        val entry = LogEntry(
            timestamp = System.currentTimeMillis(),
            level = level,
            tag = tag,
            message = message,
            throwable = throwable,
            threadName = Thread.currentThread().name,
            serviceId = getCurrentServiceId()
        )
        
        logBuffer.add(entry)
        
        // å¼‚æ­¥ä¸Šä¼ åˆ°è¿œç¨‹æ—¥å¿—æœåŠ¡
        if (shouldUploadLogs(level)) {
            uploadLogEntry(entry)
        }
    }
    
    fun exportLogs(filter: LogFilter): List<LogEntry> {
        return logBuffer.filter { entry ->
            filter.matches(entry)
        }
    }
}
```

### 3. è‡ªåŠ¨åŒ–æµ‹è¯•

```kotlin
@RunWith(AndroidJUnit4::class)
class ServiceIntegrationTest {
    
    @get:Rule
    val hiltRule = HiltAndroidRule(this)
    
    @Inject
    lateinit var serviceRegistry: ServiceRegistry
    
    @Inject 
    lateinit var mcpClient: MCPClient
    
    @Before
    fun setup() {
        hiltRule.inject()
    }
    
    @Test
    fun testVoiceInteractionFlow() = runTest {
        // 1. å¯åŠ¨KWSæœåŠ¡
        val kwsService = serviceRegistry.getService("kws-primary")
        assertNotNull(kwsService)
        
        val kwsStarted = mcpClient.call(
            kwsService!!.endpoint,
            "startListening",
            mapOf("sensitivity" to 0.6f)
        )
        assertTrue(kwsStarted.isSuccess)
        
        // 2. æ¨¡æ‹Ÿå”¤é†’æ£€æµ‹
        val wakeEvent = simulateWakeWordDetection()
        assertNotNull(wakeEvent)
        
        // 3. å¯åŠ¨ASRæœåŠ¡
        val asrService = serviceRegistry.getService("asr-primary")
        assertNotNull(asrService)
        
        val recognitionResult = simulateVoiceRecognition("ä»Šå¤©å¤©æ°”æ€ä¹ˆæ ·")
        assertEquals("ä»Šå¤©å¤©æ°”æ€ä¹ˆæ ·", recognitionResult.text)
        assertTrue(recognitionResult.confidence > 0.8f)
        
        // 4. NLUå¤„ç†
        val nluService = serviceRegistry.getService("nlu-primary")
        val intent = mcpClient.call(
            nluService!!.endpoint,
            "parseIntent",
            mapOf("text" to recognitionResult.text)
        ).getOrThrow() as Intent
        
        assertEquals("weather", intent.skillId)
        assertEquals("query", intent.action)
        
        // 5. æŒ‡ä»¤æ‰§è¡Œ
        val cmdService = serviceRegistry.getService("cmd-primary")
        val commandResult = mcpClient.call(
            cmdService!!.endpoint,
            "executeCommand",
            intent.toCommand().toMap()
        ).getOrThrow() as CommandResult
        
        assertNotNull(commandResult.response)
        assertTrue(commandResult.success)
    }
    
    @Test
    fun testServiceFailoverScenario() = runTest {
        // æµ‹è¯•æœåŠ¡æ•…éšœåˆ‡æ¢åœºæ™¯
        val primaryASR = serviceRegistry.getService("asr-primary")
        val backupASR = serviceRegistry.getService("asr-backup")
        
        // æ¨¡æ‹Ÿä¸»æœåŠ¡æ•…éšœ
        simulateServiceFailure(primaryASR!!.id)
        
        // éªŒè¯è‡ªåŠ¨åˆ‡æ¢åˆ°å¤‡ç”¨æœåŠ¡
        delay(1000) // ç­‰å¾…æ•…éšœæ£€æµ‹
        
        val currentASR = serviceRegistry.findBestService(ServiceType.ASR)
        assertEquals(backupASR!!.id, currentASR!!.id)
    }
}
```

---

## ğŸ“š æ€»ç»“

è¿™ä¸ªåŸºäºMCPåè®®çš„å¾®æœåŠ¡æ¶æ„è®¾è®¡ä¸ºDicioè¯­éŸ³åŠ©æ‰‹æä¾›äº†ï¼š

### ğŸ¯ æ ¸å¿ƒä¼˜åŠ¿

1. **é«˜åº¦æ¨¡å—åŒ–**: æ¯ä¸ªåŠŸèƒ½ç‹¬ç«‹ä¸ºæœåŠ¡ï¼Œä¾¿äºå¼€å‘ã€æµ‹è¯•å’Œç»´æŠ¤
2. **å¯æ‰©å±•æ€§**: æ”¯æŒåŠ¨æ€æ·»åŠ æ–°æœåŠ¡å’ŒåŠŸèƒ½
3. **é«˜å¯ç”¨æ€§**: å¤šå®ä¾‹éƒ¨ç½²ï¼Œè‡ªåŠ¨æ•…éšœåˆ‡æ¢
4. **æ··åˆäº‘æ¶æ„**: æœ¬åœ°å’Œäº‘ç«¯æœåŠ¡æ— ç¼ç»“åˆ
5. **æ€§èƒ½ä¼˜åŒ–**: æ™ºèƒ½èµ„æºç®¡ç†å’Œç¼“å­˜ç­–ç•¥
6. **å®‰å…¨å¯é **: ç«¯åˆ°ç«¯åŠ å¯†å’Œè®¿é—®æ§åˆ¶

### ğŸš€ æŠ€æœ¯ç‰¹è‰²

1. **MCPåè®®é€šä¿¡**: æ ‡å‡†åŒ–çš„æœåŠ¡é—´é€šä¿¡åè®®
2. **æ™ºèƒ½æœåŠ¡è·¯ç”±**: æ ¹æ®ç½‘ç»œã€ç”µé‡ã€æ€§èƒ½è‡ªåŠ¨é€‰æ‹©æœ€ä½³æœåŠ¡
3. **å¤šçº§ç¼“å­˜**: å†…å­˜ã€ç£ç›˜ã€äº‘ç«¯ä¸‰çº§ç¼“å­˜ç­–ç•¥
4. **ä¼˜é›…é™çº§**: äº‘ç«¯æœåŠ¡å¤±è´¥æ—¶è‡ªåŠ¨é™çº§åˆ°æœ¬åœ°æœåŠ¡
5. **å®æ—¶ç›‘æ§**: å…¨é¢çš„æ€§èƒ½ç›‘æ§å’Œå¥åº·æ£€æŸ¥

### ğŸ“‹ å®æ–½å»ºè®®

1. **åˆ†é˜¶æ®µå®æ–½**: æŒ‰ç…§5ä¸ªé˜¶æ®µé€æ­¥å®ç°ï¼Œç¡®ä¿æ¯ä¸ªé˜¶æ®µéƒ½æœ‰å¯äº¤ä»˜çš„æˆæœ
2. **æµ‹è¯•é©±åŠ¨**: æ¯ä¸ªæœåŠ¡éƒ½è¦æœ‰å®Œæ•´çš„å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•
3. **æ€§èƒ½ä¼˜å…ˆ**: é‡ç‚¹å…³æ³¨å¯åŠ¨æ—¶é—´ã€å“åº”å»¶è¿Ÿå’Œå†…å­˜ä½¿ç”¨
4. **ç”¨æˆ·ä½“éªŒ**: ç¡®ä¿æœåŠ¡åˆ‡æ¢å¯¹ç”¨æˆ·é€æ˜ï¼Œä¿æŒæµç•…ä½“éªŒ
5. **æ–‡æ¡£å®Œå–„**: ç»´æŠ¤è¯¦ç»†çš„APIæ–‡æ¡£å’Œéƒ¨ç½²æŒ‡å—

è¿™ä¸ªæ¶æ„è®¾è®¡ä¸ºDicioé¡¹ç›®çš„æœªæ¥å‘å±•å¥ å®šäº†åšå®çš„åŸºç¡€ï¼Œæ”¯æŒä»ç®€å•çš„è¯­éŸ³åŠ©æ‰‹å‘å±•ä¸ºå…¨åŠŸèƒ½çš„AIåŠ©æ‰‹å¹³å°ã€‚

# Dicio 数据存储与配置管理

## 存储架构概述

Dicio 采用现代化的数据存储方案，使用 DataStore 替代传统的 SharedPreferences，通过 Protocol Buffers 实现类型安全的配置管理。系统支持配置迁移、响应式更新和数据持久化。

## 技术栈

### 核心存储技术
- **DataStore**: 现代化的数据存储解决方案
- **Protocol Buffers**: 类型安全的序列化格式
- **Kotlin Coroutines**: 异步数据操作
- **StateFlow**: 响应式配置更新

### 相关依赖
```kotlin
androidx.datastore:datastore:1.1.2
com.google.protobuf:protobuf-javalite:4.29.3
com.google.protobuf:protobuf-kotlin-lite:4.29.3
```

## 配置数据模型

### 1. Protocol Buffers 定义

#### 用户设置 (UserSettings)
- **文件**: `app/src/main/proto/user_settings.proto`
- **功能**: 定义所有用户配置项

```protobuf
syntax = "proto3";

package org.stypox.dicio.settings.datastore;

message UserSettings {
  Language language = 1;
  Theme theme = 2;
  bool dynamic_colors = 3;
  InputDevice input_device = 4;
  WakeDevice wake_device = 5;
  SpeechOutputDevice speech_output_device = 6;
  SttPlaySound stt_play_sound = 7;
  bool auto_finish_stt_popup = 8;
  map<string, bool> enabled_skills_map = 9;
}
```

#### 语言配置
- **文件**: `app/src/main/proto/language.proto`

```protobuf
enum Language {
  LANGUAGE_UNSPECIFIED = 0;
  LANGUAGE_SYSTEM = 1;
  LANGUAGE_EN = 2;
  LANGUAGE_IT = 3;
  LANGUAGE_DE = 4;
  LANGUAGE_FR = 5;
  LANGUAGE_ES = 6;
  LANGUAGE_RU = 7;
  LANGUAGE_CS = 8;
  LANGUAGE_PL = 9;
  LANGUAGE_SL = 10;
  LANGUAGE_EL = 11;
  LANGUAGE_SV = 12;
  LANGUAGE_UK = 13;
}
```

#### 主题配置
- **文件**: `app/src/main/proto/theme.proto`

```protobuf
enum Theme {
  THEME_UNSPECIFIED = 0;
  THEME_SYSTEM = 1;
  THEME_LIGHT = 2;
  THEME_DARK = 3;
}
```

#### 输入设备配置
- **文件**: `app/src/main/proto/input_device.proto`

```protobuf
enum InputDevice {
  INPUT_DEVICE_UNSPECIFIED = 0;
  INPUT_DEVICE_VOSK = 1;
  INPUT_DEVICE_ANDROID_STT = 2;
  INPUT_DEVICE_EXTERNAL_POPUP = 3;
}
```

#### 唤醒设备配置
- **文件**: `app/src/main/proto/wake_device.proto`

```protobuf
enum WakeDevice {
  WAKE_DEVICE_UNSPECIFIED = 0;
  WAKE_DEVICE_NOTHING = 1;
  WAKE_DEVICE_HEY_DICIO = 2;
  WAKE_DEVICE_OPEN_WAKE_WORD = 3;
}
```

#### 语音输出设备配置
- **文件**: `app/src/main/proto/speech_output_device.proto`

```protobuf
enum SpeechOutputDevice {
  SPEECH_OUTPUT_DEVICE_UNSPECIFIED = 0;
  SPEECH_OUTPUT_DEVICE_ANDROID_TTS = 1;
  SPEECH_OUTPUT_DEVICE_TOAST = 2;
  SPEECH_OUTPUT_DEVICE_SNACKBAR = 3;
}
```

### 2. 数据类扩展

#### UserSettings 扩展
```kotlin
// 默认值定义
val UserSettings.Companion.DEFAULT: UserSettings
    get() = UserSettings.newBuilder()
        .setLanguage(Language.LANGUAGE_SYSTEM)
        .setTheme(Theme.THEME_SYSTEM)
        .setDynamicColors(true)
        .setInputDevice(InputDevice.INPUT_DEVICE_VOSK)
        .setWakeDevice(WakeDevice.WAKE_DEVICE_HEY_DICIO)
        .setSpeechOutputDevice(SpeechOutputDevice.SPEECH_OUTPUT_DEVICE_ANDROID_TTS)
        .setSttPlaySound(SttPlaySound.STT_PLAY_SOUND_BOTH)
        .setAutoFinishSttPopup(false)
        .build()

// 便利方法
fun UserSettings.isSkillEnabled(skillId: String): Boolean {
    return enabledSkillsMapMap.getOrDefault(skillId, true)
}
```

## DataStore 配置

### 1. 序列化器

#### UserSettingsSerializer
- **文件**: `app/src/main/kotlin/org/stypox/dicio/settings/datastore/UserSettingsSerializer.kt`
- **功能**: Protocol Buffers 序列化处理

```kotlin
object UserSettingsSerializer : Serializer<UserSettings> {
    override val defaultValue: UserSettings = UserSettings.getDefaultInstance()
    
    override suspend fun readFrom(input: InputStream): UserSettings {
        return try {
            UserSettings.parseFrom(input)
        } catch (exception: InvalidProtocolBufferException) {
            throw CorruptionException("Cannot read proto.", exception)
        }
    }
    
    override suspend fun writeTo(t: UserSettings, output: OutputStream) {
        t.writeTo(output)
    }
}
```

### 2. DataStore 模块

#### UserSettingsModule
- **文件**: `app/src/main/kotlin/org/stypox/dicio/settings/datastore/UserSettingsModule.kt`
- **功能**: DataStore 依赖注入配置

```kotlin
@Module
@InstallIn(SingletonComponent::class)
class UserSettingsModule {
    
    @Provides
    @Singleton
    fun provideUserSettingsDataStore(
        @ApplicationContext context: Context
    ): DataStore<UserSettings> {
        return DataStoreFactory.create(
            serializer = UserSettingsSerializer,
            corruptionHandler = ReplaceFileCorruptionHandler {
                UserSettingsSerializer.defaultValue
            },
            migrations = listOf(
                getSharedPreferencesMigration(context)
            ),
            produceFile = {
                context.dataStoreFile("settings.pb")
            }
        )
    }
    
    companion object {
        fun getSharedPreferencesMigration(
            context: Context
        ): SharedPreferencesMigration<UserSettings> {
            return SharedPreferencesMigration(
                context = context,
                sharedPreferencesName = "shared_preferences",
                migrate = { sharedPrefs, currentData ->
                    migrateFromSharedPreferences(sharedPrefs, currentData)
                }
            )
        }
    }
}
```

### 3. 数据迁移

#### SharedPreferences 迁移
```kotlin
private fun migrateFromSharedPreferences(
    sharedPrefs: SharedPreferencesView,
    currentData: UserSettings
): UserSettings {
    val builder = currentData.toBuilder()
    
    // 迁移语言设置
    sharedPrefs.getString("language")?.let { languageCode ->
        val language = when (languageCode) {
            "system" -> Language.LANGUAGE_SYSTEM
            "en" -> Language.LANGUAGE_EN
            "it" -> Language.LANGUAGE_IT
            // ... 其他语言映射
            else -> Language.LANGUAGE_SYSTEM
        }
        builder.setLanguage(language)
    }
    
    // 迁移主题设置
    sharedPrefs.getString("theme")?.let { themeValue ->
        val theme = when (themeValue) {
            "light" -> Theme.THEME_LIGHT
            "dark" -> Theme.THEME_DARK
            "system" -> Theme.THEME_SYSTEM
            else -> Theme.THEME_SYSTEM
        }
        builder.setTheme(theme)
    }
    
    // 迁移其他设置...
    
    return builder.build()
}
```

## 配置管理系统

### 1. ViewModel 集成

#### MainSettingsViewModel
- **文件**: `app/src/main/kotlin/org/stypox/dicio/settings/MainSettingsViewModel.kt`
- **功能**: 主设置界面的数据管理

```kotlin
@HiltViewModel
class MainSettingsViewModel @Inject constructor(
    application: Application,
    private val dataStore: DataStore<UserSettings>,
    private val wakeDeviceWrapper: WakeDeviceWrapper?
) : AndroidViewModel(application) {
    
    // 响应式设置状态
    val settingsState = dataStore.data
        .toStateFlowDistinctBlockingFirst(viewModelScope)
    
    // 设置更新方法
    private fun updateData(transform: (UserSettings.Builder) -> Unit) {
        viewModelScope.launch {
            dataStore.updateData { currentSettings ->
                currentSettings.toBuilder()
                    .apply(transform)
                    .build()
            }
        }
    }
    
    // 具体设置更新方法
    fun setLanguage(value: Language) = 
        updateData { it.setLanguage(value) }
    
    fun setTheme(value: Theme) = 
        updateData { it.setTheme(value) }
    
    fun setDynamicColors(value: Boolean) = 
        updateData { it.setDynamicColors(value) }
    
    fun setInputDevice(value: InputDevice) = 
        updateData { it.setInputDevice(value) }
    
    fun setWakeDevice(value: WakeDevice) = 
        updateData { it.setWakeDevice(value) }
    
    fun setSpeechOutputDevice(value: SpeechOutputDevice) = 
        updateData { it.setSpeechOutputDevice(value) }
    
    fun setSttPlaySound(value: SttPlaySound) = 
        updateData { it.setSttPlaySound(value) }
    
    fun setAutoFinishSttPopup(value: Boolean) = 
        updateData { it.setAutoFinishSttPopup(value) }
}
```

#### SkillSettingsViewModel
- **文件**: `app/src/main/kotlin/org/stypox/dicio/settings/SkillSettingsViewModel.kt`
- **功能**: 技能设置管理

```kotlin
@HiltViewModel
class SkillSettingsViewModel @Inject constructor(
    private val dataStore: DataStore<UserSettings>,
    private val skillHandler: SkillHandler,
) : ViewModel() {
    
    val enabledSkillsInfo = skillHandler.enabledSkillsInfo
    
    val enabledSkills = dataStore.data
        .map { it.enabledSkillsMapMap }
        .stateIn(
            scope = viewModelScope,
            started = SharingStarted.WhileSubscribed(5000),
            initialValue = emptyMap()
        )
    
    fun setSkillEnabled(skillId: String, enabled: Boolean) {
        viewModelScope.launch {
            dataStore.updateData { currentSettings ->
                currentSettings.toBuilder()
                    .putEnabledSkillsMap(skillId, enabled)
                    .build()
            }
        }
    }
}
```

### 2. 响应式配置更新

#### 配置监听
```kotlin
class SomeComponent @Inject constructor(
    private val dataStore: DataStore<UserSettings>
) {
    
    init {
        // 监听特定配置变化
        dataStore.data
            .map { it.language }
            .distinctUntilChanged()
            .onEach { language ->
                handleLanguageChange(language)
            }
            .launchIn(scope)
        
        // 监听多个配置变化
        dataStore.data
            .map { settings -> 
                Triple(settings.theme, settings.dynamicColors, settings.language)
            }
            .distinctUntilChanged()
            .onEach { (theme, dynamicColors, language) ->
                handleUIConfigChange(theme, dynamicColors, language)
            }
            .launchIn(scope)
    }
}
```

#### 状态流转换
```kotlin
// 扩展函数：将 Flow 转换为 StateFlow 并阻塞获取初始值
fun <T> Flow<T>.toStateFlowDistinctBlockingFirst(
    scope: CoroutineScope
): StateFlow<T> {
    val initialValue = runBlocking { first() }
    return distinctUntilChanged()
        .stateIn(
            scope = scope,
            started = SharingStarted.Eagerly,
            initialValue = initialValue
        )
}
```

## 本地化管理

### 1. LocaleManager

#### 语言管理器
- **文件**: `app/src/main/kotlin/org/stypox/dicio/di/LocaleManager.kt`
- **功能**: 统一的语言环境管理

```kotlin
@Singleton
class LocaleManager @Inject constructor(
    @ApplicationContext private val context: Context,
    private val dataStore: DataStore<UserSettings>
) {
    
    val locale: StateFlow<Locale> = dataStore.data
        .map { settings -> 
            when (settings.language) {
                Language.LANGUAGE_SYSTEM -> getSystemLocale()
                Language.LANGUAGE_EN -> Locale.ENGLISH
                Language.LANGUAGE_IT -> Locale.ITALIAN
                Language.LANGUAGE_DE -> Locale.GERMAN
                Language.LANGUAGE_FR -> Locale.FRENCH
                Language.LANGUAGE_ES -> Locale("es")
                Language.LANGUAGE_RU -> Locale("ru")
                Language.LANGUAGE_CS -> Locale("cs")
                Language.LANGUAGE_PL -> Locale("pl")
                Language.LANGUAGE_SL -> Locale("sl")
                Language.LANGUAGE_EL -> Locale("el")
                Language.LANGUAGE_SV -> Locale("sv")
                Language.LANGUAGE_UK -> Locale("uk")
                else -> getSystemLocale()
            }
        }
        .distinctUntilChanged()
        .toStateFlowDistinctBlockingFirst(scope)
    
    private fun getSystemLocale(): Locale {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            context.resources.configuration.locales[0]
        } else {
            @Suppress("DEPRECATION")
            context.resources.configuration.locale
        }
    }
}
```

### 2. 语言资源管理

#### 多语言支持
- **资源目录**: `app/src/main/res/values-*/`
- **支持语言**: 
  - 英语 (en)
  - 意大利语 (it) 
  - 德语 (de)
  - 法语 (fr)
  - 西班牙语 (es)
  - 俄语 (ru)
  - 捷克语 (cs)
  - 波兰语 (pl)
  - 斯洛文尼亚语 (sl)
  - 希腊语 (el)
  - 瑞典语 (sv)
  - 乌克兰语 (uk)
  - 中文 (zh-CN, zh-TW)

#### 动态语言切换
```kotlin
class BaseActivity : ComponentActivity() {
    
    @Inject lateinit var localeManager: LocaleManager
    
    override fun attachBaseContext(newBase: Context) {
        val locale = runBlocking { localeManager.locale.first() }
        val config = Configuration(newBase.resources.configuration)
        config.setLocale(locale)
        super.attachBaseContext(newBase.createConfigurationContext(config))
    }
}
```

## 缓存和临时数据

### 1. 文件缓存管理

#### 模型文件缓存
```kotlin
class VoskInputDevice {
    private val filesDir: File = appContext.filesDir
    private val cacheDir: File = appContext.cacheDir
    
    // 持久化文件
    private val modelDirectory: File get() = File(filesDir, "vosk-model")
    private val modelZipFile: File get() = File(filesDir, "vosk-model.zip")
    
    // 缓存文件
    private val tempDirectory: File get() = File(cacheDir, "temp")
    
    fun clearCache() {
        tempDirectory.deleteRecursively()
    }
}
```

#### 用户数据管理
```kotlin
class OpenWakeWordDevice {
    private val userWakeFile: File get() = 
        File(appContext.filesDir, "user_wake_word.onnx")
    
    fun addUserWakeFile(context: Context, uri: Uri) {
        context.contentResolver.openInputStream(uri)?.use { input ->
            userWakeFile.outputStream().use { output ->
                input.copyTo(output)
            }
        }
    }
    
    fun removeUserWakeFile() {
        if (userWakeFile.exists()) {
            userWakeFile.delete()
        }
    }
}
```

### 2. 内存缓存

#### 技能数据缓存
```kotlin
class SkillHandler {
    // 缓存已构建的技能实例
    private val skillCache = mutableMapOf<String, Skill<*>>()
    
    private fun buildSkillFromInfo(skillInfo: SkillInfo): Skill<*> {
        return skillCache.getOrPut(skillInfo.id) {
            skillInfo.build(skillContext)
        }
    }
    
    fun clearSkillCache() {
        skillCache.clear()
    }
}
```

## 数据备份和恢复

### 1. 设置导出
```kotlin
class SettingsExporter @Inject constructor(
    private val dataStore: DataStore<UserSettings>
) {
    
    suspend fun exportSettings(): ByteArray {
        val settings = dataStore.data.first()
        return settings.toByteArray()
    }
    
    suspend fun importSettings(data: ByteArray) {
        val settings = UserSettings.parseFrom(data)
        dataStore.updateData { settings }
    }
}
```

### 2. 自动备份
```kotlin
class AutoBackupManager @Inject constructor(
    private val dataStore: DataStore<UserSettings>,
    @ApplicationContext private val context: Context
) {
    
    private val backupFile = File(context.filesDir, "settings_backup.pb")
    
    fun scheduleBackup() {
        dataStore.data
            .sample(Duration.ofHours(24)) // 每24小时备份一次
            .onEach { settings ->
                backupFile.writeBytes(settings.toByteArray())
            }
            .launchIn(scope)
    }
    
    suspend fun restoreFromBackup(): Boolean {
        return try {
            if (backupFile.exists()) {
                val settings = UserSettings.parseFrom(backupFile.readBytes())
                dataStore.updateData { settings }
                true
            } else {
                false
            }
        } catch (e: Exception) {
            Log.e(TAG, "Failed to restore from backup", e)
            false
        }
    }
}
```

## 性能优化

### 1. 读取优化
- **批量读取**: 一次性读取多个配置项
- **缓存策略**: 合理使用 StateFlow 缓存
- **懒加载**: 按需加载配置数据

### 2. 写入优化
- **批量更新**: 合并多个配置更新
- **防抖动**: 避免频繁写入
- **异步写入**: 所有写入操作异步执行

### 3. 内存优化
- **及时释放**: 不用的配置数据及时释放
- **弱引用**: 对大对象使用弱引用
- **内存监控**: 监控配置数据内存使用

## 错误处理和恢复

### 1. 数据损坏处理
```kotlin
val dataStore = DataStoreFactory.create(
    serializer = UserSettingsSerializer,
    corruptionHandler = ReplaceFileCorruptionHandler { exception ->
        Log.e(TAG, "Settings corrupted, using defaults", exception)
        UserSettingsSerializer.defaultValue
    }
)
```

### 2. 迁移失败处理
```kotlin
private fun handleMigrationFailure(exception: Exception): UserSettings {
    Log.w(TAG, "Migration failed, using defaults", exception)
    return UserSettings.getDefaultInstance()
}
```

### 3. 配置验证
```kotlin
fun UserSettings.validate(): UserSettings {
    val builder = toBuilder()
    
    // 验证语言设置
    if (language == Language.UNRECOGNIZED) {
        builder.setLanguage(Language.LANGUAGE_SYSTEM)
    }
    
    // 验证主题设置
    if (theme == Theme.UNRECOGNIZED) {
        builder.setTheme(Theme.THEME_SYSTEM)
    }
    
    return builder.build()
}
```

通过现代化的数据存储方案，Dicio 实现了类型安全、响应式、高性能的配置管理系统，为用户提供了稳定可靠的个性化体验。

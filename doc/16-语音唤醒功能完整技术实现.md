# Dicio è¯­éŸ³å”¤é†’åŠŸèƒ½å®Œæ•´æŠ€æœ¯å®ç°

## æ¦‚è¿°

æœ¬æ–‡æ¡£è¯¦ç»†åˆ†æäº†Dicioé¡¹ç›®ä¸­è¯­éŸ³å”¤é†’åŠŸèƒ½çš„å®Œæ•´æŠ€æœ¯å®ç°ï¼ŒåŒ…æ‹¬æ¶æ„è®¾è®¡ã€æ ¸å¿ƒç®—æ³•ã€çŠ¶æ€ç®¡ç†ã€éŸ³é¢‘å¤„ç†æµç¨‹ç­‰æ‰€æœ‰æŠ€æœ¯ç»†èŠ‚ã€‚

## 1. ç³»ç»Ÿæ¶æ„

### 1.1 æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Dicio è¯­éŸ³å”¤é†’ç³»ç»Ÿ                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  UI Layer                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ MainActivityâ”‚  â”‚  HomeScreen â”‚  â”‚  SettingsScreen     â”‚  â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚                     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Service Layer                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                WakeService                              â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚AudioRecord  â”‚  â”‚FrameBuffer  â”‚  â”‚ BackoffManager  â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Device Abstraction Layer                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              WakeDeviceWrapper                          â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚ â”‚
â”‚  â”‚  â”‚   WakeDevice    â”‚  â”‚      StateFlow<WakeState>   â”‚   â”‚ â”‚
â”‚  â”‚  â”‚   Interface     â”‚  â”‚                             â”‚   â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Implementation Layer                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚              OpenWakeWordDevice                         â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚  OwwModel   â”‚  â”‚ModelManager â”‚  â”‚  AssetManager   â”‚ â”‚ â”‚
â”‚  â”‚  â”‚(TF Lite)    â”‚  â”‚             â”‚  â”‚                 â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Core Processing Layer                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                   OwwModel                              â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚Mel Spectro- â”‚  â”‚ Embedding   â”‚  â”‚  Wake Word      â”‚ â”‚ â”‚
â”‚  â”‚  â”‚gram Model   â”‚  â”‚   Model     â”‚  â”‚    Model        â”‚ â”‚ â”‚
â”‚  â”‚  â”‚(TF Lite)    â”‚  â”‚ (TF Lite)   â”‚  â”‚  (TF Lite)      â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æ ¸å¿ƒç»„ä»¶å…³ç³»

```kotlin
// ä¾èµ–æ³¨å…¥å…³ç³»
WakeService
    â”œâ”€â”€ WakeDeviceWrapper (æ³¨å…¥)
    â”œâ”€â”€ SttInputDeviceWrapper (æ³¨å…¥)
    â””â”€â”€ SkillEvaluator (æ³¨å…¥)

WakeDeviceWrapper
    â””â”€â”€ OpenWakeWordDevice (å®ç°)

OpenWakeWordDevice
    â”œâ”€â”€ OwwModel (ç»„åˆ)
    â”œâ”€â”€ AssetModelManager (ä½¿ç”¨)
    â””â”€â”€ OkHttpClient (æ³¨å…¥)

OwwModel
    â”œâ”€â”€ melInterpreter: Interpreter (TensorFlow Lite)
    â”œâ”€â”€ embInterpreter: Interpreter (TensorFlow Lite)
    â””â”€â”€ wakeInterpreter: Interpreter (TensorFlow Lite)
```

## 2. æ ¸å¿ƒæ¥å£è®¾è®¡

### 2.1 WakeDevice æ¥å£

```kotlin
interface WakeDevice {
    val state: StateFlow<WakeState>
    
    fun download()
    fun processFrame(audio16bitPcm: ShortArray): Boolean
    fun frameSize(): Int
    fun destroy()
    fun isHeyDicio(): Boolean
}
```

**è®¾è®¡ç†å¿µ:**
- **çŠ¶æ€é©±åŠ¨**: é€šè¿‡ `StateFlow<WakeState>` æä¾›å“åº”å¼çŠ¶æ€ç®¡ç†
- **å¸§å¤„ç†**: `processFrame()` æ˜¯æ ¸å¿ƒéŸ³é¢‘å¤„ç†æ¥å£ï¼Œè¿”å›å¸ƒå°”å€¼è¡¨ç¤ºæ˜¯å¦æ£€æµ‹åˆ°å”¤é†’è¯
- **èµ„æºç®¡ç†**: `destroy()` ç¡®ä¿æ¨¡å‹èµ„æºæ­£ç¡®é‡Šæ”¾
- **é…ç½®è¯†åˆ«**: `isHeyDicio()` åŒºåˆ†é»˜è®¤å”¤é†’è¯å’Œè‡ªå®šä¹‰å”¤é†’è¯

### 2.2 WakeState çŠ¶æ€æœº

```kotlin
sealed interface WakeState {
    data object NoMicOrNotificationPermission : WakeState
    data object NotDownloaded : WakeState
    data class Downloading(val progress: Progress) : WakeState
    data class ErrorDownloading(val throwable: Throwable) : WakeState
    data object NotLoaded : WakeState
    data object Loading : WakeState
    data class ErrorLoading(val throwable: Throwable) : WakeState
    data object Loaded : WakeState
}
```

**çŠ¶æ€è½¬æ¢å›¾:**
```
NoMicOrNotificationPermission
    â†“ (æƒé™æˆäºˆ)
NotDownloaded
    â†“ (å¼€å§‹ä¸‹è½½)
Downloading(progress)
    â†“ (ä¸‹è½½å®Œæˆ)        â†“ (ä¸‹è½½å¤±è´¥)
NotLoaded         ErrorDownloading
    â†“ (å¼€å§‹åŠ è½½)
Loading
    â†“ (åŠ è½½å®Œæˆ)        â†“ (åŠ è½½å¤±è´¥)
Loaded            ErrorLoading
```

## 3. OpenWakeWord æŠ€æœ¯å®ç°

### 3.1 ä¸‰é˜¶æ®µç¥ç»ç½‘ç»œæ¶æ„

OpenWakeWord ä½¿ç”¨ä¸‰ä¸ªç‹¬ç«‹çš„ TensorFlow Lite æ¨¡å‹ç»„æˆæµæ°´çº¿ï¼š

#### 3.1.1 Mel Spectrogram æ¨¡å‹
```kotlin
// æ¨¡å‹è§„æ ¼
const val MEL_INPUT_COUNT = 1152        // è¾“å…¥: 1152 ä¸ªéŸ³é¢‘æ ·æœ¬ (72ms @ 16kHz)
const val MEL_OUTPUT_COUNT = 5          // è¾“å‡º: 5 ä¸ªæ—¶é—´å¸§
const val MEL_FEATURE_SIZE = 32         // ç‰¹å¾ç»´åº¦: 32

// æ¨¡å‹å½¢çŠ¶: [1, 1152] -> [1, 1, 5, 32]
```

**åŠŸèƒ½**: å°†åŸå§‹éŸ³é¢‘ä¿¡å·è½¬æ¢ä¸ºæ¢…å°”é¢‘è°±å›¾ç‰¹å¾
**è¾“å…¥**: 1152ä¸ª16ä½PCMéŸ³é¢‘æ ·æœ¬ (72æ¯«ç§’)
**è¾“å‡º**: 5Ã—32çš„æ¢…å°”é¢‘è°±ç‰¹å¾çŸ©é˜µ

#### 3.1.2 Embedding æ¨¡å‹
```kotlin
// æ¨¡å‹è§„æ ¼
const val EMB_INPUT_COUNT = 76          // è¾“å…¥: 76 ä¸ªæ—¶é—´å¸§
const val EMB_OUTPUT_COUNT = 1          // è¾“å‡º: 1 ä¸ªæ—¶é—´å¸§
const val EMB_FEATURE_SIZE = 96         // ç‰¹å¾ç»´åº¦: 96

// æ¨¡å‹å½¢çŠ¶: [1, 76, 32, 1] -> [1, 1, 1, 96]
```

**åŠŸèƒ½**: å°†æ¢…å°”é¢‘è°±ç‰¹å¾ç¼–ç ä¸ºé«˜çº§è¯­ä¹‰åµŒå…¥
**è¾“å…¥**: 76Ã—32çš„ç´¯ç§¯æ¢…å°”é¢‘è°±ç‰¹å¾
**è¾“å‡º**: 1Ã—96çš„è¯­ä¹‰åµŒå…¥å‘é‡

#### 3.1.3 Wake Word æ¨¡å‹
```kotlin
// æ¨¡å‹è§„æ ¼
const val WAKE_INPUT_COUNT = 16         // è¾“å…¥: 16 ä¸ªæ—¶é—´å¸§

// æ¨¡å‹å½¢çŠ¶: [1, 16, 96] -> [1, 1]
```

**åŠŸèƒ½**: åŸºäºè¯­ä¹‰åµŒå…¥åºåˆ—æ£€æµ‹ç‰¹å®šå”¤é†’è¯
**è¾“å…¥**: 16Ã—96çš„ç´¯ç§¯åµŒå…¥ç‰¹å¾
**è¾“å‡º**: å•ä¸ªç½®ä¿¡åº¦åˆ†æ•° (0.0-1.0)

### 3.2 éŸ³é¢‘å¤„ç†æµæ°´çº¿

```kotlin
fun processFrame(audio: FloatArray): Float {
    synchronized(this) {
        // ç¬¬ä¸€é˜¶æ®µ: Mel Spectrogram å¤„ç†
        val melOutput = Array(MEL_OUTPUT_COUNT) { FloatArray(MEL_FEATURE_SIZE) }
        melInterpreter.run(arrayOf(audio), arrayOf(arrayOf(melOutput)))
        
        // ç´¯ç§¯ Mel è¾“å‡º (æ»‘åŠ¨çª—å£)
        for (i in 0..<EMB_INPUT_COUNT) {
            accumulatedMelOutputs[i] = if (i < EMB_INPUT_COUNT - MEL_OUTPUT_COUNT) {
                accumulatedMelOutputs[i + MEL_OUTPUT_COUNT]  // å·¦ç§»
            } else {
                melOutput[i - EMB_INPUT_COUNT + MEL_OUTPUT_COUNT]
                    .map { floatArrayOf((it / 10.0f) + 2.0f) }  // å½’ä¸€åŒ–
                    .toTypedArray()
            }
        }
        
        // ç¬¬äºŒé˜¶æ®µ: Embedding å¤„ç†
        val embOutput = Array(EMB_OUTPUT_COUNT) { FloatArray(EMB_FEATURE_SIZE) }
        embInterpreter.run(arrayOf(accumulatedMelOutputs), arrayOf(arrayOf(embOutput)))
        
        // ç´¯ç§¯ Embedding è¾“å‡º (æ»‘åŠ¨çª—å£)
        for (i in 0..<WAKE_INPUT_COUNT) {
            accumulatedEmbOutputs[i] = if (i < WAKE_INPUT_COUNT - EMB_OUTPUT_COUNT) {
                accumulatedEmbOutputs[i + EMB_OUTPUT_COUNT]  // å·¦ç§»
            } else {
                embOutput[i - WAKE_INPUT_COUNT + EMB_OUTPUT_COUNT]
            }
        }
        
        // ç¬¬ä¸‰é˜¶æ®µ: Wake Word æ£€æµ‹
        val wakeOutput = FloatArray(1)
        wakeInterpreter.run(arrayOf(accumulatedEmbOutputs), arrayOf(wakeOutput))
        
        return wakeOutput[0]  // è¿”å›ç½®ä¿¡åº¦åˆ†æ•°
    }
}
```

### 3.3 æ»‘åŠ¨çª—å£æœºåˆ¶

ç³»ç»Ÿä½¿ç”¨ä¸¤çº§æ»‘åŠ¨çª—å£æ¥ç»´æŠ¤æ—¶é—´ä¸Šä¸‹æ–‡ï¼š

#### Mel ç‰¹å¾çª—å£ (76 å¸§)
```kotlin
private var accumulatedMelOutputs: Array<Array<FloatArray>> = Array(EMB_INPUT_COUNT) { arrayOf() }
```

#### Embedding ç‰¹å¾çª—å£ (16 å¸§)
```kotlin
private var accumulatedEmbOutputs: Array<FloatArray> = Array(WAKE_INPUT_COUNT) { floatArrayOf() }
```

**çª—å£æ›´æ–°ç­–ç•¥:**
1. æ¯æ¬¡æ–°å¸§åˆ°è¾¾æ—¶ï¼Œçª—å£å†…å®¹å·¦ç§»
2. æ–°ç‰¹å¾æ·»åŠ åˆ°çª—å£å³ç«¯
3. ä¿æŒå›ºå®šçª—å£å¤§å°ï¼Œè‡ªåŠ¨ä¸¢å¼ƒæœ€æ—§çš„ç‰¹å¾

## 4. WakeService åå°æœåŠ¡å®ç°

### 4.1 æœåŠ¡ç”Ÿå‘½å‘¨æœŸç®¡ç†

```kotlin
class WakeService : Service() {
    private val scope = CoroutineScope(Dispatchers.Default)
    private val listening = AtomicBoolean(false)
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // æƒé™æ£€æŸ¥
        if (ContextCompat.checkSelfPermission(this, RECORD_AUDIO) != PERMISSION_GRANTED) {
            stopWithMessage("Microphone permission not granted")
            return START_NOT_STICKY
        }
        
        // çŠ¶æ€æ£€æŸ¥
        when (wakeDevice.state.value) {
            WakeState.NotLoaded, WakeState.Loading, WakeState.Loaded -> {
                // å¯ä»¥å¯åŠ¨ç›‘å¬
            }
            else -> {
                stopWithMessage("Wake word device not ready")
                return START_NOT_STICKY
            }
        }
        
        // å¯åŠ¨éŸ³é¢‘ç›‘å¬
        scope.launch {
            try {
                listenForWakeWord()
            } catch (t: Throwable) {
                stopWithMessage("Cannot continue listening", t)
            }
        }
        
        return START_STICKY
    }
}
```

### 4.2 éŸ³é¢‘å½•åˆ¶ä¸å¤„ç†å¾ªç¯

```kotlin
private fun listenForWakeWord() {
    // åˆ›å»ºä¼˜åŒ–çš„ AudioRecord
    val ar = createOptimalAudioRecord() ?: return
    
    var audio = ShortArray(0)
    var nextWakeWordAllowed = Instant.MIN
    var frameCount = 0
    
    try {
        ar.startRecording()
        
        while (listening.get()) {
            // åŠ¨æ€è°ƒæ•´ç¼“å†²åŒºå¤§å°
            if (audio.size != wakeDevice.frameSize()) {
                audio = ShortArray(wakeDevice.frameSize())
            }
            
            // è¯»å–éŸ³é¢‘æ•°æ®
            val bytesRead = ar.read(audio, 0, audio.size)
            frameCount++
            
            if (bytesRead > 0) {
                // å¤„ç†éŸ³é¢‘å¸§
                val wakeWordDetected = wakeDevice.processFrame(audio)
                val now = Instant.now()
                
                // åº”ç”¨é€€é¿æœºåˆ¶é˜²æ­¢é‡å¤è§¦å‘
                if (wakeWordDetected && now > nextWakeWordAllowed) {
                    nextWakeWordAllowed = now.plusMillis(WAKE_WORD_BACKOFF_MILLIS)
                    onWakeWordDetected()
                }
                
                lastHeard.set(now)
            }
        }
    } finally {
        ar.stop()
        ar.release()
    }
}
```

### 4.3 AudioRecord ä¼˜åŒ–é…ç½®

```kotlin
@SuppressLint("MissingPermission")
private fun createOptimalAudioRecord(): AudioRecord? {
    val audioSources = arrayOf(
        MediaRecorder.AudioSource.VOICE_RECOGNITION,
        MediaRecorder.AudioSource.MIC,
        MediaRecorder.AudioSource.DEFAULT,
        MediaRecorder.AudioSource.VOICE_COMMUNICATION
    )
    
    val bufferSizes = arrayOf(6400, 3200, 1600, 8000)
    
    for (source in audioSources) {
        for (bufferSize in bufferSizes) {
            try {
                val ar = AudioRecord(
                    source,
                    16000,  // é‡‡æ ·ç‡
                    AudioFormat.CHANNEL_IN_MONO,
                    AudioFormat.ENCODING_PCM_16BIT,
                    bufferSize
                )
                
                if (ar.state == AudioRecord.STATE_INITIALIZED) {
                    // æµ‹è¯•å½•åˆ¶åŠŸèƒ½
                    if (testAudioRecord(ar)) {
                        return ar
                    }
                }
                ar.release()
            } catch (e: Exception) {
                // å°è¯•ä¸‹ä¸€ä¸ªé…ç½®
            }
        }
    }
    
    return null
}
```

## 5. çŠ¶æ€ç®¡ç†ä¸å“åº”å¼æ¶æ„

### 5.1 WakeDeviceWrapper çŠ¶æ€åè°ƒ

```kotlin
class WakeDeviceWrapperImpl : WakeDeviceWrapper {
    private val _state: MutableStateFlow<WakeState?> = MutableStateFlow(null)
    override val state: StateFlow<WakeState?> = _state
    
    private val currentDevice: MutableStateFlow<WakeDevice?>
    
    init {
        // ç›‘å¬è®¾å¤‡çŠ¶æ€å˜åŒ–
        scope.launch {
            currentDevice.collectLatest { newWakeDevice ->
                if (newWakeDevice == null) {
                    _state.emit(null)
                } else {
                    newWakeDevice.state.collect { _state.emit(it) }
                }
            }
        }
        
        // ç›‘å¬ç”¨æˆ·è®¾ç½®å˜åŒ–
        scope.launch {
            dataStore.data
                .map { it.wakeDevice }
                .distinctUntilChanged()
                .collect(::changeWakeDeviceTo)
        }
    }
}
```

### 5.2 UI å±‚çŠ¶æ€ç»‘å®š

```kotlin
// MainActivity ä¸­çš„çŠ¶æ€ç›‘å¬
wakeServiceJob = lifecycleScope.launch {
    wakeDevice.state
        .map { it == NotLoaded || it == Loading || it == Loaded }
        .combine(
            PermissionFlow.getInstance().getMultiplePermissionState(*wakeWordPermissions)
        ) { wakeState, permGranted ->
            wakeState && permGranted.allGranted
        }
        .distinctUntilChanged()
        .filter { it }
        .collect { WakeService.start(this@MainActivity) }
}
```

## 6. æ¨¡å‹ç®¡ç†ä¸èµ„æºä¼˜åŒ–

### 6.1 é¢„æ‰“åŒ…æ¨¡å‹ç³»ç»Ÿ

```kotlin
object AssetModelManager {
    fun hasOpenWakeWordModelsInAssets(context: Context): Boolean {
        return try {
            val assetManager = context.assets
            val melExists = assetManager.list("models/openWakeWord")?.contains("melspectrogram.tflite") == true
            val embExists = assetManager.list("models/openWakeWord")?.contains("embedding.tflite") == true
            val wakeExists = assetManager.list("models/openWakeWord")?.contains("wake.tflite") == true
            melExists && embExists && wakeExists
        } catch (e: Exception) {
            false
        }
    }
    
    fun copyOpenWakeWordModels(context: Context): Boolean {
        return try {
            val modelFiles = listOf(
                "melspectrogram.tflite",
                "embedding.tflite", 
                "wake.tflite"
            )
            
            modelFiles.all { fileName ->
                copyAssetToFile(
                    context,
                    "models/openWakeWord/$fileName",
                    File(context.filesDir, "oww/$fileName")
                )
            }
        } catch (e: Exception) {
            false
        }
    }
}
```

### 6.2 æ¨¡å‹ä¸‹è½½ä¸ç¼“å­˜

```kotlin
class OpenWakeWordDevice {
    override fun download() {
        _state.value = WakeState.Downloading(Progress.UNKNOWN)
        
        scope.launch {
            try {
                // ä¼˜å…ˆä½¿ç”¨é¢„æ‰“åŒ…æ¨¡å‹
                if (AssetModelManager.hasOpenWakeWordModelsInAssets(appContext)) {
                    val copySuccess = AssetModelManager.copyOpenWakeWordModels(appContext)
                    if (copySuccess) {
                        _state.value = WakeState.NotLoaded
                        return@launch
                    }
                }
                
                // ç½‘ç»œä¸‹è½½å¤‡ç”¨æ–¹æ¡ˆ
                owwFolder.mkdirs()
                downloadBinaryFilesWithPartial(
                    urlsFiles = allModelFiles,
                    httpClient = okHttpClient,
                    cacheDir = cacheDir,
                ) { progress ->
                    _state.value = WakeState.Downloading(progress)
                }
                
                _state.value = WakeState.NotLoaded
            } catch (e: Throwable) {
                _state.value = WakeState.ErrorDownloading(e)
            }
        }
    }
}
```

## 7. éŸ³é¢‘æ•°æ®å¤„ç†

### 7.1 éŸ³é¢‘æ ¼å¼è½¬æ¢

```kotlin
override fun processFrame(audio16bitPcm: ShortArray): Boolean {
    // éªŒè¯å¸§å¤§å°
    if (audio16bitPcm.size != OwwModel.MEL_INPUT_COUNT) {
        throw IllegalArgumentException("Invalid frame size: ${audio16bitPcm.size}")
    }
    
    // 16ä½PCMè½¬æµ®ç‚¹æ•° (-1.0 åˆ° 1.0)
    for (i in 0..<OwwModel.MEL_INPUT_COUNT) {
        audio[i] = audio16bitPcm[i].toFloat() / 32768.0f
    }
    
    // è®¡ç®—éŸ³é¢‘å¹…åº¦ç”¨äºè°ƒè¯•
    val amplitude = audio.maxOf { kotlin.math.abs(it) }
    
    // æ¨¡å‹æ¨ç†
    val confidence = model!!.processFrame(audio)
    
    // é˜ˆå€¼åˆ¤æ–­
    val threshold = 0.01f
    val detected = confidence > threshold
    
    return detected
}
```

### 7.2 å®æ—¶æ€§èƒ½ä¼˜åŒ–

```kotlin
// æ€§èƒ½ç›‘æ§
inline fun <T> measureTimeAndLog(tag: String?, operation: String, block: () -> T): T {
    val startTime = System.currentTimeMillis()
    val result = block()
    val endTime = System.currentTimeMillis()
    DebugLogger.logPerformance(tag, operation, endTime - startTime)
    return result
}

// ä½¿ç”¨ç¤ºä¾‹
val confidence = measureTimeAndLog(TAG, "Process audio frame") {
    model!!.processFrame(audio)
}
```

## 8. é”™è¯¯å¤„ç†ä¸æ¢å¤æœºåˆ¶

### 8.1 æ¨¡å‹åŠ è½½é”™è¯¯å¤„ç†

```kotlin
try {
    model = OwwModel(
        melFile.file,
        embFile.file,
        if (userWakeFileExists) userWakeFile else wakeFile.file,
    )
    _state.value = WakeState.Loaded
} catch (t: Throwable) {
    _state.value = WakeState.ErrorLoading(t)
    return false
}
```

### 8.2 éŸ³é¢‘å½•åˆ¶é”™è¯¯æ¢å¤

```kotlin
private fun listenForWakeWord() {
    try {
        ar.startRecording()
        
        while (listening.get()) {
            val bytesRead = ar.read(audio, 0, audio.size)
            
            if (bytesRead > 0) {
                // æ­£å¸¸å¤„ç†
                val wakeWordDetected = wakeDevice.processFrame(audio)
                // ...
            } else {
                // å½•åˆ¶å¤±è´¥ï¼Œè®°å½•é”™è¯¯ä½†ç»§ç»­å°è¯•
                DebugLogger.logWakeWordError(TAG, "AudioRecord read failed: $bytesRead bytes")
            }
        }
    } catch (e: Exception) {
        DebugLogger.logWakeWordError(TAG, "Error in wake word listening", e)
        throw e  // é‡æ–°æŠ›å‡ºï¼Œè§¦å‘æœåŠ¡é‡å¯
    } finally {
        ar.stop()
        ar.release()
    }
}
```

## 9. è°ƒè¯•ä¸ç›‘æ§ç³»ç»Ÿ

### 9.1 åˆ†ç±»è°ƒè¯•æ—¥å¿—

```kotlin
object DebugLogger {
    private const val DEBUG_ENABLED = true
    private const val DEBUG_WAKE_WORD = DEBUG_ENABLED && true
    private const val DEBUG_AUDIO_PROCESSING = DEBUG_ENABLED && true
    
    fun logWakeWordDetection(tag: String?, confidence: Float, threshold: Float, detected: Boolean) {
        if (DEBUG_WAKE_WORD && tag != null) {
            val status = if (detected) "âœ… DETECTED" else "âŒ NOT_DETECTED"
            Log.d("ğŸ¯[$tag]", "$status - Confidence: %.3f, Threshold: %.3f".format(confidence, threshold))
        }
    }
    
    fun logAudioStats(tag: String?, frameSize: Int, amplitude: Float, threshold: Float) {
        if (DEBUG_AUDIO_PROCESSING && tag != null) {
            Log.d("ğŸ“Š[$tag]", "Frame: $frameSize, Amplitude: %.3f, Threshold: %.3f".format(amplitude, threshold))
        }
    }
}
```

### 9.2 æ€§èƒ½ç›‘æ§

```kotlin
// å¸§å¤„ç†æ€§èƒ½ç»Ÿè®¡
val confidence = measureTimeAndLog(TAG, "Process audio frame") {
    model!!.processFrame(audio)
}

// æ¨¡å‹åŠ è½½æ€§èƒ½ç»Ÿè®¡  
model = measureTimeAndLog(TAG, "Load OWW model") {
    OwwModel(melFile.file, embFile.file, wakeFile.file)
}
```

## 10. é›†æˆä¸äº¤äº’æµç¨‹

### 10.1 å”¤é†’è¯æ£€æµ‹åˆ°è¯­éŸ³è¯†åˆ«æµç¨‹

```kotlin
private fun onWakeWordDetected() {
    // 1. åˆ›å»ºMainActivityæ„å›¾
    val intent = Intent(this, MainActivity::class.java)
    intent.setAction(ACTION_WAKE_WORD)
    intent.setFlags(FLAG_ACTIVITY_NEW_TASK)
    
    // 2. å¯åŠ¨STTè¾“å…¥è®¾å¤‡
    val sttStarted = sttInputDevice.tryLoad(skillEvaluator::processInputEvent)
    
    // 3. è®¾ç½®STTèµ„æºé‡Šæ”¾å®šæ—¶å™¨
    handler.removeCallbacks(releaseSttResourcesRunnable)
    handler.postDelayed(releaseSttResourcesRunnable, RELEASE_STT_RESOURCES_MILLIS)
    
    // 4. å¯åŠ¨MainActivity
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q || MainActivity.isInForeground > 0) {
        startActivity(intent)
    } else {
        // Android 10+ ä½¿ç”¨é€šçŸ¥æ–¹å¼å¯åŠ¨
        showTriggeredNotification()
    }
}
```

### 10.2 MainActivity å“åº”å¤„ç†

```kotlin
private fun handleWakeWordTurnOnScreen(intent: Intent?) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O_MR1 &&
        intent?.action == ACTION_WAKE_WORD
    ) {
        // å”¤é†’å±å¹•
        setShowWhenLocked(true)
        setTurnScreenOn(true)
    }
    
    // å–æ¶ˆå”¤é†’é€šçŸ¥
    WakeService.cancelTriggeredNotification(this)
}
```

## 11. æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 11.1 å†…å­˜ç®¡ç†
- **æ¨¡å‹æ‡’åŠ è½½**: ä»…åœ¨éœ€è¦æ—¶åŠ è½½TensorFlow Liteæ¨¡å‹
- **èµ„æºé‡Šæ”¾**: åŠæ—¶é‡Šæ”¾AudioRecordå’Œæ¨¡å‹èµ„æº
- **ç¼“å†²åŒºå¤ç”¨**: å¤ç”¨éŸ³é¢‘ç¼“å†²åŒºé¿å…é¢‘ç¹åˆ†é…

### 11.2 CPUä¼˜åŒ–
- **å¼‚æ­¥å¤„ç†**: ä½¿ç”¨åç¨‹è¿›è¡Œéé˜»å¡æ“ä½œ
- **å¸§ç‡æ§åˆ¶**: 72mså¸§é—´éš”å¹³è¡¡æ€§èƒ½å’Œå“åº”æ€§
- **æ»‘åŠ¨çª—å£**: é«˜æ•ˆçš„ç‰¹å¾ç´¯ç§¯æœºåˆ¶

### 11.3 ç”µæ± ä¼˜åŒ–
- **å‰å°æœåŠ¡**: åˆç†ä½¿ç”¨å‰å°æœåŠ¡é¿å…è¢«ç³»ç»Ÿæ€æ­»
- **é€€é¿æœºåˆ¶**: é˜²æ­¢é‡å¤è§¦å‘æµªè´¹èµ„æº
- **æƒé™æ£€æŸ¥**: åŠæ—¶åœæ­¢æ— æƒé™æœåŠ¡

## 12. æŠ€æœ¯ç‰¹ç‚¹æ€»ç»“

### 12.1 åˆ›æ–°ç‚¹
1. **ä¸‰é˜¶æ®µç¥ç»ç½‘ç»œ**: Mel â†’ Embedding â†’ Wake Word çš„æ¸è¿›å¼ç‰¹å¾æå–
2. **æ»‘åŠ¨çª—å£æœºåˆ¶**: é«˜æ•ˆçš„æ—¶é—´ä¸Šä¸‹æ–‡ç®¡ç†
3. **é¢„æ‰“åŒ…æ¨¡å‹**: é›¶ç½‘ç»œä¾èµ–çš„æ¨¡å‹åˆ†å‘
4. **å“åº”å¼æ¶æ„**: StateFlowé©±åŠ¨çš„çŠ¶æ€ç®¡ç†

### 12.2 æŠ€æœ¯ä¼˜åŠ¿
1. **é«˜å‡†ç¡®ç‡**: åŸºäºæ·±åº¦å­¦ä¹ çš„å”¤é†’è¯æ£€æµ‹
2. **ä½å»¶è¿Ÿ**: 72mså¸§å¤„ç†é—´éš”ï¼Œå®æ—¶å“åº”
3. **å¯æ‰©å±•**: æ”¯æŒè‡ªå®šä¹‰å”¤é†’è¯æ¨¡å‹
4. **å¥å£®æ€§**: å®Œå–„çš„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶

### 12.3 æ¶æ„ä¼˜åŠ¿
1. **æ¨¡å—åŒ–è®¾è®¡**: æ¸…æ™°çš„æ¥å£åˆ†ç¦»å’Œä¾èµ–æ³¨å…¥
2. **çŠ¶æ€é©±åŠ¨**: å“åº”å¼çŠ¶æ€ç®¡ç†ç¡®ä¿UIä¸€è‡´æ€§
3. **èµ„æºé«˜æ•ˆ**: æ™ºèƒ½çš„æ¨¡å‹åŠ è½½å’Œå†…å­˜ç®¡ç†
4. **è°ƒè¯•å‹å¥½**: å®Œå–„çš„æ—¥å¿—ç³»ç»Ÿå’Œæ€§èƒ½ç›‘æ§

## ç»“è®º

Dicioçš„è¯­éŸ³å”¤é†’åŠŸèƒ½å±•ç°äº†ç°ä»£Androidåº”ç”¨ä¸­AIé›†æˆçš„æœ€ä½³å®è·µã€‚é€šè¿‡åˆç†çš„æ¶æ„è®¾è®¡ã€é«˜æ•ˆçš„ç®—æ³•å®ç°å’Œå®Œå–„çš„å·¥ç¨‹åŒ–æªæ–½ï¼Œç³»ç»Ÿå®ç°äº†é«˜æ€§èƒ½ã€ä½åŠŸè€—çš„å®æ—¶è¯­éŸ³å”¤é†’åŠŸèƒ½ã€‚è¯¥å®ç°ä¸ä»…æŠ€æœ¯å…ˆè¿›ï¼Œè€Œä¸”å…·æœ‰è‰¯å¥½çš„å¯ç»´æŠ¤æ€§å’Œå¯æ‰©å±•æ€§ï¼Œä¸ºç±»ä¼¼é¡¹ç›®æä¾›äº†å®è´µçš„å‚è€ƒä»·å€¼ã€‚

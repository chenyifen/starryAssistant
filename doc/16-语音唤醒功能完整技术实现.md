# Dicio 语音唤醒功能完整技术实现

## 概述

本文档详细分析了Dicio项目中语音唤醒功能的完整技术实现，包括架构设计、核心算法、状态管理、音频处理流程等所有技术细节。

## 1. 系统架构

### 1.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    Dicio 语音唤醒系统                        │
├─────────────────────────────────────────────────────────────┤
│  UI Layer                                                   │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │ MainActivity│  │  HomeScreen │  │  SettingsScreen     │  │
│  │             │  │             │  │                     │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
├─────────────────────────────────────────────────────────────┤
│  Service Layer                                              │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                WakeService                              │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐ │ │
│  │  │AudioRecord  │  │FrameBuffer  │  │ BackoffManager  │ │ │
│  │  └─────────────┘  └─────────────┘  └─────────────────┘ │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Device Abstraction Layer                                   │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              WakeDeviceWrapper                          │ │
│  │  ┌─────────────────┐  ┌─────────────────────────────┐   │ │
│  │  │   WakeDevice    │  │      StateFlow<WakeState>   │   │ │
│  │  │   Interface     │  │                             │   │ │
│  │  └─────────────────┘  └─────────────────────────────┘   │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Implementation Layer                                       │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              OpenWakeWordDevice                         │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐ │ │
│  │  │  OwwModel   │  │ModelManager │  │  AssetManager   │ │ │
│  │  │(TF Lite)    │  │             │  │                 │ │ │
│  │  └─────────────┘  └─────────────┘  └─────────────────┘ │ │
│  └─────────────────────────────────────────────────────────┘ │
├─────────────────────────────────────────────────────────────┤
│  Core Processing Layer                                      │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                   OwwModel                              │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────┐ │ │
│  │  │Mel Spectro- │  │ Embedding   │  │  Wake Word      │ │ │
│  │  │gram Model   │  │   Model     │  │    Model        │ │ │
│  │  │(TF Lite)    │  │ (TF Lite)   │  │  (TF Lite)      │ │ │
│  │  └─────────────┘  └─────────────┘  └─────────────────┘ │ │
│  └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 核心组件关系

```kotlin
// 依赖注入关系
WakeService
    ├── WakeDeviceWrapper (注入)
    ├── SttInputDeviceWrapper (注入)
    └── SkillEvaluator (注入)

WakeDeviceWrapper
    └── OpenWakeWordDevice (实现)

OpenWakeWordDevice
    ├── OwwModel (组合)
    ├── AssetModelManager (使用)
    └── OkHttpClient (注入)

OwwModel
    ├── melInterpreter: Interpreter (TensorFlow Lite)
    ├── embInterpreter: Interpreter (TensorFlow Lite)
    └── wakeInterpreter: Interpreter (TensorFlow Lite)
```

## 2. 核心接口设计

### 2.1 WakeDevice 接口

```kotlin
interface WakeDevice {
    val state: StateFlow<WakeState>
    
    fun download()
    fun processFrame(audio16bitPcm: ShortArray): Boolean
    fun frameSize(): Int
    fun destroy()
    fun isHeyDicio(): Boolean
}
```

**设计理念:**
- **状态驱动**: 通过 `StateFlow<WakeState>` 提供响应式状态管理
- **帧处理**: `processFrame()` 是核心音频处理接口，返回布尔值表示是否检测到唤醒词
- **资源管理**: `destroy()` 确保模型资源正确释放
- **配置识别**: `isHeyDicio()` 区分默认唤醒词和自定义唤醒词

### 2.2 WakeState 状态机

```kotlin
sealed interface WakeState {
    data object NoMicOrNotificationPermission : WakeState
    data object NotDownloaded : WakeState
    data class Downloading(val progress: Progress) : WakeState
    data class ErrorDownloading(val throwable: Throwable) : WakeState
    data object NotLoaded : WakeState
    data object Loading : WakeState
    data class ErrorLoading(val throwable: Throwable) : WakeState
    data object Loaded : WakeState
}
```

**状态转换图:**
```
NoMicOrNotificationPermission
    ↓ (权限授予)
NotDownloaded
    ↓ (开始下载)
Downloading(progress)
    ↓ (下载完成)        ↓ (下载失败)
NotLoaded         ErrorDownloading
    ↓ (开始加载)
Loading
    ↓ (加载完成)        ↓ (加载失败)
Loaded            ErrorLoading
```

## 3. OpenWakeWord 技术实现

### 3.1 三阶段神经网络架构

OpenWakeWord 使用三个独立的 TensorFlow Lite 模型组成流水线：

#### 3.1.1 Mel Spectrogram 模型
```kotlin
// 模型规格
const val MEL_INPUT_COUNT = 1152        // 输入: 1152 个音频样本 (72ms @ 16kHz)
const val MEL_OUTPUT_COUNT = 5          // 输出: 5 个时间帧
const val MEL_FEATURE_SIZE = 32         // 特征维度: 32

// 模型形状: [1, 1152] -> [1, 1, 5, 32]
```

**功能**: 将原始音频信号转换为梅尔频谱图特征
**输入**: 1152个16位PCM音频样本 (72毫秒)
**输出**: 5×32的梅尔频谱特征矩阵

#### 3.1.2 Embedding 模型
```kotlin
// 模型规格
const val EMB_INPUT_COUNT = 76          // 输入: 76 个时间帧
const val EMB_OUTPUT_COUNT = 1          // 输出: 1 个时间帧
const val EMB_FEATURE_SIZE = 96         // 特征维度: 96

// 模型形状: [1, 76, 32, 1] -> [1, 1, 1, 96]
```

**功能**: 将梅尔频谱特征编码为高级语义嵌入
**输入**: 76×32的累积梅尔频谱特征
**输出**: 1×96的语义嵌入向量

#### 3.1.3 Wake Word 模型
```kotlin
// 模型规格
const val WAKE_INPUT_COUNT = 16         // 输入: 16 个时间帧

// 模型形状: [1, 16, 96] -> [1, 1]
```

**功能**: 基于语义嵌入序列检测特定唤醒词
**输入**: 16×96的累积嵌入特征
**输出**: 单个置信度分数 (0.0-1.0)

### 3.2 音频处理流水线

```kotlin
fun processFrame(audio: FloatArray): Float {
    synchronized(this) {
        // 第一阶段: Mel Spectrogram 处理
        val melOutput = Array(MEL_OUTPUT_COUNT) { FloatArray(MEL_FEATURE_SIZE) }
        melInterpreter.run(arrayOf(audio), arrayOf(arrayOf(melOutput)))
        
        // 累积 Mel 输出 (滑动窗口)
        for (i in 0..<EMB_INPUT_COUNT) {
            accumulatedMelOutputs[i] = if (i < EMB_INPUT_COUNT - MEL_OUTPUT_COUNT) {
                accumulatedMelOutputs[i + MEL_OUTPUT_COUNT]  // 左移
            } else {
                melOutput[i - EMB_INPUT_COUNT + MEL_OUTPUT_COUNT]
                    .map { floatArrayOf((it / 10.0f) + 2.0f) }  // 归一化
                    .toTypedArray()
            }
        }
        
        // 第二阶段: Embedding 处理
        val embOutput = Array(EMB_OUTPUT_COUNT) { FloatArray(EMB_FEATURE_SIZE) }
        embInterpreter.run(arrayOf(accumulatedMelOutputs), arrayOf(arrayOf(embOutput)))
        
        // 累积 Embedding 输出 (滑动窗口)
        for (i in 0..<WAKE_INPUT_COUNT) {
            accumulatedEmbOutputs[i] = if (i < WAKE_INPUT_COUNT - EMB_OUTPUT_COUNT) {
                accumulatedEmbOutputs[i + EMB_OUTPUT_COUNT]  // 左移
            } else {
                embOutput[i - WAKE_INPUT_COUNT + EMB_OUTPUT_COUNT]
            }
        }
        
        // 第三阶段: Wake Word 检测
        val wakeOutput = FloatArray(1)
        wakeInterpreter.run(arrayOf(accumulatedEmbOutputs), arrayOf(wakeOutput))
        
        return wakeOutput[0]  // 返回置信度分数
    }
}
```

### 3.3 滑动窗口机制

系统使用两级滑动窗口来维护时间上下文：

#### Mel 特征窗口 (76 帧)
```kotlin
private var accumulatedMelOutputs: Array<Array<FloatArray>> = Array(EMB_INPUT_COUNT) { arrayOf() }
```

#### Embedding 特征窗口 (16 帧)
```kotlin
private var accumulatedEmbOutputs: Array<FloatArray> = Array(WAKE_INPUT_COUNT) { floatArrayOf() }
```

**窗口更新策略:**
1. 每次新帧到达时，窗口内容左移
2. 新特征添加到窗口右端
3. 保持固定窗口大小，自动丢弃最旧的特征

## 4. WakeService 后台服务实现

### 4.1 服务生命周期管理

```kotlin
class WakeService : Service() {
    private val scope = CoroutineScope(Dispatchers.Default)
    private val listening = AtomicBoolean(false)
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // 权限检查
        if (ContextCompat.checkSelfPermission(this, RECORD_AUDIO) != PERMISSION_GRANTED) {
            stopWithMessage("Microphone permission not granted")
            return START_NOT_STICKY
        }
        
        // 状态检查
        when (wakeDevice.state.value) {
            WakeState.NotLoaded, WakeState.Loading, WakeState.Loaded -> {
                // 可以启动监听
            }
            else -> {
                stopWithMessage("Wake word device not ready")
                return START_NOT_STICKY
            }
        }
        
        // 启动音频监听
        scope.launch {
            try {
                listenForWakeWord()
            } catch (t: Throwable) {
                stopWithMessage("Cannot continue listening", t)
            }
        }
        
        return START_STICKY
    }
}
```

### 4.2 音频录制与处理循环

```kotlin
private fun listenForWakeWord() {
    // 创建优化的 AudioRecord
    val ar = createOptimalAudioRecord() ?: return
    
    var audio = ShortArray(0)
    var nextWakeWordAllowed = Instant.MIN
    var frameCount = 0
    
    try {
        ar.startRecording()
        
        while (listening.get()) {
            // 动态调整缓冲区大小
            if (audio.size != wakeDevice.frameSize()) {
                audio = ShortArray(wakeDevice.frameSize())
            }
            
            // 读取音频数据
            val bytesRead = ar.read(audio, 0, audio.size)
            frameCount++
            
            if (bytesRead > 0) {
                // 处理音频帧
                val wakeWordDetected = wakeDevice.processFrame(audio)
                val now = Instant.now()
                
                // 应用退避机制防止重复触发
                if (wakeWordDetected && now > nextWakeWordAllowed) {
                    nextWakeWordAllowed = now.plusMillis(WAKE_WORD_BACKOFF_MILLIS)
                    onWakeWordDetected()
                }
                
                lastHeard.set(now)
            }
        }
    } finally {
        ar.stop()
        ar.release()
    }
}
```

### 4.3 AudioRecord 优化配置

```kotlin
@SuppressLint("MissingPermission")
private fun createOptimalAudioRecord(): AudioRecord? {
    val audioSources = arrayOf(
        MediaRecorder.AudioSource.VOICE_RECOGNITION,
        MediaRecorder.AudioSource.MIC,
        MediaRecorder.AudioSource.DEFAULT,
        MediaRecorder.AudioSource.VOICE_COMMUNICATION
    )
    
    val bufferSizes = arrayOf(6400, 3200, 1600, 8000)
    
    for (source in audioSources) {
        for (bufferSize in bufferSizes) {
            try {
                val ar = AudioRecord(
                    source,
                    16000,  // 采样率
                    AudioFormat.CHANNEL_IN_MONO,
                    AudioFormat.ENCODING_PCM_16BIT,
                    bufferSize
                )
                
                if (ar.state == AudioRecord.STATE_INITIALIZED) {
                    // 测试录制功能
                    if (testAudioRecord(ar)) {
                        return ar
                    }
                }
                ar.release()
            } catch (e: Exception) {
                // 尝试下一个配置
            }
        }
    }
    
    return null
}
```

## 5. 状态管理与响应式架构

### 5.1 WakeDeviceWrapper 状态协调

```kotlin
class WakeDeviceWrapperImpl : WakeDeviceWrapper {
    private val _state: MutableStateFlow<WakeState?> = MutableStateFlow(null)
    override val state: StateFlow<WakeState?> = _state
    
    private val currentDevice: MutableStateFlow<WakeDevice?>
    
    init {
        // 监听设备状态变化
        scope.launch {
            currentDevice.collectLatest { newWakeDevice ->
                if (newWakeDevice == null) {
                    _state.emit(null)
                } else {
                    newWakeDevice.state.collect { _state.emit(it) }
                }
            }
        }
        
        // 监听用户设置变化
        scope.launch {
            dataStore.data
                .map { it.wakeDevice }
                .distinctUntilChanged()
                .collect(::changeWakeDeviceTo)
        }
    }
}
```

### 5.2 UI 层状态绑定

```kotlin
// MainActivity 中的状态监听
wakeServiceJob = lifecycleScope.launch {
    wakeDevice.state
        .map { it == NotLoaded || it == Loading || it == Loaded }
        .combine(
            PermissionFlow.getInstance().getMultiplePermissionState(*wakeWordPermissions)
        ) { wakeState, permGranted ->
            wakeState && permGranted.allGranted
        }
        .distinctUntilChanged()
        .filter { it }
        .collect { WakeService.start(this@MainActivity) }
}
```

## 6. 模型管理与资源优化

### 6.1 预打包模型系统

```kotlin
object AssetModelManager {
    fun hasOpenWakeWordModelsInAssets(context: Context): Boolean {
        return try {
            val assetManager = context.assets
            val melExists = assetManager.list("models/openWakeWord")?.contains("melspectrogram.tflite") == true
            val embExists = assetManager.list("models/openWakeWord")?.contains("embedding.tflite") == true
            val wakeExists = assetManager.list("models/openWakeWord")?.contains("wake.tflite") == true
            melExists && embExists && wakeExists
        } catch (e: Exception) {
            false
        }
    }
    
    fun copyOpenWakeWordModels(context: Context): Boolean {
        return try {
            val modelFiles = listOf(
                "melspectrogram.tflite",
                "embedding.tflite", 
                "wake.tflite"
            )
            
            modelFiles.all { fileName ->
                copyAssetToFile(
                    context,
                    "models/openWakeWord/$fileName",
                    File(context.filesDir, "oww/$fileName")
                )
            }
        } catch (e: Exception) {
            false
        }
    }
}
```

### 6.2 模型下载与缓存

```kotlin
class OpenWakeWordDevice {
    override fun download() {
        _state.value = WakeState.Downloading(Progress.UNKNOWN)
        
        scope.launch {
            try {
                // 优先使用预打包模型
                if (AssetModelManager.hasOpenWakeWordModelsInAssets(appContext)) {
                    val copySuccess = AssetModelManager.copyOpenWakeWordModels(appContext)
                    if (copySuccess) {
                        _state.value = WakeState.NotLoaded
                        return@launch
                    }
                }
                
                // 网络下载备用方案
                owwFolder.mkdirs()
                downloadBinaryFilesWithPartial(
                    urlsFiles = allModelFiles,
                    httpClient = okHttpClient,
                    cacheDir = cacheDir,
                ) { progress ->
                    _state.value = WakeState.Downloading(progress)
                }
                
                _state.value = WakeState.NotLoaded
            } catch (e: Throwable) {
                _state.value = WakeState.ErrorDownloading(e)
            }
        }
    }
}
```

## 7. 音频数据处理

### 7.1 音频格式转换

```kotlin
override fun processFrame(audio16bitPcm: ShortArray): Boolean {
    // 验证帧大小
    if (audio16bitPcm.size != OwwModel.MEL_INPUT_COUNT) {
        throw IllegalArgumentException("Invalid frame size: ${audio16bitPcm.size}")
    }
    
    // 16位PCM转浮点数 (-1.0 到 1.0)
    for (i in 0..<OwwModel.MEL_INPUT_COUNT) {
        audio[i] = audio16bitPcm[i].toFloat() / 32768.0f
    }
    
    // 计算音频幅度用于调试
    val amplitude = audio.maxOf { kotlin.math.abs(it) }
    
    // 模型推理
    val confidence = model!!.processFrame(audio)
    
    // 阈值判断
    val threshold = 0.01f
    val detected = confidence > threshold
    
    return detected
}
```

### 7.2 实时性能优化

```kotlin
// 性能监控
inline fun <T> measureTimeAndLog(tag: String?, operation: String, block: () -> T): T {
    val startTime = System.currentTimeMillis()
    val result = block()
    val endTime = System.currentTimeMillis()
    DebugLogger.logPerformance(tag, operation, endTime - startTime)
    return result
}

// 使用示例
val confidence = measureTimeAndLog(TAG, "Process audio frame") {
    model!!.processFrame(audio)
}
```

## 8. 错误处理与恢复机制

### 8.1 模型加载错误处理

```kotlin
try {
    model = OwwModel(
        melFile.file,
        embFile.file,
        if (userWakeFileExists) userWakeFile else wakeFile.file,
    )
    _state.value = WakeState.Loaded
} catch (t: Throwable) {
    _state.value = WakeState.ErrorLoading(t)
    return false
}
```

### 8.2 音频录制错误恢复

```kotlin
private fun listenForWakeWord() {
    try {
        ar.startRecording()
        
        while (listening.get()) {
            val bytesRead = ar.read(audio, 0, audio.size)
            
            if (bytesRead > 0) {
                // 正常处理
                val wakeWordDetected = wakeDevice.processFrame(audio)
                // ...
            } else {
                // 录制失败，记录错误但继续尝试
                DebugLogger.logWakeWordError(TAG, "AudioRecord read failed: $bytesRead bytes")
            }
        }
    } catch (e: Exception) {
        DebugLogger.logWakeWordError(TAG, "Error in wake word listening", e)
        throw e  // 重新抛出，触发服务重启
    } finally {
        ar.stop()
        ar.release()
    }
}
```

## 9. 调试与监控系统

### 9.1 分类调试日志

```kotlin
object DebugLogger {
    private const val DEBUG_ENABLED = true
    private const val DEBUG_WAKE_WORD = DEBUG_ENABLED && true
    private const val DEBUG_AUDIO_PROCESSING = DEBUG_ENABLED && true
    
    fun logWakeWordDetection(tag: String?, confidence: Float, threshold: Float, detected: Boolean) {
        if (DEBUG_WAKE_WORD && tag != null) {
            val status = if (detected) "✅ DETECTED" else "❌ NOT_DETECTED"
            Log.d("🎯[$tag]", "$status - Confidence: %.3f, Threshold: %.3f".format(confidence, threshold))
        }
    }
    
    fun logAudioStats(tag: String?, frameSize: Int, amplitude: Float, threshold: Float) {
        if (DEBUG_AUDIO_PROCESSING && tag != null) {
            Log.d("📊[$tag]", "Frame: $frameSize, Amplitude: %.3f, Threshold: %.3f".format(amplitude, threshold))
        }
    }
}
```

### 9.2 性能监控

```kotlin
// 帧处理性能统计
val confidence = measureTimeAndLog(TAG, "Process audio frame") {
    model!!.processFrame(audio)
}

// 模型加载性能统计  
model = measureTimeAndLog(TAG, "Load OWW model") {
    OwwModel(melFile.file, embFile.file, wakeFile.file)
}
```

## 10. 集成与交互流程

### 10.1 唤醒词检测到语音识别流程

```kotlin
private fun onWakeWordDetected() {
    // 1. 创建MainActivity意图
    val intent = Intent(this, MainActivity::class.java)
    intent.setAction(ACTION_WAKE_WORD)
    intent.setFlags(FLAG_ACTIVITY_NEW_TASK)
    
    // 2. 启动STT输入设备
    val sttStarted = sttInputDevice.tryLoad(skillEvaluator::processInputEvent)
    
    // 3. 设置STT资源释放定时器
    handler.removeCallbacks(releaseSttResourcesRunnable)
    handler.postDelayed(releaseSttResourcesRunnable, RELEASE_STT_RESOURCES_MILLIS)
    
    // 4. 启动MainActivity
    if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q || MainActivity.isInForeground > 0) {
        startActivity(intent)
    } else {
        // Android 10+ 使用通知方式启动
        showTriggeredNotification()
    }
}
```

### 10.2 MainActivity 响应处理

```kotlin
private fun handleWakeWordTurnOnScreen(intent: Intent?) {
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O_MR1 &&
        intent?.action == ACTION_WAKE_WORD
    ) {
        // 唤醒屏幕
        setShowWhenLocked(true)
        setTurnScreenOn(true)
    }
    
    // 取消唤醒通知
    WakeService.cancelTriggeredNotification(this)
}
```

## 11. 性能优化策略

### 11.1 内存管理
- **模型懒加载**: 仅在需要时加载TensorFlow Lite模型
- **资源释放**: 及时释放AudioRecord和模型资源
- **缓冲区复用**: 复用音频缓冲区避免频繁分配

### 11.2 CPU优化
- **异步处理**: 使用协程进行非阻塞操作
- **帧率控制**: 72ms帧间隔平衡性能和响应性
- **滑动窗口**: 高效的特征累积机制

### 11.3 电池优化
- **前台服务**: 合理使用前台服务避免被系统杀死
- **退避机制**: 防止重复触发浪费资源
- **权限检查**: 及时停止无权限服务

## 12. 技术特点总结

### 12.1 创新点
1. **三阶段神经网络**: Mel → Embedding → Wake Word 的渐进式特征提取
2. **滑动窗口机制**: 高效的时间上下文管理
3. **预打包模型**: 零网络依赖的模型分发
4. **响应式架构**: StateFlow驱动的状态管理

### 12.2 技术优势
1. **高准确率**: 基于深度学习的唤醒词检测
2. **低延迟**: 72ms帧处理间隔，实时响应
3. **可扩展**: 支持自定义唤醒词模型
4. **健壮性**: 完善的错误处理和恢复机制

### 12.3 架构优势
1. **模块化设计**: 清晰的接口分离和依赖注入
2. **状态驱动**: 响应式状态管理确保UI一致性
3. **资源高效**: 智能的模型加载和内存管理
4. **调试友好**: 完善的日志系统和性能监控

## 结论

Dicio的语音唤醒功能展现了现代Android应用中AI集成的最佳实践。通过合理的架构设计、高效的算法实现和完善的工程化措施，系统实现了高性能、低功耗的实时语音唤醒功能。该实现不仅技术先进，而且具有良好的可维护性和可扩展性，为类似项目提供了宝贵的参考价值。
